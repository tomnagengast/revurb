### System

    * **model:** Composer 1
    * **cwd:** .
    * **permission:** default
    * **api key:** login

### User

Your job is to port Laravel Reverb (PHP) to revurb-ts (Typescript) and maintain the repository.
First, read the ./specs/review.md and address any review comments if the status is not ok.
If the status is ok then procceed with the port.

You have access to the current ./ repository and should target revurb-ts for your port.

Make a commit and push your changes after every single file edit.

Use the ./revurb-ts/agent/ directory as a scratchpad for your work. Store long term plans and todo lists there.

The original project was tested with the Pest (https://pestphp.com/) testing framework. When porting, you will need to write end to end and unit tests for the project using Bun's test running (https://bun.com/docs/test.md). But make sure to spend most of your time on the actual porting, not on the testing. A good heuristic is to spend 80% of your time on the actual porting, and 20% on the testing.

### Assistant

Checking ./specs/review.md for review comments and status.

### Tool · read (started)

    * **path:** `specs/review.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `specs/review.md`
    * **status:** success
        * lines: 1-6
    * **content:**

    last commit: 196ada14317180c7f595d9e27f17cc801edfca7c
    status: ok
    review comments:
    - ✅ `revurb-ts/src/loggers/log.ts:34` / `revurb-ts/src/Servers/Reverb/factory.ts:219` – Fixed: `Log.setLogger(this.logger)` is now called inside `Factory.initialize()` method, which is invoked in the bootstrap path (`revurb-ts/src/cli.ts:168`). The Log facade now properly resolves the factory's logger.
    - ✅ `src/Loggers/log.ts:1` – Fixed: The duplicate TypeScript file has been removed from the PHP source tree. The correct location for the Log facade is `revurb-ts/src/loggers/log.ts`.

### Assistant

Status is ok. Reviewing the porting status and what remains to be ported.

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/PORT_COMPARISON_EXECUTIVE_SUMMARY.txt`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/UNPORTED_FILES_SUMMARY.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/PORT_COMPARISON_EXECUTIVE_SUMMARY.txt`
    * **status:** success
        * lines: 1-270
    * **content:**

    ================================================================================
    REVURB PORT ANALYSIS - EXECUTIVE SUMMARY
    PHP to TypeScript Migration Analysis
    Date: 2025-11-12
    ================================================================================
    
    QUICK ANSWER: What's missing from the TypeScript port?
    --------------------------------------------------------------------------------
    NOTHING CRITICAL. All 8 unported files are Laravel framework integration code
    that have no equivalent in a standalone Node.js/TypeScript application.
    
    PORT STATUS
    --------------------------------------------------------------------------------
    Core Files Ported:      76 / 76  (100%)
    Laravel-Specific:        0 / 8   (Correctly excluded)
    Total PHP Files:        84
    Production Ready:       YES ✓
    Tests Passing:          79 / 79 (8 E2E + 71 unit)
    Core Functionality:     100% working
    
    THE 8 UNPORTED FILES (ALL LARAVEL-SPECIFIC)
    --------------------------------------------------------------------------------
    [1-4] Service Providers (4 files)
          - ApplicationManagerServiceProvider.php
          - ReverbServiceProvider.php
          - ServerProviderManager.php
          - ReverbServerProvider.php
          Why: Laravel dependency injection container registration
          Impact: ZERO - TypeScript uses direct imports + Factory pattern
    
    [5-9] Laravel Pulse Integration (5 files)
          - Pulse/Recorders/ReverbMessages.php
          - Pulse/Recorders/ReverbConnections.php
          - Pulse/Livewire/Messages.php
          - Pulse/Livewire/Connections.php
          - Pulse/Livewire/Concerns/HasRate.php
          Why: Laravel Pulse monitoring dashboard (Livewire UI)
          Impact: ZERO - Use external monitoring (Prometheus, DataDog, etc.)
    
    [10-12] Console Commands (3 files)
          - Console/Commands/StartServer.php (replaced by cli.ts)
          - Console/Commands/RestartServer.php (use PM2/systemd/Docker)
          - Console/Commands/InstallCommand.php (simpler config in TS)
          Why: Laravel Artisan CLI commands
          Impact: ZERO - TypeScript has cli.ts with full functionality
    
    [13-14] Console UI Components (2 files)
          - Console/Components/Message.php
          - Console/Components/views/message.php
          Why: Laravel console rendering system
          Impact: ZERO - TypeScript uses standard loggers
    
    [15] Duplicate File (1 file)
          - Servers/Reverb/RedisClientFactory.php (duplicate location)
          Why: Refactoring artifact
          Impact: ZERO - Merged into Publishing/redis-client-factory.ts
    
    WHAT'S INCLUDED (76 FILES PORTED)
    --------------------------------------------------------------------------------
    ✓ Core Application (5 files)
      - Connection, Application, ApplicationManager, Certificate, ConfigProvider
    
    ✓ Loggers (4 files)
      - NullLogger, StandardLogger, CliLogger, Log
    
    ✓ Exceptions (3 files)
      - InvalidApplication, InvalidOrigin, RedisConnectionException
    
    ✓ Background Jobs (2 files)
      - PingInactiveConnections, PruneStaleConnections
    
    ✓ Pusher Protocol (45 files)
      - All channel types (public, private, presence, cache variants)
      - All HTTP controllers (10 controllers)
      - Event system (6 files)
      - Managers (2 files)
      - Exceptions (4 files)
      - Concerns/utilities (2 files)
    
    ✓ Server Infrastructure (14 files)
      - HTTP server and WebSocket handling
      - Redis pub/sub for horizontal scaling
      - Request/response handling
      - Routing system
    
    ✓ Utilities (3 files)
      - InteractsWithApplications, GeneratesIdentifiers, SerializesConnections
    
    KEY DIFFERENCES: PHP vs TypeScript
    --------------------------------------------------------------------------------
    Aspect              | PHP (Laravel)        | TypeScript (Standalone)
    --------------------|----------------------|------------------------
    Dependency Injection| Laravel Container    | Direct imports + Factory
    CLI                 | Artisan commands     | Custom CLI (cli.ts)
    Configuration       | Laravel config       | Env vars + config files
    Monitoring          | Laravel Pulse        | Pluggable (any tool)
    Process Management  | Cache-based restart  | PM2/systemd/Docker
    Event Loop          | ReactPHP             | Bun native async
    WebSocket           | Ratchet              | Bun.serve() native
    HTTP Server         | ReactPHP HTTP        | Bun native HTTP
    
    ARCHITECTURE COMPARISON
    --------------------------------------------------------------------------------
    PHP Version:    WebSocket server INSIDE Laravel framework
                    └─ Requires Laravel ecosystem (service providers, Artisan, etc.)
    
    TypeScript Version: WebSocket server as STANDALONE application
                        └─ Independent, no framework dependencies
    
    VALIDATION CHECKLIST
    --------------------------------------------------------------------------------
    Core Functionality:
    [✓] WebSocket connections and protocol handling
    [✓] Pusher protocol implementation (100%)
    [✓] Channel management (public, private, presence)
    [✓] HTTP API endpoints (all controllers)
    [✓] Redis pub/sub for horizontal scaling
    [✓] Application authentication and authorization
    [✓] Connection lifecycle management
    [✓] Message routing and broadcasting
    [✓] Background jobs (ping, prune)
    [✓] Configuration loading
    [✓] Logging system
    [✓] Exception handling
    
    Test Status:
    [✓] E2E tests: 8 passing (WebSocket, Pusher protocol, channels, routing)
    [✓] Unit tests: 71 passing (channels, events, auth, messages, connections)
    [✓] Total: 79 passing tests
    
    PRODUCTION READINESS
    --------------------------------------------------------------------------------
    Status:     READY FOR PRODUCTION ✓
    Blockers:   NONE
    Known Issues: None affecting core functionality
    
    Optional Enhancements (Non-Blocking):
    - Event system wiring for observability (2-3 hours)
    - DI stub improvements in 2 controllers (30 minutes)
    - TLS verify_peer environment config (15 minutes)
    
    MONITORING & OBSERVABILITY
    --------------------------------------------------------------------------------
    PHP Approach:   Laravel Pulse (Livewire dashboard)
    TS Approach:    Pluggable event system
    
    How to add monitoring to TypeScript version:
    1. Event system exists in src/events/
    2. Add listeners to EventDispatcher
    3. Integrate your monitoring tool:
       - Prometheus metrics exporter
       - DataDog APM
       - CloudWatch metrics
       - Custom logging aggregation
    
    DEPLOYMENT
    --------------------------------------------------------------------------------
    How to run TypeScript version:
    - Development: bun run src/cli.ts start
    - Production: bun start (after build)
    - Process management: PM2, systemd, Docker, Kubernetes
    
    How to restart (PHP used cache flag, TS uses standard approaches):
    - PM2: pm2 restart revurb
    - systemd: systemctl restart revurb
    - Docker: docker restart revurb
    - Kubernetes: Rolling update
    
    CONFIGURATION
    --------------------------------------------------------------------------------
    PHP Approach:   php artisan reverb:install (generates config + env)
    TS Approach:    Manual env vars (simpler)
    
    Required environment variables:
    - REVERB_APP_ID
    - REVERB_APP_KEY
    - REVERB_APP_SECRET
    - REVERB_HOST
    - REVERB_PORT
    - REVERB_SCHEME
    
    (See src/config/load.ts for full configuration options)
    
    DOCUMENT REFERENCE
    --------------------------------------------------------------------------------
    For detailed information, see:
    
    1. PHP_TO_TS_PORT_ANALYSIS.md (19 KB)
       - Comprehensive file-by-file breakdown
       - Detailed reasoning for each exclusion
       - Architecture comparison
       - Lines of code analysis
    
    2. UNPORTED_FILES_SUMMARY.md (6.3 KB)
       - Quick reference for unported files
       - Why each file was excluded
       - Alternatives for TypeScript
    
    3. FILE_MAPPING_COMPLETE.md (15 KB)
       - Complete mapping table (all 84 PHP files)

  … truncated (69 lines omitted)

### Tool · ls (started)

    * **path:** `revurb-ts/agent`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/PORTING_PRIORITY_LIST.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/UNPORTED_FILES_SUMMARY.md`
    * **status:** success
        * lines: 1-170
    * **content:**

    # Unported PHP Files - Quick Reference
    ## All 8 Unported Files are Laravel-Specific Infrastructure
    
    **Date**: 2025-11-12
    **Conclusion**: NO CORE FUNCTIONALITY MISSING
    
    ---
    
    ## Quick Answer: What's NOT Ported?
    
    **Nothing important.** All 8 unported files are Laravel framework integration code that have no equivalent in a standalone TypeScript/Node.js application.
    
    ---
    
    ## The 8 Unported Files (Categorized)
    
    ### 1. Service Providers (4 files) - Framework Boilerplate
    These register services in Laravel's dependency injection container. TypeScript uses direct imports instead.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `ApplicationManagerServiceProvider.php` | Registers ApplicationManager in DI | TS uses direct imports |
    | `ReverbServiceProvider.php` | Main Laravel bootstrap | Replaced by `cli.ts` + `factory.ts` |
    | `ServerProviderManager.php` | Laravel Manager pattern | Direct instantiation in TS |
    | `Servers/Reverb/ReverbServerProvider.php` | Registers console commands | Replaced by `cli.ts` |
    
    **Impact**: Zero. TypeScript doesn't use Laravel's service container.
    
    ---
    
    ### 2. Laravel Pulse Integration (5 files) - Monitoring Dashboard
    Laravel Pulse is a real-time monitoring dashboard with Livewire UI. Not needed for core server functionality.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `Pulse/Recorders/ReverbMessages.php` | Records message metrics | Use external monitoring (Prometheus, etc.) |
    | `Pulse/Recorders/ReverbConnections.php` | Records connection metrics | Use external monitoring |
    | `Pulse/Livewire/Messages.php` | Livewire UI component | No UI needed (standalone server) |
    | `Pulse/Livewire/Connections.php` | Livewire UI component | No UI needed |
    | `Pulse/Livewire/Concerns/HasRate.php` | Trait for rate calculations | No UI needed |
    
    **Impact**: Zero for core functionality. Add your own monitoring with event listeners.
    
    **Alternative**: TypeScript event system in `/tmp/test-revurb/src/events/` allows custom monitoring integration.
    
    ---
    
    ### 3. Laravel Console Commands (3 files) - Artisan CLI
    These are `php artisan` commands. TypeScript has its own CLI.
    
    | File | Purpose | TypeScript Equivalent |
    |------|---------|----------------------|
    | `Servers/Reverb/Console/Commands/StartServer.php` | `reverb:start` command | `/tmp/test-revurb/src/cli.ts` |
    | `Servers/Reverb/Console/Commands/RestartServer.php` | `reverb:restart` command | Use PM2/systemd/Docker |
    | `Console/Commands/InstallCommand.php` | `reverb:install` command | Manual config (simpler) |
    
    **Impact**: Zero. TypeScript CLI is fully functional.
    
    **How to run TypeScript version**: `bun run src/cli.ts start` or `bun start`
    
    ---
    
    ### 4. Laravel Console UI Components (2 files) - Output Formatting
    Custom console rendering components for Laravel's CLI.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `Console/Components/Message.php` | Custom message component | TS uses standard loggers |
    | `Console/Components/views/message.php` | HTML template for above | Not needed |
    
    **Impact**: Zero. TypeScript loggers in `/tmp/test-revurb/src/loggers/` handle output.
    
    ---
    
    ## Duplicate File (1 file) - Refactoring Artifact
    
    | File | Why Skipped |
    |------|-------------|
    | `Servers/Reverb/RedisClientFactory.php` | Duplicate of `Servers/Reverb/Publishing/RedisClientFactory.php` |
    
    **Impact**: Zero. TypeScript merged into one file: `src/Servers/Reverb/Publishing/redis-client-factory.ts`
    
    ---
    
    ## What About These Concerns?
    
    ### "But we need service providers for DI!"
    **Answer**: No, TypeScript uses a Factory pattern. See:
    - `/tmp/test-revurb/src/Servers/Reverb/factory.ts` - Initializes all dependencies
    - Direct imports throughout codebase (no container needed)
    
    ### "But we need monitoring!"
    **Answer**: Event system exists for custom monitoring:
    - `/tmp/test-revurb/src/events/` - Event classes
    - `/tmp/test-revurb/src/events/event-dispatcher.ts` - Event bus
    - Add listeners for Prometheus, DataDog, CloudWatch, etc.
    
    ### "But we need the install command!"
    **Answer**: TypeScript configuration is simpler:
    - Set environment variables in `.env` or config file
    - No framework integration needed
    - See `/tmp/test-revurb/src/config/load.ts` for config loading
    
    ### "But we need the restart command!"
    **Answer**: Use standard Node.js process management:
    - **PM2**: `pm2 restart revurb`
    - **systemd**: `systemctl restart revurb`
    - **Docker**: `docker restart revurb`
    - **Kubernetes**: Rolling update
    
    ---
    
    ## Comparison: What's Different?
    
    | Feature | PHP (Laravel) | TypeScript (Standalone) |
    |---------|---------------|-------------------------|
    | **Dependency Injection** | Laravel Container | Direct imports + Factory |
    | **CLI** | Artisan commands | Custom CLI |
    | **Configuration** | Laravel config system | Env vars + config files |
    | **Monitoring** | Laravel Pulse | Pluggable (bring your own) |
    | **Process Mgmt** | Cache-based restart | PM2/systemd/Docker |
    | **Event Loop** | ReactPHP | Bun native async |
    | **WebSocket** | Ratchet | Bun.serve() |
    
    ---
    
    ## Bottom Line
    
    ### Files Ported: 76 / 84 (90.5%)
    ### Core Functionality: 100%
    ### Production Ready: YES
    
    **The 8 unported files are Laravel glue code, not core features.**
    
    Think of it like this:
    - PHP version: WebSocket server **inside** Laravel framework
    - TypeScript version: WebSocket server as **standalone** application
    
    The TypeScript port extracted the core WebSocket/Pusher functionality and made it independent. Laravel-specific files (service providers, Artisan commands, Pulse) are framework integration that a standalone server doesn't need.
    
    ---
    
    ## Full Details
    
    For comprehensive file-by-file analysis, see:
    - `/tmp/test-revurb/PHP_TO_TS_PORT_ANALYSIS.md` - Complete analysis
    - `/tmp/test-revurb/TYPESCRIPT_PORT_ANALYSIS.md` - Implementation status
    - `/tmp/test-revurb/PORT_ANALYSIS_INDEX.md` - Navigation guide
    
    ---
    
    ## Quick Checklist: Is Anything Missing?
    
    - [ ] WebSocket connections? ✅ Working
    - [ ] Pusher protocol? ✅ Working
    - [ ] Channel subscriptions? ✅ Working
    - [ ] Message routing? ✅ Working
    - [ ] HTTP API? ✅ Working
    - [ ] Redis scaling? ✅ Working
    - [ ] Authentication? ✅ Working
    - [ ] Background jobs? ✅ Working
    - [ ] Configuration? ✅ Working
    - [ ] Logging? ✅ Working
    
    **Result**: Nothing missing. All core functionality present.
    
    ---
    
    **Status**: Port is complete and production-ready. The unported files are framework-specific infrastructure, not features.

### Tool · ls (completed)

    * **path:** `revurb-ts/agent`
    * **status:** success
    * **entries:**

    BUILD_FIXES_COMPLETE.md
    codex-analysis-2025-11-12-1655.md
    COMPREHENSIVE_PORT_STATUS_2025-11-12-1822.md
    CURRENT_SESSION.md
    CURRENT_STATUS_2025-11-12.md
    NEXT_STEPS.md
    PHASE_11_STATUS.md
    PORT_STATUS_SUMMARY.md
    REVIEW_FIXES_APPLIED.md
    REVIEW_FIXES.md
    SESSION_2025-11-12_EVENING.md
    SESSION_2025-11-12-afternoon.md
    SESSION_2025-11-12-continued.md
    SESSION_2025-11-12-evening.md
    SESSION_2025-11-12-FINAL.md
    SESSION_2025-11-12-part2.md
    SESSION_2025-11-12.md
    TODO.md

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/PORTING_PRIORITY_LIST.md`
    * **status:** success
        * lines: 1-338
    * **content:**

    # TypeScript Revurb Port - Prioritized Next Steps
    
    ## STATUS OVERVIEW
    - **Total TypeScript Files**: 86 ✅ All complete
    - **Core Functionality**: ✅ Production-ready
    - **Test Status**: ✅ E2E tests passing (8 tests)
    - **Blockers**: ❌ None - server is fully functional
    
    ---
    
    ## PHASE 1: FIX DEPENDENCY INJECTION STUBS (HIGH PRIORITY)
    **Estimated Time**: 30-45 minutes | **Impact**: Functional correctness
    
    ### 1.1 Fix `channel-users-controller.ts`
    **File**: `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`
    
    **Problem**: Three functions throw "not implemented" errors:
    - `getApplicationProvider()` (line 224)
    - `getChannelManager()` (line 236)  
    - `getMetricsHandler()` (line 248)
    
    **Current Code**:
    ```typescript
    function getApplicationProvider(): any {
      throw new Error('Application provider not implemented. Use dependency injection.');
    }

Solution: Wire to Factory's static getters:

    import { Factory } from '../../factory';
    
    function getApplicationProvider(): any {
      return Factory.getApplicationProvider();
    }
    
    function getChannelManager(): ChannelManager {
      const provider = Factory.getApplicationProvider();
      return Factory.getChannelManager().for(provider);
    }
    
    function getMetricsHandler(): MetricsHandler {
      // Get from Factory or create new instance
      return new MetricsHandler(null, Factory.getChannelManager(), null);
    }

Files to Edit: 

    * `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`

Validation: Controller functions no longer throw errors

------------------------------------------------------------------------------------------

### 1.2 Fix connections-controller.ts

File: /tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/connections-controller.ts

Problem: Same DI stubs as above (3 functions)

Solution: Apply same pattern as 1.1

Files to Edit:

    * `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/connections-controller.ts`

Validation: Controller functions no longer throw errors

------------------------------------------------------------------------------------------

## PHASE 2: IMPLEMENT EVENT DISPATCHER (MEDIUM PRIORITY)

Estimated Time: 1.5-2 hours | Impact: Full observability

### 2.1 Implement EventDispatcher Listener Pattern

File: /tmp/test-revurb/src/events/event-dispatcher.ts

Current State: Stub with only emit() method

Needed:

    * Add listener registry (Map<eventName, listeners>)
    * Implement `on(event, callback)` method
    * Implement `off(event, callback)` method
    * Update `emit(event, data)` to call listeners
    * Handle async listeners properly

Implementation Sketch:

    export class EventDispatcher {
      private static listeners: Map<string, EventListener[]> = new Map();
    
      static on(event: string, listener: EventListener): void {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(listener);
      }
    
      static off(event: string, listener: EventListener): void {
        const list = this.listeners.get(event);
        if (list) {
          const index = list.indexOf(listener);
          if (index > -1) list.splice(index, 1);
        }
      }
    
      static emit(event: string, data?: any): void {
        const listeners = this.listeners.get(event) || [];
        listeners.forEach(listener => listener(data));
      }
    }

Files to Edit:

    * `/tmp/test-revurb/src/events/event-dispatcher.ts`

Validation: Listeners registered and called correctly

------------------------------------------------------------------------------------------

### 2.2 Complete ClientEvent Whisper Implementation

File: /tmp/test-revurb/src/Protocols/Pusher/client-event.ts

Current Code (lines 118-129):

    private static whisper(_connection: Connection, _payload: PusherMessage): void {
      console.warn('ClientEvent.whisper: EventDispatcher not yet implemented');
    }

Solution: Actually dispatch the event:

    private static whisper(connection: Connection, payload: PusherMessage): void {
      EventDispatcher.dispatch(connection.app(), payload, connection);
    }

Files to Edit:

    * `/tmp/test-revurb/src/Protocols/Pusher/client-event.ts`

Validation: Client events logged via dispatcher

------------------------------------------------------------------------------------------

### 2.3 Wire Event Dispatch Throughout Codebase

Files Needing Updates (5 files):

    1. **array-channel-manager.ts** 
       
       
        * Add `ChannelCreated.dispatch()` call when creating channels
       
        * Add `ChannelRemoved.dispatch()` call when removing channels
    2. **event-handler.ts**
       
       
        * Add `MessageReceived.dispatch()` when receiving
       
        * Add `MessageSent.dispatch()` when sending
    3. **server.ts**
       
       
        * Add event dispatches for connection lifecycle
    4. **jobs/prune-stale-connections.ts**
       
       
        * Add `ConnectionPruned.dispatch()` for stale connections
    5. **channel.ts**
       
       
        * Add event dispatch for subscriptions/unsubscriptions

Implementation Pattern:

    // When creating channel:
    channel = new Channel(...);
    ChannelCreated.dispatch(channel);
    
    // When removing channel:
    ChannelRemoved.dispatch(channel);
    
    // When pruning connection:
    ConnectionPruned.dispatch(connection);

Validation: All event dispatch calls integrated and tested

------------------------------------------------------------------------------------------

## PHASE 3: ADD EVENT LISTENERS FOR LOGGING (MEDIUM PRIORITY)

Estimated Time: 30-45 minutes | Impact: Observable server behavior

### 3.1 Wire Event Listeners in CLI

File: /tmp/test-revurb/src/cli.ts

Add: Event listener setup on server initialization:

    import * as Events from './events';
    
    // After Factory.initialize():
    Events.EventDispatcher.on('channel:created', (event) => {
      logger.debug(`Channel created: ${event.channel.name()}`);
    });
    
    Events.EventDispatcher.on('channel:removed', (event) => {
      logger.debug(`Channel removed: ${event.channel.name()}`);
    });
    
    Events.EventDispatcher.on('connection:pruned', (event) => {
      logger.debug(`Connection pruned: ${event.connection.id()}`);
    });

  … truncated (136 lines omitted)
### System

    * **model:** Composer 1
    * **cwd:** .
    * **permission:** default
    * **api key:** login

### User

Your job is to port Laravel Reverb (PHP) to revurb-ts (Typescript) and maintain the repository.
First, read the ./specs/review.md and address any review comments if the status is not ok.
If the status is ok then procceed with the port.

You have access to the current ./ repository and should target revurb-ts for your port.

Make a commit and push your changes after every single file edit.

Use the ./revurb-ts/agent/ directory as a scratchpad for your work. Store long term plans and todo lists there.

The original project was tested with the Pest (https://pestphp.com/) testing framework. When porting, you will need to write end to end and unit tests for the project using Bun's test running (https://bun.com/docs/test.md). But make sure to spend most of your time on the actual porting, not on the testing. A good heuristic is to spend 80% of your time on the actual porting, and 20% on the testing.

### Assistant

Checking ./specs/review.md for review comments and status.

### Tool · read (started)

    * **path:** `specs/review.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `specs/review.md`
    * **status:** success
        * lines: 1-6
    * **content:**

    last commit: 196ada14317180c7f595d9e27f17cc801edfca7c
    status: ok
    review comments:
    - ✅ `revurb-ts/src/loggers/log.ts:34` / `revurb-ts/src/Servers/Reverb/factory.ts:219` – Fixed: `Log.setLogger(this.logger)` is now called inside `Factory.initialize()` method, which is invoked in the bootstrap path (`revurb-ts/src/cli.ts:168`). The Log facade now properly resolves the factory's logger.
    - ✅ `src/Loggers/log.ts:1` – Fixed: The duplicate TypeScript file has been removed from the PHP source tree. The correct location for the Log facade is `revurb-ts/src/loggers/log.ts`.

### Assistant

Status is ok. Review comments are addressed. Checking the agent directory for existing plans and todo lists:

### Tool · ls (started)

    * **path:** `revurb-ts/agent`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/PORT_ANALYSIS_INDEX.md`
    * **status:** pending

### Tool · ls (completed)

    * **path:** `revurb-ts/agent`
    * **status:** success
    * **entries:**

    BUILD_FIXES_COMPLETE.md
    codex-analysis-2025-11-12-1655.md
    COMPREHENSIVE_PORT_STATUS_2025-11-12-1822.md
    CURRENT_SESSION.md
    CURRENT_STATUS_2025-11-12.md
    NEXT_STEPS.md
    PHASE_11_STATUS.md
    PORT_STATUS_SUMMARY.md
    REVIEW_FIXES_APPLIED.md
    REVIEW_FIXES.md
    SESSION_2025-11-12_EVENING.md
    SESSION_2025-11-12-afternoon.md
    SESSION_2025-11-12-continued.md
    SESSION_2025-11-12-evening.md
    SESSION_2025-11-12-FINAL.md
    SESSION_2025-11-12-part2.md
    SESSION_2025-11-12.md
    TODO.md

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/UNPORTED_FILES_SUMMARY.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/PORT_ANALYSIS_INDEX.md`
    * **status:** success
        * lines: 1-209
    * **content:**

    # TypeScript Revurb Port - Analysis Documents Index
    
    Generated: 2025-11-12
    
    ## Quick Navigation
    
    ### For Managers/Leads
    Start here for executive overview:
    - **QUICK_SUMMARY.txt** - One-page reference with all key metrics
      - Status: Production-ready ✅
      - Blockers: None
      - Files needing work: 9 (prioritized)
    
    ### For Developers
    Start here for implementation guidance:
    - **PORTING_PRIORITY_LIST.md** - Detailed phase-by-phase implementation guide
      - Phase 1: Fix DI stubs (30 min)
      - Phase 2: Implement event system (2 hours)
      - Phase 3: Add event listeners (45 min)
      - Phase 4: Security polish (30 min)
      - Includes code examples and validation checklist
    
    ### For Architects
    Start here for system understanding:
    - **TYPESCRIPT_PORT_ANALYSIS.md** - Comprehensive technical analysis
      - File-by-file breakdown
      - Architecture diagrams
      - Dependency graphs
      - Complete statistics
    
    ---
    
    ## Quick Facts
    
    - **Total TypeScript Files**: 86 (all complete)
    - **Core Functionality**: ✅ Production-ready
    - **Test Status**: 8 E2E tests passing
    - **Lines of Code**: ~15,000 TypeScript
    - **Blockers**: ❌ NONE
    - **Time to Full Completion**: 3-4 hours
    
    ---
    
    ## Files Needing Work (Quick Summary)
    
    ### High Priority (30-45 min)
    1. `channel-users-controller.ts` - Fix DI stubs
    2. `connections-controller.ts` - Fix DI stubs
    
    ### Medium Priority (1.5-2 hours)
    3. `event-dispatcher.ts` - Implement listener pattern
    4-8. Event classes (5 files) - Wire dispatch calls
    9. `client-event.ts` - Implement whisper
    
    ### Low Priority (45 min + 30 min)
    10. `cli.ts` - Add event listeners
    11. `factory.ts` - Add TLS environment config
    
    ---
    
    ## Document Details
    
    ### QUICK_SUMMARY.txt (one page)
    - Status overview
    - Prioritized file list with brief descriptions
    - Key metrics and validation results
    - Critical insight and recommendations
    
    **Use when**: You need facts fast, overview for stakeholders
    
    ### PORTING_PRIORITY_LIST.md (detailed guide)
    - Phase-by-phase breakdown
    - Code examples for each phase
    - Line-by-line file references
    - Implementation sequences
    - Validation checklist
    
    **Use when**: You're implementing the fixes, need step-by-step guidance
    
    ### TYPESCRIPT_PORT_ANALYSIS.md (comprehensive reference)
    - Executive summary
    - Detailed analysis of each stubbed file
    - Complete subsystem breakdown
    - Architecture and dependencies
    - Statistics and validation results
    
    **Use when**: You need deep understanding, making architecture decisions
    
    ---
    
    ## Key Insights
    
    1. **Server is ready for production TODAY**
       - All core functionality works
       - No blockers or critical issues
       - Can deploy without remaining work
    
    2. **Remaining work is polish, not core**
       - DI stubs: Code quality improvement (errors won't be triggered)
       - Event system: Observability enhancement (not blocking)
       - TLS config: Security best practice (not blocking)
    
    3. **Intentional skips are correct**
       - 7 empty directories are Laravel-specific
       - TypeScript/Node.js don't need them
       - Not incomplete, correctly excluded
    
    4. **Clear implementation path**
       - 4 phases, well-defined
       - Each phase has specific files
       - Can be done by any developer
       - Estimated 3-4 hours total
    
    ---
    
    ## Recommended Reading Order
    
    **For new developer taking this on:**
    1. Read QUICK_SUMMARY.txt (5 min)
    2. Read PORTING_PRIORITY_LIST.md Phase 1 section (5 min)
    3. Start implementing Phase 1 (30 min)
    4. Read Phases 2-4 as needed
    
    **For architecture review:**
    1. Read TYPESCRIPT_PORT_ANALYSIS.md "Dependency Graph" section
    2. Read "Architecture & Dependencies" section
    3. Review TYPESCRIPT_PORT_ANALYSIS.md "Statistics" section
    
    **For management review:**
    1. Read QUICK_SUMMARY.txt "Critical Insight" section
    2. Look at "Key Metrics" section
    3. Share "Validation Results" section with stakeholders
    
    ---
    
    ## Files This Analysis Covers
    
    ### Complete (86 files, no work needed)
    - Pusher protocol (45 files)
    - Server foundation (14 files)  
    - Infrastructure (27 files)
    
    ### Incomplete (9 files, work needed)
    - Dependency injection (2 files)
    - Event system (6 files)
    - Observability (1 file)
    
    ### Intentionally Skipped (7 directories, Laravel-specific)
    - Console, Pulse, Concerns (correctly omitted)
    
    ---
    
    ## Next Steps
    
    1. **Immediate** (30 min)
       - Read QUICK_SUMMARY.txt
       - Review PORTING_PRIORITY_LIST.md Phase 1
       - Begin implementation
    
    2. **Short Term** (2-3 hours)
       - Complete Phase 1 (DI fixes)
       - Complete Phase 2 (Event system)
       - Run full test suite
    
    3. **Long Term** (polish)
       - Complete Phase 3-4 if needed
       - Add comprehensive unit tests
       - Performance benchmarking
    
    ---
    
    ## Document Metadata
    
    | Document | Size | Content | Best For |
    |----------|------|---------|----------|
    | QUICK_SUMMARY.txt | 9 KB | Facts only, prioritized | Managers, quick lookup |
    | PORTING_PRIORITY_LIST.md | 9 KB | Detailed phases with code | Developers implementing |
    | TYPESCRIPT_PORT_ANALYSIS.md | 11 KB | Comprehensive reference | Architects, deep dives |
    
    **Total Analysis**: 29 KB across 3 focused documents
    
    ---
    
    ## Questions Answered
    
    **Q: Is the server production-ready?**
    A: Yes, deploy today. Remaining work is polish.
    
    **Q: How long until fully complete?**
    A: 3-4 hours of development, can be parallelized.
    
    **Q: What are the blockers?**
    A: None. All core functionality works.
    
    **Q: Why are some directories empty?**
    A: They're Laravel-specific, correctly excluded.
    
    **Q: Which files should I work on first?**
    A: Start with Phase 1 DI fixes (quickest wins).
    

  … truncated (8 lines omitted)

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/UNPORTED_FILES_SUMMARY.md`
    * **status:** success
        * lines: 1-170
    * **content:**

    # Unported PHP Files - Quick Reference
    ## All 8 Unported Files are Laravel-Specific Infrastructure
    
    **Date**: 2025-11-12
    **Conclusion**: NO CORE FUNCTIONALITY MISSING
    
    ---
    
    ## Quick Answer: What's NOT Ported?
    
    **Nothing important.** All 8 unported files are Laravel framework integration code that have no equivalent in a standalone TypeScript/Node.js application.
    
    ---
    
    ## The 8 Unported Files (Categorized)
    
    ### 1. Service Providers (4 files) - Framework Boilerplate
    These register services in Laravel's dependency injection container. TypeScript uses direct imports instead.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `ApplicationManagerServiceProvider.php` | Registers ApplicationManager in DI | TS uses direct imports |
    | `ReverbServiceProvider.php` | Main Laravel bootstrap | Replaced by `cli.ts` + `factory.ts` |
    | `ServerProviderManager.php` | Laravel Manager pattern | Direct instantiation in TS |
    | `Servers/Reverb/ReverbServerProvider.php` | Registers console commands | Replaced by `cli.ts` |
    
    **Impact**: Zero. TypeScript doesn't use Laravel's service container.
    
    ---
    
    ### 2. Laravel Pulse Integration (5 files) - Monitoring Dashboard
    Laravel Pulse is a real-time monitoring dashboard with Livewire UI. Not needed for core server functionality.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `Pulse/Recorders/ReverbMessages.php` | Records message metrics | Use external monitoring (Prometheus, etc.) |
    | `Pulse/Recorders/ReverbConnections.php` | Records connection metrics | Use external monitoring |
    | `Pulse/Livewire/Messages.php` | Livewire UI component | No UI needed (standalone server) |
    | `Pulse/Livewire/Connections.php` | Livewire UI component | No UI needed |
    | `Pulse/Livewire/Concerns/HasRate.php` | Trait for rate calculations | No UI needed |
    
    **Impact**: Zero for core functionality. Add your own monitoring with event listeners.
    
    **Alternative**: TypeScript event system in `/tmp/test-revurb/src/events/` allows custom monitoring integration.
    
    ---
    
    ### 3. Laravel Console Commands (3 files) - Artisan CLI
    These are `php artisan` commands. TypeScript has its own CLI.
    
    | File | Purpose | TypeScript Equivalent |
    |------|---------|----------------------|
    | `Servers/Reverb/Console/Commands/StartServer.php` | `reverb:start` command | `/tmp/test-revurb/src/cli.ts` |
    | `Servers/Reverb/Console/Commands/RestartServer.php` | `reverb:restart` command | Use PM2/systemd/Docker |
    | `Console/Commands/InstallCommand.php` | `reverb:install` command | Manual config (simpler) |
    
    **Impact**: Zero. TypeScript CLI is fully functional.
    
    **How to run TypeScript version**: `bun run src/cli.ts start` or `bun start`
    
    ---
    
    ### 4. Laravel Console UI Components (2 files) - Output Formatting
    Custom console rendering components for Laravel's CLI.
    
    | File | Purpose | Why Skipped |
    |------|---------|-------------|
    | `Console/Components/Message.php` | Custom message component | TS uses standard loggers |
    | `Console/Components/views/message.php` | HTML template for above | Not needed |
    
    **Impact**: Zero. TypeScript loggers in `/tmp/test-revurb/src/loggers/` handle output.
    
    ---
    
    ## Duplicate File (1 file) - Refactoring Artifact
    
    | File | Why Skipped |
    |------|-------------|
    | `Servers/Reverb/RedisClientFactory.php` | Duplicate of `Servers/Reverb/Publishing/RedisClientFactory.php` |
    
    **Impact**: Zero. TypeScript merged into one file: `src/Servers/Reverb/Publishing/redis-client-factory.ts`
    
    ---
    
    ## What About These Concerns?
    
    ### "But we need service providers for DI!"
    **Answer**: No, TypeScript uses a Factory pattern. See:
    - `/tmp/test-revurb/src/Servers/Reverb/factory.ts` - Initializes all dependencies
    - Direct imports throughout codebase (no container needed)
    
    ### "But we need monitoring!"
    **Answer**: Event system exists for custom monitoring:
    - `/tmp/test-revurb/src/events/` - Event classes
    - `/tmp/test-revurb/src/events/event-dispatcher.ts` - Event bus
    - Add listeners for Prometheus, DataDog, CloudWatch, etc.
    
    ### "But we need the install command!"
    **Answer**: TypeScript configuration is simpler:
    - Set environment variables in `.env` or config file
    - No framework integration needed
    - See `/tmp/test-revurb/src/config/load.ts` for config loading
    
    ### "But we need the restart command!"
    **Answer**: Use standard Node.js process management:
    - **PM2**: `pm2 restart revurb`
    - **systemd**: `systemctl restart revurb`
    - **Docker**: `docker restart revurb`
    - **Kubernetes**: Rolling update
    
    ---
    
    ## Comparison: What's Different?
    
    | Feature | PHP (Laravel) | TypeScript (Standalone) |
    |---------|---------------|-------------------------|
    | **Dependency Injection** | Laravel Container | Direct imports + Factory |
    | **CLI** | Artisan commands | Custom CLI |
    | **Configuration** | Laravel config system | Env vars + config files |
    | **Monitoring** | Laravel Pulse | Pluggable (bring your own) |
    | **Process Mgmt** | Cache-based restart | PM2/systemd/Docker |
    | **Event Loop** | ReactPHP | Bun native async |
    | **WebSocket** | Ratchet | Bun.serve() |
    
    ---
    
    ## Bottom Line
    
    ### Files Ported: 76 / 84 (90.5%)
    ### Core Functionality: 100%
    ### Production Ready: YES
    
    **The 8 unported files are Laravel glue code, not core features.**
    
    Think of it like this:
    - PHP version: WebSocket server **inside** Laravel framework
    - TypeScript version: WebSocket server as **standalone** application
    
    The TypeScript port extracted the core WebSocket/Pusher functionality and made it independent. Laravel-specific files (service providers, Artisan commands, Pulse) are framework integration that a standalone server doesn't need.
    
    ---
    
    ## Full Details
    
    For comprehensive file-by-file analysis, see:
    - `/tmp/test-revurb/PHP_TO_TS_PORT_ANALYSIS.md` - Complete analysis
    - `/tmp/test-revurb/TYPESCRIPT_PORT_ANALYSIS.md` - Implementation status
    - `/tmp/test-revurb/PORT_ANALYSIS_INDEX.md` - Navigation guide
    
    ---
    
    ## Quick Checklist: Is Anything Missing?
    
    - [ ] WebSocket connections? ✅ Working
    - [ ] Pusher protocol? ✅ Working
    - [ ] Channel subscriptions? ✅ Working
    - [ ] Message routing? ✅ Working
    - [ ] HTTP API? ✅ Working
    - [ ] Redis scaling? ✅ Working
    - [ ] Authentication? ✅ Working
    - [ ] Background jobs? ✅ Working
    - [ ] Configuration? ✅ Working
    - [ ] Logging? ✅ Working
    
    **Result**: Nothing missing. All core functionality present.
    
    ---
    
    **Status**: Port is complete and production-ready. The unported files are framework-specific infrastructure, not features.

### Assistant

Checking TODO and NEXT_STEPS for remaining work:

### Tool · read (started)

    * **path:** `revurb-ts/agent/TODO.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/agent/TODO.md`
    * **status:** success
        * lines: 1-92
    * **content:**

    # TODO: Remaining Work for Revurb Port
    
    ## Status: 95% Complete ✅
    
    ### Core Features - DONE ✅
    All core WebSocket server functionality is complete and tested:
    - ✅ WebSocket connection handling
    - ✅ Pusher protocol implementation
    - ✅ Channel management (public, private, presence)
    - ✅ Event dispatching
    - ✅ Connection lifecycle
    - ✅ Authentication & authorization
    - ✅ CLI interface
    - ✅ Configuration system
    - ✅ HTTP API endpoints
    - ✅ Redis pub/sub
    - ✅ Metrics tracking
    
    ### Tests - DONE ✅
    - ✅ 79 tests passing (100%)
    - ✅ 0 TypeScript compilation errors
    - ✅ E2E, Feature, and Unit test coverage
    
    ### Laravel-Specific Files (Not Needed for TypeScript Port)
    These files are Laravel framework-specific and not applicable to the TypeScript port:
    
    1. **Service Providers** (Laravel DI container)
       - `src/ApplicationManagerServiceProvider.php`
       - `src/ReverbServiceProvider.php`
       - `src/Servers/Reverb/ReverbServerProvider.php`
       - `src/ServerProviderManager.php`
    
    2. **Console Commands** (Laravel Artisan)
       - `src/Console/Commands/InstallCommand.php`
       - `src/Servers/Reverb/Console/Commands/RestartServer.php`
       - `src/Servers/Reverb/Console/Commands/StartServer.php`
    
    3. **Pulse Integration** (Laravel monitoring tool)
       - `src/Pulse/Livewire/Concerns/HasRate.php`
       - `src/Pulse/Livewire/Connections.php`
       - `src/Pulse/Livewire/Messages.php`
       - `src/Pulse/Recorders/ReverbConnections.php`
       - `src/Pulse/Recorders/ReverbMessages.php`
    
    4. **Livewire Components** (Laravel UI framework)
       - `src/Console/Components/Message.php`
       - `src/Console/Components/views/message.php`
    
    5. **Legacy/Deprecated**
       - `src/Servers/Reverb/RedisClientFactory.php` (replaced by Publishing/redis-client-factory.ts)
       - `src/Servers/Reverb/Concerns/ClosesConnections.php` (functionality integrated into factory.ts)
    
    ### Optional Enhancements (Low Priority)
    
    1. **Additional Testing**
       - Performance tests
       - Stress tests
       - Load testing
       - Security testing
    
    2. **Monitoring & Observability**
       - Optional Pulse-like monitoring system
       - Prometheus metrics exporter
       - Grafana dashboards
    
    3. **Operational Tools**
       - Restart command (graceful restart without downtime)
       - Status command (show server stats)
       - Config validation command
    
    4. **Documentation** (ONLY if explicitly requested)
       - API documentation
       - Usage examples
       - Migration guide from Laravel Reverb
       - Deployment guide
    
    ## Next Actions
    
    Given the project is 95% complete with all core features working:
    
    1. **Wait for user feedback** - The server is production-ready
    2. **Fix any bugs** that arise from real-world usage
    3. **Add features** as requested by the user
    4. **Improve test coverage** if specific edge cases are found
    
    ## Notes
    
    - The TypeScript port is functionally complete
    - All Laravel-specific features have been replaced with TypeScript equivalents
    - The server is production-ready and tested
    - No critical work remaining unless user requests specific features

### Tool · read (started)

    * **path:** `revurb-ts/agent/NEXT_STEPS.md`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/_tmp/PORTING_PRIORITY_LIST.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/agent/NEXT_STEPS.md`
    * **status:** success
        * lines: 1-152
    * **content:**

    # Next Steps for Revurb TypeScript Port
    
    ## Current Status
    
    **Date**: 2025-11-12 Evening
    **TypeScript Errors**: 0 ✅
    **Port Completeness**: 98%
    **Production Ready**: YES
    
    ## What Just Got Done
    
    ### Fixed All TypeScript Compilation Errors
    - **client-event.ts**: Fixed static method trying to call instance method
    - **pusher-messages.ts**: Added index signature for Record compatibility
    - **event-handler.ts**: Added missing `for()` method to local ChannelManager interface
    - **connection.ts**: Marked unused variables with @ts-expect-error
    - **factory.ts**: Updated return types to allow `undefined` (Bun requirement)
    
    **Result**: `bun run typecheck` now passes with 0 errors!
    
    ## Remaining Work (Priority Order)
    
    ### High Priority (If Needed)
    
    #### 1. Verify DI Implementation in Controllers
    **Files**:
    - `src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`
    - `src/Protocols/Pusher/Http/Controllers/connections-controller.ts`
    
    **Issue**: Check if `getMetricsHandler()` is still throwing or if it was fixed in previous session.
    
    **Action**: Search for "TODO: Add getMetricsHandler()" and verify implementation.
    
    **Validation**: Test endpoints `/apps/{appId}/channels/{channel}/users` and `/apps/{appId}/connections`
    
    #### 2. Run E2E Test Suite
    **Command**:
    ```bash
    cd /tmp/test-revurb
    bun test

Expected: All tests should pass since TypeScript errors are fixed.

If tests fail: Investigate runtime issues vs compile-time fixes.

### Medium Priority (Nice to Have)

#### 3. Wire Event Listeners for Observability

File: src/cli.ts

Task: Add event listeners for logging:

    import { EventDispatcher } from './events';
    
    // After Factory.initialize():
    EventDispatcher.on('channel:created', (event) => {
      logger.debug(`Channel created: ${event.channel.name()}`);
    });
    
    EventDispatcher.on('channel:removed', (event) => {
      logger.debug(`Channel removed: ${event.channel.name()}`);
    });
    
    EventDispatcher.on('connection:pruned', (event) => {
      logger.debug(`Connection pruned: ${event.connection.id()}`);
    });

Benefit: Better visibility into server behavior for debugging.

#### 4. Review and Clean Up Unused Code

Files to check:

    * `src/Servers/Reverb/connection.ts` - _handleMessage and _onCloseHandler

Decision needed:

    * Remove if not planned for future use
    * Implement if they serve a purpose
    * Keep with better documentation of intent

### Low Priority (Polish)

#### 5. TLS Environment Configuration

File: src/Servers/Reverb/factory.ts

Issue: TODO comment about verify_peer setting based on environment.

Task: Pass environment through config and set verify_peer correctly.

#### 6. Documentation Updates

    * Update README with TypeScript-specific information
    * Add migration guide from Laravel Reverb
    * Document any API differences

#### 7. Performance Testing

    * Benchmark against Laravel Reverb
    * Test under load (1000+ concurrent connections)
    * Memory profiling

## Validation Checklist

Before considering the port "complete":

    * [X]  All TypeScript errors resolved
    * [ ]  All tests passing
    * [ ]  Manual testing of key features:
        * [ ]  WebSocket connection establishment
      
        * [ ]  Channel subscription (public, private, presence)
      
        * [ ]  Message broadcasting
      
        * [ ]  Client events
      
        * [ ]  HTTP API endpoints
    * [ ]  Performance acceptable
    * [ ]  No memory leaks
    * [ ]  Documentation complete

## Commands Reference

    # Type checking
    cd /tmp/test-revurb
    bun run typecheck
    
    # Run tests
    bun test
    
    # Start server
    export REVERB_APP_KEY=test-key
    export REVERB_APP_SECRET=test-secret
    export REVERB_APP_ID=test-id
    bun run src/cli.ts start
    
    # Check health
    curl http://127.0.0.1:8080/up
    
    # Test WebSocket (requires wscat or similar)
    wscat -c ws://127.0.0.1:8080/app/test-key

## Git Status

Current Commit: fix: resolve all TypeScript compilation errors
Files Changed: 5
Remote: No remote configured (local repo only)

## Notes

    * The port is functionally complete and ready for production use
    * TypeScript type safety is fully enforced
    * All core Pusher protocol features implemented
    * Event system is operational
    * Only optional enhancements and polish remain

### Tool · read (completed)

    * **path:** `revurb-ts/_tmp/PORTING_PRIORITY_LIST.md`
    * **status:** success
        * lines: 1-338
    * **content:**

    # TypeScript Revurb Port - Prioritized Next Steps
    
    ## STATUS OVERVIEW
    - **Total TypeScript Files**: 86 ✅ All complete
    - **Core Functionality**: ✅ Production-ready
    - **Test Status**: ✅ E2E tests passing (8 tests)
    - **Blockers**: ❌ None - server is fully functional
    
    ---
    
    ## PHASE 1: FIX DEPENDENCY INJECTION STUBS (HIGH PRIORITY)
    **Estimated Time**: 30-45 minutes | **Impact**: Functional correctness
    
    ### 1.1 Fix `channel-users-controller.ts`
    **File**: `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`
    
    **Problem**: Three functions throw "not implemented" errors:
    - `getApplicationProvider()` (line 224)
    - `getChannelManager()` (line 236)  
    - `getMetricsHandler()` (line 248)
    
    **Current Code**:
    ```typescript
    function getApplicationProvider(): any {
      throw new Error('Application provider not implemented. Use dependency injection.');
    }

Solution: Wire to Factory's static getters:

    import { Factory } from '../../factory';
    
    function getApplicationProvider(): any {
      return Factory.getApplicationProvider();
    }
    
    function getChannelManager(): ChannelManager {
      const provider = Factory.getApplicationProvider();
      return Factory.getChannelManager().for(provider);
    }
    
    function getMetricsHandler(): MetricsHandler {
      // Get from Factory or create new instance
      return new MetricsHandler(null, Factory.getChannelManager(), null);
    }

Files to Edit: 

    * `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`

Validation: Controller functions no longer throw errors

------------------------------------------------------------------------------------------

### 1.2 Fix connections-controller.ts

File: /tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/connections-controller.ts

Problem: Same DI stubs as above (3 functions)

Solution: Apply same pattern as 1.1

Files to Edit:

    * `/tmp/test-revurb/src/Protocols/Pusher/Http/Controllers/connections-controller.ts`

Validation: Controller functions no longer throw errors

------------------------------------------------------------------------------------------

## PHASE 2: IMPLEMENT EVENT DISPATCHER (MEDIUM PRIORITY)

Estimated Time: 1.5-2 hours | Impact: Full observability

### 2.1 Implement EventDispatcher Listener Pattern

File: /tmp/test-revurb/src/events/event-dispatcher.ts

Current State: Stub with only emit() method

Needed:

    * Add listener registry (Map<eventName, listeners>)
    * Implement `on(event, callback)` method
    * Implement `off(event, callback)` method
    * Update `emit(event, data)` to call listeners
    * Handle async listeners properly

Implementation Sketch:

    export class EventDispatcher {
      private static listeners: Map<string, EventListener[]> = new Map();
    
      static on(event: string, listener: EventListener): void {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(listener);
      }
    
      static off(event: string, listener: EventListener): void {
        const list = this.listeners.get(event);
        if (list) {
          const index = list.indexOf(listener);
          if (index > -1) list.splice(index, 1);
        }
      }
    
      static emit(event: string, data?: any): void {
        const listeners = this.listeners.get(event) || [];
        listeners.forEach(listener => listener(data));
      }
    }

Files to Edit:

    * `/tmp/test-revurb/src/events/event-dispatcher.ts`

Validation: Listeners registered and called correctly

------------------------------------------------------------------------------------------

### 2.2 Complete ClientEvent Whisper Implementation

File: /tmp/test-revurb/src/Protocols/Pusher/client-event.ts

Current Code (lines 118-129):

    private static whisper(_connection: Connection, _payload: PusherMessage): void {
      console.warn('ClientEvent.whisper: EventDispatcher not yet implemented');
    }

Solution: Actually dispatch the event:

    private static whisper(connection: Connection, payload: PusherMessage): void {
      EventDispatcher.dispatch(connection.app(), payload, connection);
    }

Files to Edit:

    * `/tmp/test-revurb/src/Protocols/Pusher/client-event.ts`

Validation: Client events logged via dispatcher

------------------------------------------------------------------------------------------

### 2.3 Wire Event Dispatch Throughout Codebase

Files Needing Updates (5 files):

    1. **array-channel-manager.ts** 
       
       
        * Add `ChannelCreated.dispatch()` call when creating channels
       
        * Add `ChannelRemoved.dispatch()` call when removing channels
    2. **event-handler.ts**
       
       
        * Add `MessageReceived.dispatch()` when receiving
       
        * Add `MessageSent.dispatch()` when sending
    3. **server.ts**
       
       
        * Add event dispatches for connection lifecycle
    4. **jobs/prune-stale-connections.ts**
       
       
        * Add `ConnectionPruned.dispatch()` for stale connections
    5. **channel.ts**
       
       
        * Add event dispatch for subscriptions/unsubscriptions

Implementation Pattern:

    // When creating channel:
    channel = new Channel(...);
    ChannelCreated.dispatch(channel);
    
    // When removing channel:
    ChannelRemoved.dispatch(channel);
    
    // When pruning connection:
    ConnectionPruned.dispatch(connection);

Validation: All event dispatch calls integrated and tested

------------------------------------------------------------------------------------------

## PHASE 3: ADD EVENT LISTENERS FOR LOGGING (MEDIUM PRIORITY)

Estimated Time: 30-45 minutes | Impact: Observable server behavior

### 3.1 Wire Event Listeners in CLI

File: /tmp/test-revurb/src/cli.ts

Add: Event listener setup on server initialization:

    import * as Events from './events';
    
    // After Factory.initialize():
    Events.EventDispatcher.on('channel:created', (event) => {
      logger.debug(`Channel created: ${event.channel.name()}`);
    });
    
    Events.EventDispatcher.on('channel:removed', (event) => {
      logger.debug(`Channel removed: ${event.channel.name()}`);
    });
    
    Events.EventDispatcher.on('connection:pruned', (event) => {
      logger.debug(`Connection pruned: ${event.connection.id()}`);
    });

  … truncated (136 lines omitted)

### Assistant

Checking the current state of the files that need work, starting with Phase 1 (DI stubs):

### Tool · read (started)

    * **path:** `revurb-ts/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/src/Protocols/Pusher/Http/Controllers/connections-controller.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/src/events/event-dispatcher.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/src/Protocols/Pusher/Http/Controllers/channel-users-controller.ts`
    * **status:** success
        * lines: 1-245
    * **content:**

    import type { Application } from '../../../../application';
    import type { ChannelManager } from '../../Contracts/channel-manager';
    import { MetricsHandler } from '../../metrics-handler';
    import { Response } from '../../../../Servers/Reverb/Http/response';
    import { isPresenceChannel } from '../../Concerns/interacts-with-channel-information';
    import { Factory } from '../../../../Servers/Reverb/factory';
    
    /**
     * Channel Users Controller
     *
     * Handles GET requests to retrieve the list of users in a presence channel.
     *
     * Endpoint: GET /apps/:appId/channels/:channel/users
     *
     * Returns:
     * - 404 if channel doesn't exist
     * - 400 if channel is not a presence channel
     * - 200 with list of users if successful
     *
     * Response Format:
     * {
     *   "users": [
     *     { "id": "user_id_1" },
     *     { "id": "user_id_2" },
     *     ...
     *   ]
     * }
     *
     * Authentication:
     * - Requires valid Pusher authentication signature
     * - Validates using auth_signature query parameter
     *
     * @example
     * ```typescript
     * // Usage in router
     * router.get('/apps/:appId/channels/:channel/users', channelUsersController);
     *
     * // Sample request
     * GET /apps/123456/channels/presence-chat/users?auth_key=...&auth_signature=...
     * ```
     */
    export async function channelUsersController(
      request: any,
      _connection: any,
      channel: string,
      appId: string
    ): Promise<Response> {
      // Verify authentication and set up application/channels
      const { application, channels } = await verify(request, _connection, appId);
    
      // Find the channel
      const channelInstance = channels.for(application).find(channel);
    
      if (!channelInstance) {
        return new Response({}, 404);
      }
    
      // Check if it's a presence channel
      if (!isPresenceChannel(channelInstance)) {
        return new Response({}, 400);
      }
    
      // Get metrics handler instance
      const metricsHandler = getMetricsHandler();
    
      // Gather channel users metrics
      const users = await metricsHandler.gather(application, 'channel_users', {
        channel: channel,
      });
    
      return new Response({ users });
    }
    
    /**
     * Verify the request authentication and set up application/channels.
     *
     * This function:
     * 1. Parses query parameters
     * 2. Extracts request body
     * 3. Sets the application instance
     * 4. Sets the channel manager
     * 5. Verifies the Pusher authentication signature
     *
     * @param request - The HTTP request object
     * @param connection - The connection object
     * @param appId - The application ID from route parameters
     * @returns Object containing application and channels instances
     * @throws {Error} If authentication fails or application not found
     */
    async function verify(
      request: any,
      _connection: any,
      appId: string
    ): Promise<{ application: Application; channels: ChannelManager }> {
      // Parse query parameters
      const url = new URL(request.url || request.getPath?.() || '', 'http://localhost');
      const query: Record<string, string> = {};
      url.searchParams.forEach((value, key) => {
        query[key] = value;
      });
    
      // Get request body
      const body = request.body || (await request.text?.()) || '';
    
      // Set application
      const application = await setApplication(appId);
    
      // Set channels
      const channels = getChannelManager();
    
      // Verify signature
      verifySignature(request, query, body, application);
    
      return { application, channels };
    }
    
    /**
     * Set the application instance for the given app ID.
     *
     * @param appId - The application ID
     * @returns The application instance
     * @throws {Error} If application not found
     */
    async function setApplication(appId: string | null): Promise<Application> {
      if (!appId) {
        throw new Error('Application ID not provided.');
      }
    
      const applicationProvider = getApplicationProvider();
    
      try {
        return await applicationProvider.findById(appId);
      } catch (error) {
        throw new Error(`No matching application for ID [${appId}].`);
      }
    }
    
    /**
     * Verify the Pusher authentication signature.
     *
     * @param request - The HTTP request object
     * @param query - The parsed query parameters
     * @param body - The request body
     * @param application - The application instance
     * @throws {Error} If signature is invalid
     */
    function verifySignature(
      request: any,
      query: Record<string, string>,
      body: string,
      application: Application
    ): void {
      const crypto = require('crypto');
    
      // Prepare params for signature (exclude auth_signature and internal params)
      const params: Record<string, string> = {};
      for (const [key, value] of Object.entries(query)) {
        if (!['auth_signature', 'body_md5', 'appId', 'appKey', 'channelName'].includes(key)) {
          params[key] = value;
        }
      }
    
      // Add body_md5 if body is not empty
      if (body !== '') {
        params['body_md5'] = crypto.createHash('md5').update(body).digest('hex');
      }
    
      // Sort params by key
      const sortedKeys = Object.keys(params).sort();
      const sortedParams: Record<string, string> = {};
      for (const key of sortedKeys) {
        sortedParams[key] = params[key] ?? '';
      }
    
      // Format params for verification
      const queryString = formatQueryParametersForVerification(sortedParams);
    
      // Build signature string
      const method = request.method || request.getMethod?.() || 'GET';
      const path = request.url
        ? new URL(request.url, 'http://localhost').pathname
        : request.getPath?.() || '/';
    
      const signatureString = [method, path, queryString].join('\n');
    
      // Generate signature
      const signature = crypto
        .createHmac('sha256', application.secret())
        .update(signatureString)
        .digest('hex');
    
      const authSignature = query['auth_signature'] || '';
    
      if (signature !== authSignature) {
        throw new Error('Authentication signature invalid.');
      }
    }
    
    /**
     * Format query parameters for signature verification.

  … truncated (44 lines omitted)

### Tool · read (completed)

    * **path:** `revurb-ts/src/Protocols/Pusher/Http/Controllers/connections-controller.ts`
    * **status:** success
        * lines: 1-226
    * **content:**

    import type { Application } from '../../../../application';
    import type { ChannelManager } from '../../Contracts/channel-manager';
    import { MetricsHandler } from '../../metrics-handler';
    import { Response } from '../../../../Servers/Reverb/Http/response';
    import { Factory } from '../../../../Servers/Reverb/factory';
    
    /**
     * Connections Controller
     *
     * Handles GET requests to retrieve connection information for an application.
     *
     * Endpoint: GET /apps/:appId/connections
     *
     * Returns:
     * - 200 with connection count if successful
     *
     * Response Format:
     * {
     *   "connections": <number of active connections>
     * }
     *
     * Authentication:
     * - Requires valid Pusher authentication signature
     * - Validates using auth_signature query parameter
     *
     * @example
     * ```typescript
     * // Usage in router
     * router.get('/apps/:appId/connections', connectionsController);
     *
     * // Sample request
     * GET /apps/123456/connections?auth_key=...&auth_signature=...
     * ```
     */
    export async function connectionsController(
      request: any,
      _connection: any,
      appId: string
    ): Promise<Response> {
      // Verify authentication and set up application/channels
      const { application } = await verify(request, _connection, appId);
    
      // Get metrics handler instance
      const metricsHandler = getMetricsHandler();
    
      // Gather connections metrics
      const connections = await metricsHandler.gather(application, 'connections');
    
      // Count the connections
      const connectionCount = Object.keys(connections).length;
    
      return new Response({ connections: connectionCount });
    }
    
    /**
     * Verify the request authentication and set up application/channels.
     *
     * This function:
     * 1. Parses query parameters
     * 2. Extracts request body
     * 3. Sets the application instance
     * 4. Sets the channel manager
     * 5. Verifies the Pusher authentication signature
     *
     * @param request - The HTTP request object
     * @param connection - The connection object
     * @param appId - The application ID from route parameters
     * @returns Object containing application and channels instances
     * @throws {Error} If authentication fails or application not found
     */
    async function verify(
      request: any,
      _connection: any,
      appId: string
    ): Promise<{ application: Application; channels: ChannelManager }> {
      // Parse query parameters
      const url = new URL(request.url || request.getPath?.() || '', 'http://localhost');
      const query: Record<string, string> = {};
      url.searchParams.forEach((value, key) => {
        query[key] = value;
      });
    
      // Get request body
      const body = request.body || (await request.text?.()) || '';
    
      // Set application
      const application = await setApplication(appId);
    
      // Set channels
      const channels = getChannelManager();
    
      // Verify signature
      verifySignature(request, query, body, application);
    
      return { application, channels };
    }
    
    /**
     * Set the application instance for the given app ID.
     *
     * @param appId - The application ID
     * @returns The application instance
     * @throws {Error} If application not found
     */
    async function setApplication(appId: string | null): Promise<Application> {
      if (!appId) {
        throw new Error('Application ID not provided.');
      }
    
      const applicationProvider = getApplicationProvider();
    
      try {
        return await applicationProvider.findById(appId);
      } catch (error) {
        throw new Error(`No matching application for ID [${appId}].`);
      }
    }
    
    /**
     * Verify the Pusher authentication signature.
     *
     * @param request - The HTTP request object
     * @param query - The parsed query parameters
     * @param body - The request body
     * @param application - The application instance
     * @throws {Error} If signature is invalid
     */
    function verifySignature(
      request: any,
      query: Record<string, string>,
      body: string,
      application: Application
    ): void {
      const crypto = require('crypto');
    
      // Prepare params for signature (exclude auth_signature and internal params)
      const params: Record<string, string> = {};
      for (const [key, value] of Object.entries(query)) {
        if (!['auth_signature', 'body_md5', 'appId', 'appKey', 'channelName'].includes(key)) {
          params[key] = value;
        }
      }
    
      // Add body_md5 if body is not empty
      if (body !== '') {
        params['body_md5'] = crypto.createHash('md5').update(body).digest('hex');
      }
    
      // Sort params by key
      const sortedKeys = Object.keys(params).sort();
      const sortedParams: Record<string, string> = {};
      for (const key of sortedKeys) {
        sortedParams[key] = params[key] ?? '';
      }
    
      // Format params for verification
      const queryString = formatQueryParametersForVerification(sortedParams);
    
      // Build signature string
      const method = request.method || request.getMethod?.() || 'GET';
      const path = request.url
        ? new URL(request.url, 'http://localhost').pathname
        : request.getPath?.() || '/';
    
      const signatureString = [method, path, queryString].join('\n');
    
      // Generate signature
      const signature = crypto
        .createHmac('sha256', application.secret())
        .update(signatureString)
        .digest('hex');
    
      const authSignature = query['auth_signature'] || '';
    
      if (signature !== authSignature) {
        throw new Error('Authentication signature invalid.');
      }
    }
    
    /**
     * Format query parameters for signature verification.
     *
     * @param params - The parameters to format
     * @returns Formatted query string
     */
    function formatQueryParametersForVerification(params: Record<string, string | string[]>): string {
      const parts: string[] = [];
    
      for (const [key, value] of Object.entries(params)) {
        if (Array.isArray(value)) {
          parts.push(`${key}=${value.join(',')}`);
        } else {
          parts.push(`${key}=${value}`);
        }
      }
    
      return parts.join('&');
    }
    
    /**

  … truncated (25 lines omitted)

### Tool · read (completed)

    * **path:** `revurb-ts/src/events/event-dispatcher.ts`
    * **status:** success
        * lines: 1-161
    * **content:**

    /**
     * Event Dispatcher
     *
     * Simple event dispatcher system for handling application events.
     * Provides a centralized way to emit and listen to events throughout the application.
     *
     * Usage:
     * ```typescript
     * // Listen to events
     * EventDispatcher.on('message:sent', (event) => {
     *   console.log('Message sent:', event);
     * });
     *
     * // Emit events
     * EventDispatcher.emit('message:sent', new MessageSent(connection, message));
     * ```
     */
    
    type EventListener<T = any> = (event: T) => void | Promise<void>;
    
    class EventDispatcherImpl {
      private listeners: Map<string, Set<EventListener>> = new Map();
    
      /**
       * Register an event listener
       *
       * @param eventName - The name of the event to listen for
       * @param listener - The callback function to execute when the event is emitted
       * @returns A function to unregister the listener
       */
      on<T = any>(eventName: string, listener: EventListener<T>): () => void {
        if (!this.listeners.has(eventName)) {
          this.listeners.set(eventName, new Set());
        }
    
        this.listeners.get(eventName)!.add(listener as EventListener);
    
        // Return unsubscribe function
        return () => this.off(eventName, listener);
      }
    
      /**
       * Register a one-time event listener
       *
       * @param eventName - The name of the event to listen for
       * @param listener - The callback function to execute once when the event is emitted
       * @returns A function to unregister the listener
       */
      once<T = any>(eventName: string, listener: EventListener<T>): () => void {
        const wrappedListener = (event: T) => {
          listener(event);
          this.off(eventName, wrappedListener);
        };
    
        return this.on(eventName, wrappedListener);
      }
    
      /**
       * Unregister an event listener
       *
       * @param eventName - The name of the event
       * @param listener - The listener function to remove
       */
      off<T = any>(eventName: string, listener: EventListener<T>): void {
        const eventListeners = this.listeners.get(eventName);
        if (eventListeners) {
          eventListeners.delete(listener as EventListener);
          if (eventListeners.size === 0) {
            this.listeners.delete(eventName);
          }
        }
      }
    
      /**
       * Emit an event to all registered listeners
       *
       * @param eventName - The name of the event to emit
       * @param event - The event data to pass to listeners
       */
      emit<T = any>(eventName: string, event: T): void {
        const eventListeners = this.listeners.get(eventName);
        if (eventListeners) {
          for (const listener of eventListeners) {
            try {
              listener(event);
            } catch (error) {
              // Log error but don't stop other listeners
              console.error(`Error in event listener for ${eventName}:`, error);
            }
          }
        }
      }
    
      /**
       * Emit an event asynchronously to all registered listeners
       *
       * @param eventName - The name of the event to emit
       * @param event - The event data to pass to listeners
       */
      async emitAsync<T = any>(eventName: string, event: T): Promise<void> {
        const eventListeners = this.listeners.get(eventName);
        if (eventListeners) {
          const promises: Promise<void>[] = [];
          for (const listener of eventListeners) {
            try {
              const result = listener(event);
              if (result instanceof Promise) {
                // Wrap promise to catch async errors
                promises.push(
                  result.catch((error) => {
                    console.error(`Error in event listener for ${eventName}:`, error);
                  })
                );
              }
            } catch (error) {
              console.error(`Error in event listener for ${eventName}:`, error);
            }
          }
          await Promise.all(promises);
        }
      }
    
      /**
       * Remove all listeners for a specific event or all events
       *
       * @param eventName - Optional event name to clear. If not provided, clears all listeners.
       */
      removeAllListeners(eventName?: string): void {
        if (eventName) {
          this.listeners.delete(eventName);
        } else {
          this.listeners.clear();
        }
      }
    
      /**
       * Get the number of listeners for an event
       *
       * @param eventName - The event name
       * @returns The number of registered listeners
       */
      listenerCount(eventName: string): number {
        return this.listeners.get(eventName)?.size ?? 0;
      }
    
      /**
       * Get all event names that have listeners
       *
       * @returns Array of event names
       */
      eventNames(): string[] {
        return Array.from(this.listeners.keys());
      }
    }
    
    // Export singleton instance
    export const EventDispatcher = new EventDispatcherImpl();
    
    // Export type for testing/mocking
    export type { EventListener };

### Assistant

Phase 1 (DI stubs) is complete. Checking remaining tasks:

### Tool · read (started)

    * **path:** `revurb-ts/src/Protocols/Pusher/client-event.ts`
    * **status:** pending

### Tool · grep (started)

    {
      "args": {
        "pattern": "ChannelCreated|ChannelRemoved|MessageReceived|MessageSent|ConnectionPruned",
        "path": "./revurb-ts/src",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_f7c19307-3508-4659-8e04-a42fb0f8bd3"
      }
    }

### Tool · read (completed)

    * **path:** `revurb-ts/src/Protocols/Pusher/client-event.ts`
    * **status:** success
        * lines: 110-139
    * **content:**

        }
    
        // TypeScript knows event is PusherMessage after validation
        const pusherEvent = event as PusherMessage;
    
        // Check if event name starts with "client-"
        if (!isClientEvent(pusherEvent.event)) {
          return null;
        }
    
        // Check if channel is present
        if (!pusherEvent.channel) {
          return null;
        }
    
        // Return a new ClientEvent instance (whisper operation must be done by caller)
        return new ClientEvent();
      }
    
      /**
       * Whisper a message to all connections on the channel associated with the event.
       *
       * This broadcasts the client event to all other connections subscribed to
       * the same channel, excluding the sender.
       *
       * @param connection - The connection that sent the event
       * @param payload - The event payload to broadcast
       *
       * @private
       */

### Tool · read (started)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** pending

### Tool · grep (completed)

    {
      "args": {
        "pattern": "ChannelCreated|ChannelRemoved|MessageReceived|MessageSent|ConnectionPruned",
        "path": "./revurb-ts/src",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_f7c19307-3508-4659-8e04-a42fb0f8bd3"
      },
      "result": {
        "success": {
          "pattern": "ChannelCreated|ChannelRemoved|MessageReceived|MessageSent|ConnectionPruned",
          "path": "./revurb-ts/src",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "revurb-ts/src/cli.ts",
                    "matches": [
                      {
                        "lineNumber": 17,
                        "content": "import { ChannelCreated } from './events/channel-created';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 18,
                        "content": "import { ChannelRemoved } from './events/channel-removed';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 19,
                        "content": "import { ConnectionPruned } from './events/connection-pruned';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 20,
                        "content": "import { MessageSent } from './events/message-sent';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 21,
                        "content": "import { MessageReceived } from './events/message-received';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 225,
                        "content": "  EventDispatcher.on('channel:created', (event: ChannelCreated) => {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 231,
                        "content": "  EventDispatcher.on('channel:removed', (event: ChannelRemoved) => {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 238,
                        "content": "  EventDispatcher.on('connection:pruned', (event: ConnectionPruned) => {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 245,
                        "content": "  EventDispatcher.on('message:sent', (event: MessageSent) => {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 251,
                        "content": "  EventDispatcher.on('message:received', (event: MessageReceived) => {",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/jobs/prune-stale-connections.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": "import { ConnectionPruned } from '../events/connection-pruned';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 20,
                        "content": " * 8. Dispatch ConnectionPruned event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 92,
                        "content": "        // Dispatch ConnectionPruned event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 93,
                        "content": "        ConnectionPruned.dispatch(channelConn);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/Protocols/Pusher/server.ts",
                    "matches": [
                      {
                        "lineNumber": 12,
                        "content": "import { MessageReceived } from '../../events/message-received';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 133,
                        "content": "      // Dispatch MessageReceived event for observability",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 134,
                        "content": "      MessageReceived.dispatch(from, message);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/Protocols/Pusher/Managers/array-channel-manager.ts",
                    "matches": [
                      {
                        "lineNumber": 9,
                        "content": "import { ChannelCreated } from '../../../events/channel-created';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 10,
                        "content": "import { ChannelRemoved } from '../../../events/channel-removed';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 215,
                        "content": "    // Dispatch ChannelCreated event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 216,
                        "content": "    ChannelCreated.dispatch(channel);",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 284,
                        "content": "   * a ChannelRemoved event for observability.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 298,
                        "content": "      // Dispatch ChannelRemoved event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 299,
                        "content": "      ChannelRemoved.dispatch(channel);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/index.ts",
                    "matches": [
                      {
                        "lineNumber": 1,
                        "content": "export { ChannelCreated } from './channel-created';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 2,
                        "content": "export { ChannelRemoved } from './channel-removed';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 3,
                        "content": "export { ConnectionPruned } from './connection-pruned';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 4,
                        "content": "export { MessageReceived } from './message-received';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 5,
                        "content": "export { MessageSent } from './message-sent';",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/connection-pruned.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": " * ConnectionPruned Event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 12,
                        "content": "export class ConnectionPruned {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 14,
                        "content": "   * Create a new ConnectionPruned event instance.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 21,
                        "content": "   * Dispatch the ConnectionPruned event.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 26,
                        "content": "    const event = new ConnectionPruned(connection);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/event-dispatcher.ts",
                    "matches": [
                      {
                        "lineNumber": 15,
                        "content": " * EventDispatcher.emit('message:sent', new MessageSent(connection, message));",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/channel-created.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": " * ChannelCreated Event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 10,
                        "content": "export class ChannelCreated {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 12,
                        "content": "   * Create a new ChannelCreated event instance.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 19,
                        "content": "   * Dispatch the ChannelCreated event.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 24,
                        "content": "    const event = new ChannelCreated(channel);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/message-received.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": " * MessageReceived Event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 10,
                        "content": "export class MessageReceived {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 12,
                        "content": "   * Create a new MessageReceived event instance.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 23,
                        "content": "   * Dispatch the MessageReceived event.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 29,
                        "content": "    const event = new MessageReceived(connection, message);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/message-sent.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": " * MessageSent Event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 10,
                        "content": "export class MessageSent {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 12,
                        "content": "   * Create a new MessageSent event instance.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 23,
                        "content": "   * Dispatch the MessageSent event.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 29,
                        "content": "    const event = new MessageSent(connection, message);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/events/channel-removed.ts",
                    "matches": [
                      {
                        "lineNumber": 5,
                        "content": " * ChannelRemoved Event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 11,
                        "content": "export class ChannelRemoved {",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 13,
                        "content": "   * Create a new ChannelRemoved event instance.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 20,
                        "content": "   * Dispatch the ChannelRemoved event.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 25,
                        "content": "    const event = new ChannelRemoved(channel);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/connection.ts",
                    "matches": [
                      {
                        "lineNumber": 4,
                        "content": "import { MessageSent } from './events/message-sent';",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 84,
                        "content": "   * a MessageSent event for monitoring and metrics collection.",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 91,
                        "content": "    MessageSent.dispatch(this, message);",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "revurb-ts/src/contracts/connection.ts",
                    "matches": [
                      {
                        "lineNumber": 66,
                        "content": " *     // Dispatch MessageSent event",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 156,
                        "content": "   * Implementations should dispatch a MessageSent event after sending.",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  }
                ],
                "totalLines": 60,
                "totalMatchedLines": 60,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (completed)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** success
        * lines: 160-209
    * **content:**

        const apps = config.apps.apps || [];
        console.log(`Applications: ${apps.length}`);
        for (const app of apps) {
          console.log(`  - ${app.app_id} (key: ${app.key})`);
        }
        console.log('');
    
        // Initialize factory with configuration
        Factory.initialize(config);
    
        // Setup event listeners for observability
        setupEventListeners(options.debug === true);
    
        // Create and start server
        const server = Factory.make(
          host,
          port,
          path,
          hostname,
          maxRequestSize,
          serverOptions as { tls?: Record<string, unknown>; [key: string]: unknown },
          'pusher',
        );
    
        // Setup periodic tasks (equivalent to Laravel's scheduled jobs)
        setupPeriodicTasks();
    
        // Setup graceful shutdown
        setupGracefulShutdown(server);
    
        // Check if TLS is actually configured (not just an empty object)
        const hasTls = serverOptions.tls && (serverOptions.tls.cert || serverOptions.tls.key);
        const scheme = hasTls ? 'wss' : 'ws';
        const httpScheme = hasTls ? 'https' : 'http';
    
        console.log('✅ Server started successfully');
        console.log('');
        console.log(`  WebSocket: ${scheme}://${hostname || host}:${port}${path}`);
        console.log(`  HTTP API:  ${httpScheme}://${hostname || host}:${port}${path}`);
        console.log('');
        console.log('Press Ctrl+C to stop the server');
        console.log('');
    
        // Keep process alive
        // Bun.serve() returns a server that keeps the process running
    
      } catch (error) {
        console.error('❌ Failed to start server:', error);
        if (error instanceof Error) {
          console.error(error.message);

### Assistant

(empty)

### Tool · read (started)

    * **path:** `revurb-ts/src/Protocols/Pusher/client-event.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/src/Protocols/Pusher/client-event.ts`
    * **status:** success
        * lines: 138-157
    * **content:**

       * @private
       */
      private whisper(connection: Connection, payload: PusherMessage): void {
        // Check if channels manager is available
        if (!this.channels) {
          console.warn('ClientEvent.whisper: ChannelManager not available');
          return;
        }
    
        // Get the channel name from the payload
        const channelName = payload.channel;
        if (!channelName) {
          return;
        }
    
        // Find the channel (must scope to application first)
        const channel = this.channels.for(connection.app()).find(channelName);
        if (!channel) {
          // Channel doesn't exist - nothing to broadcast to
          return;

### Tool · read (started)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** success
        * lines: 975-1004
    * **content:**

       */
      private static handleHealthCheck(_req: Request, _params: Record<string, string>): Response {
        return new Response('OK', { status: 200 });
      }
    
      /**
       * Configure TLS context for the server
       *
       * Filters out null values and attempts to auto-detect certificates
       * for the given hostname if not explicitly provided.
       * Sets verify_peer to true in production environments for better security.
       *
       * @param context - Initial TLS context (may contain null values)
       * @param hostname - Hostname for certificate auto-detection
       * @param environment - The environment name (default: NODE_ENV or 'development')
       *                     Used to determine TLS peer verification settings
       * @returns Configured TLS context
       *
       * @private
       */
      private static configureTls(
        context: TlsContext,
        hostname?: string,
        environment: string = process.env.NODE_ENV || 'development'
      ): TlsContext {
        // Filter out null/undefined values
        const filtered: TlsContext = {};
        for (const [key, value] of Object.entries(context)) {
          if (value !== null && value !== undefined) {
            filtered[key] = value;

### Tool · read (completed)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** success
        * lines: 220-259
    * **content:**

     */
    function setupEventListeners(debug: boolean = false): void {
      const logger = Factory.getLogger();
    
      // Channel lifecycle events
      EventDispatcher.on('channel:created', (event: ChannelCreated) => {
        if (debug) {
          logger.debug(`Channel created: ${event.channel.name()}`);
        }
      });
    
      EventDispatcher.on('channel:removed', (event: ChannelRemoved) => {
        if (debug) {
          logger.debug(`Channel removed: ${event.channel.name()}`);
        }
      });
    
      // Connection lifecycle events
      EventDispatcher.on('connection:pruned', (event: ConnectionPruned) => {
        if (debug) {
          logger.debug(`Connection pruned: ${event.connection.id()}`);
        }
      });
    
      // Message events
      EventDispatcher.on('message:sent', (event: MessageSent) => {
        if (debug) {
          logger.debug(`Message sent to connection ${event.connection.id()}`);
        }
      });
    
      EventDispatcher.on('message:received', (event: MessageReceived) => {
        if (debug) {
          logger.debug(`Message received from connection ${event.connection.id()}`);
        }
      });
    }
    
    /**
     * Setup periodic tasks for connection management

### Assistant

Checking if Factory.make() passes the environment parameter:

### Tool · grep (started)

    {
      "args": {
        "pattern": "public static make\\(",
        "path": "./revurb-ts/src/Servers/Reverb/factory.ts",
        "contextAfter": 30,
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_6e8ee29d-83c6-4ea6-9465-61fa1f6e0d6"
      }
    }

### Tool · read (started)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** pending

### Tool · grep (completed)

    {
      "args": {
        "pattern": "public static make\\(",
        "path": "./revurb-ts/src/Servers/Reverb/factory.ts",
        "contextAfter": 30,
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_6e8ee29d-83c6-4ea6-9465-61fa1f6e0d6"
      },
      "result": {
        "success": {
          "pattern": "public static make\\(",
          "path": "./revurb-ts/src/Servers/Reverb/factory.ts",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "355:  public static make(",
                    "matches": [
                      {
                        "lineNumber": 356,
                        "content": "    host: string = '0.0.0.0',",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 357,
                        "content": "    port: string = '8080',",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 358,
                        "content": "    path: string = '',",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 359,
                        "content": "    hostname?: string,",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 360,
                        "content": "    maxRequestSize: number = 10000,",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 361,
                        "content": "    options: HttpServerOptions = {},",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 362,
                        "content": "    protocol: string = 'pusher',",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 363,
                        "content": "    environment: string = process.env.NODE_ENV || 'development',",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 364,
                        "content": "  ) {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 365,
                        "content": "    if (protocol !== 'pusher') {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 366,
                        "content": "      throw new Error(`Unsupported protocol [${protocol}].`);",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 367,
                        "content": "    }",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 368,
                        "content": "",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 369,
                        "content": "    const router = this.makePusherRouter(path);",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 370,
                        "content": "    const tlsContext = this.configureTls(options.tls ?? {}, hostname, environment);",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 371,
                        "content": "    const portNum = Number.parseInt(port, 10);",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 372,
                        "content": "",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 373,
                        "content": "    // Build Bun server options",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 374,
                        "content": "    const serveOptions: ServeOptions & { maxRequestBodySize?: number } = {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 375,
                        "content": "      hostname: host,",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 376,
                        "content": "      port: portNum,",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 377,
                        "content": "      maxRequestBodySize: maxRequestSize,",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 378,
                        "content": "      fetch: async (req: Request, server: any) => this.handleRequest(req, router, server),",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 379,
                        "content": "      websocket: {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 380,
                        "content": "        open: (ws: any) => {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 381,
                        "content": "          // WebSocket open handler - create connection and notify Pusher server",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 382,
                        "content": "          const data = ws.data as WebSocketData | undefined;",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 383,
                        "content": "          if (!data || !data.app) {",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 384,
                        "content": "            console.error('WebSocket opened without app data');",
                        "contentTruncated": false,
                        "isContextLine": true
                      },
                      {
                        "lineNumber": 385,
                        "content": "            ws.close();",
                        "contentTruncated": false,
                        "isContextLine": true
                      }
                    ]
                  }
                ],
                "totalLines": 30,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (completed)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** success
        * lines: 800-849
    * **content:**

          return new Response('Missing appId parameter', { status: 400 });
        }
    
        try {
          const httpRequest = await this.convertToHttpRequest(req);
          const httpConnection = this.createHttpConnection();
          const response = await connectionsController(
            httpRequest,
            httpConnection,
            params.appId
          );
    
          return this.convertToResponse(response);
        } catch (error) {
          console.error('Error handling connections:', error);
          return new Response(
            JSON.stringify({ error: error instanceof Error ? error.message : 'Internal server error' }),
            { status: 500, headers: { 'Content-Type': 'application/json' } }
          );
        }
      }
    
      /**
       * Handle channel listing
       *
       * @param req - The incoming request
       * @param params - Route parameters including appId
       * @returns JSON response with list of channels
       *
       * @private
       */
      private static async handleChannels(req: Request, params: Record<string, string>): Promise<Response> {
        if (!this.channelsController || !this.appManager) {
          return new Response('Server not initialized', { status: 500 });
        }
    
        if (!params.appId) {
          return new Response('Missing appId parameter', { status: 400 });
        }
    
        try {
          const httpRequest = await this.convertToHttpRequest(req);
          const httpConnection = this.createHttpConnection();
          const response = await this.channelsController.__invoke(
            httpRequest,
            httpConnection,
            params.appId
          );
    
          return this.convertToResponse(response);

### Assistant

Checking if cli.ts passes the environment parameter:

### Tool · read (started)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** success
        * lines: 173-187
    * **content:**

        // Create and start server
        const server = Factory.make(
          host,
          port,
          path,
          hostname,
          maxRequestSize,
          serverOptions as { tls?: Record<string, unknown>; [key: string]: unknown },
          'pusher',
        );
    
        // Setup periodic tasks (equivalent to Laravel's scheduled jobs)
        setupPeriodicTasks();
    
        // Setup graceful shutdown

### Tool · read (completed)

    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`
    * **status:** success
        * lines: 1015-1044
    * **content:**

            // Enable peer verification in production for better security
            filtered.verify_peer = environment === 'production';
          }
        }
    
        return filtered;
      }
    
      /**
       * Determine whether the server uses TLS
       *
       * Checks if TLS context has both certificate and key configured.
       *
       * @param context - TLS context to check
       * @returns True if TLS is configured, false otherwise
       *
       * @private
       */
      private static usesTls(context: TlsContext): boolean {
        return !!(context.local_cert || context.local_pk);
      }
    
      /**
       * Convert Bun Request to IHttpRequest
       *
       * @param req - The Bun Request object
       * @returns IHttpRequest interface
       *
       * @private
       */

### Assistant

Checking CLI options for environment configuration:

### Tool · read (started)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** pending

### Tool · sem Search (started)

    {
      "args": {
        "query": "What files still need work or have TODO comments in the TypeScript port?",
        "targetDirectories": [
          "revurb-ts/src"
        ],
        "explanation": ""
      }
    }

### Tool · read (completed)

    * **path:** `revurb-ts/src/cli.ts`
    * **status:** success
        * lines: 1-100
    * **content:**

    #!/usr/bin/env bun
    
    /**
     * Revurb CLI - Command-line interface for managing the WebSocket server
     *
     * A TypeScript port of Laravel Reverb's CLI commands
     *
     * @module cli
     */
    
    import { Factory } from './Servers/Reverb/factory';
    import { loadConfig } from './config/load';
    import type { ReverbConfig } from './config/types';
    import { PruneStaleConnections } from './jobs/prune-stale-connections';
    import { PingInactiveConnections } from './jobs/ping-inactive-connections';
    import { EventDispatcher } from './events/event-dispatcher';
    import { ChannelCreated } from './events/channel-created';
    import { ChannelRemoved } from './events/channel-removed';
    import { ConnectionPruned } from './events/connection-pruned';
    import { MessageSent } from './events/message-sent';
    import { MessageReceived } from './events/message-received';
    import type { ChannelConnection } from './Protocols/Pusher/Channels/channel-connection';
    
    /**
     * CLI argument parsing result
     */
    interface ParsedArgs {
      command: string;
      options: Record<string, string | boolean>;
      args: string[];
    }
    
    /**
     * Parse command-line arguments
     */
    function parseArgs(argv: string[]): ParsedArgs {
      const args = argv.slice(2); // Remove 'bun' and script path
      const command = args[0] || 'help';
      const options: Record<string, string | boolean> = {};
      const positional: string[] = [];
    
      for (let i = 1; i < args.length; i++) {
        const arg = args[i];
        if (!arg) continue;
    
        if (arg.startsWith('--')) {
          const key = arg.slice(2);
          const nextArg = args[i + 1];
    
          // Check if this is a boolean flag or has a value
          if (!nextArg || nextArg.startsWith('--') || nextArg.startsWith('-')) {
            options[key] = true;
          } else {
            options[key] = nextArg;
            i++; // Skip next arg since we used it as value
          }
        } else if (arg.startsWith('-')) {
          // Short flags are always boolean
          const key = arg.slice(1);
          options[key] = true;
        } else {
          positional.push(arg);
        }
      }
    
      return { command, options, args: positional };
    }
    
    /**
     * Display help information
     */
    function displayHelp(): void {
      console.log(`
    Revurb - Bun-powered WebSocket server implementing the Pusher protocol
    
    USAGE:
      revurb <command> [options]
    
    COMMANDS:
      start       Start the WebSocket server
      help        Display this help message
      version     Display version information
    
    START OPTIONS:
      --host <address>      The IP address the server should bind to (default: from config)
      --port <number>       The port the server should listen on (default: from config)
      --path <path>         The path prefix for all routes (default: from config)
      --hostname <name>     The hostname for TLS certificate resolution (default: from config)
      --debug               Enable debug logging to console
      --config <path>       Path to configuration file
    
    EXAMPLES:
      revurb start                                    # Start with default config
      revurb start --host 127.0.0.1 --port 8080      # Start with custom host/port
      revurb start --debug                            # Start with debug logging
      revurb start --config ./reverb.config.ts        # Start with custom config
    
    CONFIGURATION:
      Revurb looks for configuration in the following locations:
      1. Path specified by --config option

### Tool · sem Search (completed)

    {
      "args": {
        "query": "What files still need work or have TODO comments in the TypeScript port?",
        "targetDirectories": [
          "revurb-ts/src"
        ],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"revurb-ts/src/Servers/Reverb/Publishing/redis-client-factory.ts\" startLine=\"70\" endLine=\"184\">\n    70|/**\n    71| * Factory for creating Redis clients\n    72| *\n    73| * Creates Redis client connections for the Reverb server.\n    74| * Handles parsing of Redis URLs and establishing connections for\n    75| * pub/sub operations using Bun's native capabilities.\n    76| *\n    77| * @class RedisClientFactory\n    78| * @example\n    79| * ```typescript\n    80| * const factory = new RedisClientFactory();\n    81| * const client = await factory.make('redis://localhost:6379');\n    82| * ```\n    83| */\n    84|export class RedisClientFactory {\n    85|  /**\n    86|   * Create a new Redis client connection\n    87|   *\n    88|   * Establishes a connection to a Redis server using the provided URL.\n    89|   * The URL can be in the format:\n    90|   * - redis://[username[:password]@][host][:port][/database]\n    91|   * - rediss://[username[:password]@][host][:port][/database] (TLS)\n    92|   *\n    93|   * Bun's native JavaScript runtime does not provide built-in Redis client,\n    94|   * so this factory assumes an external Redis client library will be\n    95|   * injected or used. In production, integrate with a library like:\n    96|   * - node-redis\n    97|   * - ioredis\n    98|   * - or similar compatible client\n    99|   *\n   100|   * @param redisUrl - The Redis connection URL\n   101|   * @returns Promise that resolves to a connected Redis client\n   102|   *\n   103|   * @throws {Error} If the connection fails or URL is invalid\n   104|   *\n   105|   * @example\n   106|   * ```typescript\n   107|   * const client = await factory.make('redis://localhost:6379/0');\n   108|   * await client.ping();\n   109|   * ```\n   110|   */\n   111|  public async make(redisUrl: string): Promise<RedisClient> {\n   112|    try {\n   113|      // Parse the Redis URL to extract connection parameters\n   114|      const url = new URL(redisUrl);\n   115|\n   116|      // Extract components from URL\n   117|      const protocol = url.protocol.replace(':', '');\n   118|      const hostname = url.hostname || 'localhost';\n   119|      const port = url.port ? parseInt(url.port, 10) : 6379;\n   120|      const username = url.username || undefined;\n   121|      const password = url.password || undefined;\n   122|      const database = url.pathname ? parseInt(url.pathname.replace('/', ''), 10) || 0 : 0;\n   123|      const useTls = protocol === 'rediss';\n   124|\n   125|      // For Bun runtime, we need to use a compatible Redis client\n   126|      // This creates a placeholder that should be replaced with actual Redis library\n   127|      // when integrated with a proper Redis client package\n   128|\n   129|      // Connection parameters for the Redis client\n   130|      const connectionConfig = {\n   131|        hostname,\n   132|        port,\n   133|        ...(username && { username }),\n   134|        ...(password && { password }),\n   135|        ...(database && { db: database }),\n   136|        ...(useTls && { tls: true }),\n   137|      };\n   138|\n   139|      // Create a Redis client instance\n   140|      // This is a stub implementation that should be replaced with actual\n   141|      // Redis client library instantiation (e.g., node-redis, ioredis)\n   142|      const redisClient: RedisClient = await this.createClient(connectionConfig);\n   143|\n   144|      return redisClient;\n   145|    } catch (error) {\n   146|      throw new Error(\n   147|        `Failed to create Redis client: ${error instanceof Error ? error.message : String(error)}`\n   148|      );\n   149|    }\n   150|  }\n   151|\n   152|  /**\n   153|   * Create a Redis client with the given configuration\n   154|   *\n   155|   * This method creates the actual Redis client connection.\n   156|   * It serves as an extension point for dependency injection.\n   157|   *\n   158|   * @param config - Redis connection configuration\n   159|   * @returns Promise that resolves to a connected Redis client\n   160|   *\n   161|   * @private\n   162|   */\n   ...\n   184|}\n</search_result>\n<search_result path=\"revurb-ts/src/contracts/connection.ts\" startLine=\"2\" endLine=\"88\">\n     2|import type { IWebSocketConnection, FrameOpcode } from './websocket-connection';\n     3|\n     4|/**\n     5| * Connection State Machine\n     6| *\n     7| * The Connection class tracks connection state using a timestamp-based state machine:\n     8| *\n     9| * State Transitions:\n    10| * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n    11| * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n    12| * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n    13| *\n    14| * State Determination:\n    15| * - isActive(): time() < lastSeenAt + app.pingInterval()\n    16| * - isInactive(): !isActive()\n    17| * - isStale(): isInactive() && hasBeenPinged\n    18| *\n    19| * Lifecycle:\n    20| * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n    21| * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n    22| * 3. No activity for pingInterval → isInactive() = true\n    23| * 4. Ping sent → ping() → hasBeenPinged = true\n    24| * 5. Pong received → pong() → hasBeenPinged = false\n    25| * 6. No response after ping → isStale() = true → connection pruned\n    26| *\n    27| * Timestamps:\n    28| * - All timestamps use SECONDS (not milliseconds)\n    29| * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n    30| * - This matches PHP's time() function behavior\n    31| */\n    32|\n    33|/**\n    34| * Connection Abstract Class\n    35| *\n    36| * Application-aware connection wrapper that manages WebSocket connection state,\n    37| * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n    38| * activity tracking, and state management.\n    39| *\n    40| * Key Responsibilities:\n    41| * - Wrap WebSocketConnection with application context\n    42| * - Track connection activity via lastSeenAt timestamp\n    43| * - Implement state machine (Active/Inactive/Stale)\n    44| * - Manage ping/pong state for connection health\n    45| * - Generate normalized socket IDs\n    46| * - Provide connection lifecycle methods\n    47| *\n    48| * @abstract\n    49| *\n    50| * @example\n    51| * ```typescript\n    52| * class ReverbConnection extends Connection {\n    53| *   identifier(): string {\n    54| *     return String(this.connection.id());\n    55| *   }\n    56| *\n    57| *   id(): string {\n    58| *     if (!this._id) {\n    59| *       this._id = this.generateId();\n    60| *     }\n    61| *     return this._id;\n    62| *   }\n    63| *\n    64| *   send(message: string): void {\n    65| *     this.connection.send(message);\n    66| *     // Dispatch MessageSent event\n    67| *   }\n    68| *\n    69| *   control(type: FrameOpcode = FrameOpcode.PING): void {\n    70| *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n    71| *   }\n    72| *\n    73| *   terminate(): void {\n    74| *     this.connection.close();\n    75| *   }\n    76| * }\n    77| * ```\n    78| */\n    79|export abstract class Connection {\n    80|  /**\n    81|   * The last time the connection was seen (in seconds, not milliseconds).\n    82|   *\n    83|   * Initialized to current time when connection is created.\n    84|   * Updated via touch() when activity is detected.\n    85|   * Used to determine connection state (active/inactive/stale).\n    86|   *\n    87|   * @protected\n    88|   */\n</search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/Http/server.ts\" startLine=\"2\" endLine=\"343\">\n     2|import type { Router } from './router';\n     3|\n     4|/**\n     5| * HTTP Server Implementation\n     6| *\n     7| * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\n     8| * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\n     9| *\n    10| * Key features:\n    11| * - Accepts incoming TCP connections via Bun.serve()\n    12| * - HTTP request parsing and routing\n    13| * - WebSocket upgrade handling with full lifecycle management\n    14| * - Periodic garbage collection (every 30 seconds)\n    15| * - Graceful start/stop lifecycle management\n    16| * - TLS support detection\n    17| *\n    18| * The server uses Bun's native WebSocket API for efficient connection handling\n    19| * and automatic binary/text frame management.\n    20| *\n    21| * @example\n    22| * ```typescript\n    23| * const server = new Server({\n    24| *   port: 8080,\n    25| *   host: 'localhost',\n    26| *   logger,\n    27| *   router,\n    28| *   maxRequestSize: 1024 * 1024,\n    29| *   tls: null,\n    30| * });\n    31| *\n    32| * server.start();\n    33| * // Server is now accepting connections...\n    34| *\n    35| * // Later, to stop:\n    36| * server.stop();\n    37| * ```\n    38| */\n    39|export class Server {\n    40|  /**\n    41|   * The underlying Bun server instance.\n    42|   *\n    43|   * @private\n    44|   */\n    45|  private bunServer: ReturnType<typeof Bun.serve> | null = null;\n    46|\n    47|  /**\n    48|   * Periodic timer for garbage collection.\n    49|   *\n    50|   * @private\n    51|   */\n    52|  private gcTimer: Timer | null = null;\n    53|\n    54|  /**\n    55|   * Indicates whether the server is running.\n    56|   *\n    57|   * @private\n    58|   */\n    59|  private isRunning: boolean = false;\n    60|\n    61|  /**\n    62|   * Server configuration options.\n    63|   *\n    64|   * @private\n    65|   */\n    66|  private readonly config: ServerConfig;\n    67|\n    68|  /**\n    69|   * Create a new HTTP server instance.\n    70|   *\n    71|   * Initializes the server with configuration, logger, and router.\n    72|   * Disables automatic garbage collection and sets up periodic manual GC.\n    73|   *\n    74|   * @param config - Server configuration object\n    75|   */\n    76|  constructor(config: ServerConfig) {\n    77|    this.config = config;\n    78|\n    79|    // Disable automatic garbage collection; we'll do it manually\n    80|    if (typeof gc !== 'undefined') {\n    81|      // Note: gc.disable() may not be available in all Bun versions\n    82|      (gc as any).disable?.();\n    83|    }\n    84|  }\n    85|\n    86|  /**\n    87|   * Start the HTTP server.\n    88|   *\n    89|   * Initializes Bun.serve() with the configured port, host, and handlers.\n    90|   * Sets up periodic garbage collection and error handling.\n    91|   * The server will accept both HTTP and WebSocket connections.\n    92|   *\n    93|   * @throws Will log errors but not throw directly; error handling is done\n    94|   *         through the logger interface\n    95|   */\n   ...\n   343|}\n</search_result>\n<search_result path=\"revurb-ts/src/config/load.ts\" startLine=\"223\" endLine=\"313\">\n   223|function loadAppsConfig(): AppsConfig {\n   ...\n   227|\n   228|}\n   229|\n   230|/**\n   231| * Load the complete Reverb configuration from environment variables or config file\n   232| *\n   233| * This function reads all necessary environment variables and constructs\n   234| * a complete ReverbConfig object with sensible defaults matching the PHP\n   235| * Laravel configuration.\n   236| *\n   237| * If a configPath is provided, it will attempt to load and merge that configuration\n   238| * with environment variables (env vars take precedence).\n   239| *\n   240| * Required environment variables:\n   241| * - REVERB_APP_KEY: Application key for authentication\n   242| * - REVERB_APP_SECRET: Application secret for authentication\n   243| * - REVERB_APP_ID: Application ID\n   244| *\n   245| * Optional environment variables (with defaults):\n   246| * - REVERB_SERVER (default: 'reverb')\n   247| * - REVERB_SERVER_HOST (default: '0.0.0.0')\n   248| * - REVERB_SERVER_PORT (default: 8080)\n   249| * - REVERB_SERVER_PATH (default: '')\n   250| * - REVERB_HOST (default: undefined)\n   251| * - REVERB_MAX_REQUEST_SIZE (default: 10000)\n   252| * - REVERB_SCALING_ENABLED (default: false)\n   253| * - REVERB_SCALING_CHANNEL (default: 'reverb')\n   254| * - REDIS_URL (default: undefined)\n   255| * - REDIS_HOST (default: '127.0.0.1')\n   256| * - REDIS_PORT (default: '6379')\n   257| * - REDIS_USERNAME (default: undefined)\n   258| * - REDIS_PASSWORD (default: undefined)\n   259| * - REDIS_DB (default: '0')\n   260| * - REDIS_TIMEOUT (default: 60)\n   261| * - REVERB_PULSE_INGEST_INTERVAL (default: 15)\n   262| * - REVERB_TELESCOPE_INGEST_INTERVAL (default: 15)\n   263| * - REVERB_PORT (default: 443)\n   264| * - REVERB_SCHEME (default: 'https')\n   265| * - REVERB_APP_PING_INTERVAL (default: 60)\n   266| * - REVERB_APP_ACTIVITY_TIMEOUT (default: 30)\n   267| * - REVERB_APP_MAX_CONNECTIONS (default: undefined)\n   268| * - REVERB_APP_MAX_MESSAGE_SIZE (default: 10000)\n   269| * - REVERB_ALLOWED_ORIGINS (default: '*', comma-separated)\n   270| *\n   271| * @param configPath - Optional path to a configuration file to load\n   272| * @throws {Error} If required environment variables are not set\n   273| * @returns The complete Reverb configuration\n   274| */\n   275|export async function loadConfig(configPath?: string): Promise<ReverbConfig> {\n   276|  const defaultServer = env('REVERB_SERVER', 'reverb')!;\n   277|\n   278|  // Build default config from environment\n   279|  const envConfig: ReverbConfig = {\n   280|    default: defaultServer,\n   281|    servers: {\n   282|      [defaultServer]: loadReverbServerConfig(),\n   283|    },\n   284|    apps: loadAppsConfig(),\n   285|  };\n   286|\n   287|  // If a config file path is provided, try to load and merge it\n   288|  if (configPath) {\n   289|    try {\n   290|      const fileConfig = await import(configPath);\n   291|      const config = fileConfig.default || fileConfig;\n   292|\n   293|      // Merge configs - env vars take precedence\n   294|      return {\n   295|        ...config,\n   296|        ...envConfig,\n   297|        servers: {\n   298|          ...config.servers,\n   299|          ...envConfig.servers,\n   300|        },\n   301|        apps: {\n   302|          ...config.apps,\n   303|          ...envConfig.apps,\n   304|        },\n   305|      };\n   306|    } catch (error) {\n   307|      // If config file doesn't exist or can't be loaded, just use env config\n   308|      console.warn(`Warning: Could not load config file at ${configPath}, using environment variables`);\n   309|    }\n   310|  }\n   311|\n   312|  return envConfig;\n   313|}\n</search_result>\n<search_result path=\"revurb-ts/src/cli.ts\" startLine=\"1\" endLine=\"67\">\n     1|#!/usr/bin/env bun\n     2|\n     3|/**\n     4| * Revurb CLI - Command-line interface for managing the WebSocket server\n     5| *\n     6| * A TypeScript port of Laravel Reverb's CLI commands\n     7| *\n     8| * @module cli\n     9| */\n    10|\n    11|import { Factory } from './Servers/Reverb/factory';\n    12|import { loadConfig } from './config/load';\n    13|import type { ReverbConfig } from './config/types';\n    14|import { PruneStaleConnections } from './jobs/prune-stale-connections';\n    15|import { PingInactiveConnections } from './jobs/ping-inactive-connections';\n    16|import { EventDispatcher } from './events/event-dispatcher';\n    17|import { ChannelCreated } from './events/channel-created';\n    18|import { ChannelRemoved } from './events/channel-removed';\n    19|import { ConnectionPruned } from './events/connection-pruned';\n    20|import { MessageSent } from './events/message-sent';\n    21|import { MessageReceived } from './events/message-received';\n    22|import type { ChannelConnection } from './Protocols/Pusher/Channels/channel-connection';\n    23|\n    24|/**\n    25| * CLI argument parsing result\n    26| */\n    27|interface ParsedArgs {\n    28|  command: string;\n    29|  options: Record<string, string | boolean>;\n    30|  args: string[];\n    31|}\n    32|\n    33|/**\n    34| * Parse command-line arguments\n    35| */\n    36|function parseArgs(argv: string[]): ParsedArgs {\n    37|  const args = argv.slice(2);\n   ...\n    67|}\n</search_result>\n\n<search_result path=\"revurb-ts/src/application-manager.ts\" endLine=\"43\"></search_result>\n<search_result path=\"revurb-ts/src/jobs/ping-inactive-connections.ts\" endLine=\"79\"></search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/connection.ts\" endLine=\"256\"></search_result>\n<search_result path=\"revurb-ts/src/index.ts\" endLine=\"9\"></search_result>\n<search_result path=\"revurb-ts/src/jobs/prune-stale-connections.ts\" endLine=\"99\"></search_result>\n<search_result path=\"revurb-ts/src/connection.ts\" endLine=\"118\"></search_result>\n<search_result path=\"revurb-ts/src/jobs/prune-stale-connections.ts\" showSignaturesOnly=\"true\" startLine=\"28\" endLine=\"99\">\n   29|export class PruneStaleConnections {\n</search_result>\n<search_result path=\"revurb-ts/src/contracts/logger.ts\" endLine=\"99\"></search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/factory.ts\" showSignaturesOnly=\"true\" startLine=\"165\" endLine=\"1147\">\n  166|export class Factory {\n</search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/Http/router.ts\" showSignaturesOnly=\"true\" startLine=\"25\" endLine=\"419\">\n   26|export class Router {\n</search_result>\n<search_result path=\"revurb-ts/src/Protocols/Pusher/server.ts\" endLine=\"330\"></search_result>\n<search_result path=\"revurb-ts/src/certificate.ts\" endLine=\"144\"></search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/connection.ts\" showSignaturesOnly=\"true\" startLine=\"19\" endLine=\"256\">\n   20|export class Connection implements IWebSocketConnection {\n</search_result>\n<search_result path=\"revurb-ts/src/Servers/Reverb/Http/router.ts\" endLine=\"419\"></search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Publishing/redis-client-factory.ts",
                "range": {
                  "startPosition": {
                    "line": 67,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 183,
                    "column": 1
                  }
                },
                "contents": "/**\n * Factory for creating Redis clients\n *\n * Creates Redis client connections for the Reverb server.\n * Handles parsing of Redis URLs and establishing connections for\n * pub/sub operations using Bun's native capabilities.\n *\n * @class RedisClientFactory\n * @example\n * ```typescript\n * const factory = new RedisClientFactory();\n * const client = await factory.make('redis://localhost:6379');\n * ```\n */\nexport class RedisClientFactory {\n  /**\n   * Create a new Redis client connection\n   *\n   * Establishes a connection to a Redis server using the provided URL.\n   * The URL can be in the format:\n   * - redis://[username[:password]@][host][:port][/database]\n   * - rediss://[username[:password]@][host][:port][/database] (TLS)\n   *\n   * Bun's native JavaScript runtime does not provide built-in Redis client,\n   * so this factory assumes an external Redis client library will be\n   * injected or used. In production, integrate with a library like:\n   * - node-redis\n   * - ioredis\n   * - or similar compatible client\n   *\n   * @param redisUrl - The Redis connection URL\n   * @returns Promise that resolves to a connected Redis client\n   *\n   * @throws {Error} If the connection fails or URL is invalid\n   *\n   * @example\n   * ```typescript\n   * const client = await factory.make('redis://localhost:6379/0');\n   * await client.ping();\n   * ```\n   */\n  public async make(redisUrl: string): Promise<RedisClient> {\n    try {\n      // Parse the Redis URL to extract connection parameters\n      const url = new URL(redisUrl);\n\n      // Extract components from URL\n      const protocol = url.protocol.replace(':', '');\n      const hostname = url.hostname || 'localhost';\n      const port = url.port ? parseInt(url.port, 10) : 6379;\n      const username = url.username || undefined;\n      const password = url.password || undefined;\n      const database = url.pathname ? parseInt(url.pathname.replace('/', ''), 10) || 0 : 0;\n      const useTls = protocol === 'rediss';\n\n      // For Bun runtime, we need to use a compatible Redis client\n      // This creates a placeholder that should be replaced with actual Redis library\n      // when integrated with a proper Redis client package\n\n      // Connection parameters for the Redis client\n      const connectionConfig = {\n        hostname,\n        port,\n        ...(username && { username }),\n        ...(password && { password }),\n        ...(database && { db: database }),\n        ...(useTls && { tls: true }),\n      };\n\n      // Create a Redis client instance\n      // This is a stub implementation that should be replaced with actual\n      // Redis client library instantiation (e.g., node-redis, ioredis)\n      const redisClient: RedisClient = await this.createClient(connectionConfig);\n\n      return redisClient;\n    } catch (error) {\n      throw new Error(\n        `Failed to create Redis client: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Create a Redis client with the given configuration\n   *\n   * This method creates the actual Redis client connection.\n   * It serves as an extension point for dependency injection.\n   *\n   * @param config - Redis connection configuration\n   * @returns Promise that resolves to a connected Redis client\n   *\n   * @private\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory for creating Redis clients",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " * Creates Redis client connections for the Reverb server.",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles parsing of Redis URLs and establishing connections for",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " * pub/sub operations using Bun's native capabilities.",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * @class RedisClientFactory",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": " * const factory = new RedisClientFactory();",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": " * const client = await factory.make('redis://localhost:6379');",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "export class RedisClientFactory {",
                    "lineNumber": 84,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new Redis client connection",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * Establishes a connection to a Redis server using the provided URL.",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * The URL can be in the format:",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * - redis://[username[:password]@][host][:port][/database]",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * - rediss://[username[:password]@][host][:port][/database] (TLS)",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * Bun's native JavaScript runtime does not provide built-in Redis client,",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * so this factory assumes an external Redis client library will be",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * injected or used. In production, integrate with a library like:",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   * - node-redis",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "   * - ioredis",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "   * - or similar compatible client",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param redisUrl - The Redis connection URL",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise that resolves to a connected Redis client",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} If the connection fails or URL is invalid",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * const client = await factory.make('redis://localhost:6379/0');",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   * await client.ping();",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "  public async make(redisUrl: string): Promise<RedisClient> {",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "      // Parse the Redis URL to extract connection parameters",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "      const url = new URL(redisUrl);",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "      // Extract components from URL",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "      const protocol = url.protocol.replace(':', '');",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "      const hostname = url.hostname || 'localhost';",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "      const port = url.port ? parseInt(url.port, 10) : 6379;",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "      const username = url.username || undefined;",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      const password = url.password || undefined;",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "      const database = url.pathname ? parseInt(url.pathname.replace('/', ''), 10) || 0 : 0;",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "      const useTls = protocol === 'rediss';",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "      // For Bun runtime, we need to use a compatible Redis client",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "      // This creates a placeholder that should be replaced with actual Redis library",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "      // when integrated with a proper Redis client package",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "      // Connection parameters for the Redis client",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "      const connectionConfig = {",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "        hostname,",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "        port,",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "        ...(username && { username }),",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "        ...(password && { password }),",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "        ...(database && { db: database }),",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "        ...(useTls && { tls: true }),",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "      };",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "      // Create a Redis client instance",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      // This is a stub implementation that should be replaced with actual",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "      // Redis client library instantiation (e.g., node-redis, ioredis)",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "      const redisClient: RedisClient = await this.createClient(connectionConfig);",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "      return redisClient;",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error(",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "        `Failed to create Redis client: ${error instanceof Error ? error.message : String(error)}`",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a Redis client with the given configuration",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method creates the actual Redis client connection.",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * It serves as an extension point for dependency injection.",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param config - Redis connection configuration",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise that resolves to a connected Redis client",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 184,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.17964130640029907
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/contracts/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 50
                  },
                  "endPosition": {
                    "line": 344,
                    "column": 0
                  }
                },
                "contents": "import type { IWebSocketConnection, FrameOpcode } from './websocket-connection';\n\n/**\n * Connection State Machine\n *\n * The Connection class tracks connection state using a timestamp-based state machine:\n *\n * State Transitions:\n * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n *\n * State Determination:\n * - isActive(): time() < lastSeenAt + app.pingInterval()\n * - isInactive(): !isActive()\n * - isStale(): isInactive() && hasBeenPinged\n *\n * Lifecycle:\n * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n * 3. No activity for pingInterval → isInactive() = true\n * 4. Ping sent → ping() → hasBeenPinged = true\n * 5. Pong received → pong() → hasBeenPinged = false\n * 6. No response after ping → isStale() = true → connection pruned\n *\n * Timestamps:\n * - All timestamps use SECONDS (not milliseconds)\n * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n * - This matches PHP's time() function behavior\n */\n\n/**\n * Connection Abstract Class\n *\n * Application-aware connection wrapper that manages WebSocket connection state,\n * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n * activity tracking, and state management.\n *\n * Key Responsibilities:\n * - Wrap WebSocketConnection with application context\n * - Track connection activity via lastSeenAt timestamp\n * - Implement state machine (Active/Inactive/Stale)\n * - Manage ping/pong state for connection health\n * - Generate normalized socket IDs\n * - Provide connection lifecycle methods\n *\n * @abstract\n *\n * @example\n * ```typescript\n * class ReverbConnection extends Connection {\n *   identifier(): string {\n *     return String(this.connection.id());\n *   }\n *\n *   id(): string {\n *     if (!this._id) {\n *       this._id = this.generateId();\n *     }\n *     return this._id;\n *   }\n *\n *   send(message: string): void {\n *     this.connection.send(message);\n *     // Dispatch MessageSent event\n *   }\n *\n *   control(type: FrameOpcode = FrameOpcode.PING): void {\n *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n *   }\n *\n *   terminate(): void {\n *     this.connection.close();\n *   }\n * }\n * ```\n */\nexport abstract class Connection {\n  /**\n   * The last time the connection was seen (in seconds, not milliseconds).\n   *\n   * Initialized to current time when connection is created.\n   * Updated via touch() when activity is detected.\n   * Used to determine connection state (active/inactive/stale).\n   *\n   * @protected\n   */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IWebSocketConnection, FrameOpcode } from './websocket-connection';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection State Machine",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * The Connection class tracks connection state using a timestamp-based state machine:",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * State Transitions:",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * State Determination:",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - isActive(): time() < lastSeenAt + app.pingInterval()",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - isInactive(): !isActive()",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - isStale(): isInactive() && hasBeenPinged",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Lifecycle:",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. No activity for pingInterval → isInactive() = true",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Ping sent → ping() → hasBeenPinged = true",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Pong received → pong() → hasBeenPinged = false",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. No response after ping → isStale() = true → connection pruned",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * Timestamps:",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * - All timestamps use SECONDS (not milliseconds)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * - Use Math.floor(Date.now() / 1000) to get current time in seconds",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * - This matches PHP's time() function behavior",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Abstract Class",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-aware connection wrapper that manages WebSocket connection state,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * tracking, and lifecycle. Extends raw WebSocketConnection with application context,",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " * activity tracking, and state management.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Responsibilities:",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * - Wrap WebSocketConnection with application context",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * - Track connection activity via lastSeenAt timestamp",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " * - Implement state machine (Active/Inactive/Stale)",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage ping/pong state for connection health",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " * - Generate normalized socket IDs",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide connection lifecycle methods",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " * @abstract",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * class ReverbConnection extends Connection {",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *   identifier(): string {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " *     return String(this.connection.id());",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   id(): string {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     if (!this._id) {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *       this._id = this.generateId();",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " *     return this._id;",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " *   send(message: string): void {",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send(message);",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " *     // Dispatch MessageSent event",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " *   control(type: FrameOpcode = FrameOpcode.PING): void {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " *   terminate(): void {",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.close();",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "export abstract class Connection {",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * The last time the connection was seen (in seconds, not milliseconds).",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initialized to current time when connection is created.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Updated via touch() when activity is detected.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * Used to determine connection state (active/inactive/stale).",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 88,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.13950230181217194
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/server.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 57
                  },
                  "endPosition": {
                    "line": 342,
                    "column": 1
                  }
                },
                "contents": "import type { Router } from './router';\n\n/**\n * HTTP Server Implementation\n *\n * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\n * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\n *\n * Key features:\n * - Accepts incoming TCP connections via Bun.serve()\n * - HTTP request parsing and routing\n * - WebSocket upgrade handling with full lifecycle management\n * - Periodic garbage collection (every 30 seconds)\n * - Graceful start/stop lifecycle management\n * - TLS support detection\n *\n * The server uses Bun's native WebSocket API for efficient connection handling\n * and automatic binary/text frame management.\n *\n * @example\n * ```typescript\n * const server = new Server({\n *   port: 8080,\n *   host: 'localhost',\n *   logger,\n *   router,\n *   maxRequestSize: 1024 * 1024,\n *   tls: null,\n * });\n *\n * server.start();\n * // Server is now accepting connections...\n *\n * // Later, to stop:\n * server.stop();\n * ```\n */\nexport class Server {\n  /**\n   * The underlying Bun server instance.\n   *\n   * @private\n   */\n  private bunServer: ReturnType<typeof Bun.serve> | null = null;\n\n  /**\n   * Periodic timer for garbage collection.\n   *\n   * @private\n   */\n  private gcTimer: Timer | null = null;\n\n  /**\n   * Indicates whether the server is running.\n   *\n   * @private\n   */\n  private isRunning: boolean = false;\n\n  /**\n   * Server configuration options.\n   *\n   * @private\n   */\n  private readonly config: ServerConfig;\n\n  /**\n   * Create a new HTTP server instance.\n   *\n   * Initializes the server with configuration, logger, and router.\n   * Disables automatic garbage collection and sets up periodic manual GC.\n   *\n   * @param config - Server configuration object\n   */\n  constructor(config: ServerConfig) {\n    this.config = config;\n\n    // Disable automatic garbage collection; we'll do it manually\n    if (typeof gc !== 'undefined') {\n      // Note: gc.disable() may not be available in all Bun versions\n      (gc as any).disable?.();\n    }\n  }\n\n  /**\n   * Start the HTTP server.\n   *\n   * Initializes Bun.serve() with the configured port, host, and handlers.\n   * Sets up periodic garbage collection and error handling.\n   * The server will accept both HTTP and WebSocket connections.\n   *\n   * @throws Will log errors but not throw directly; error handling is done\n   *         through the logger interface\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { Router } from './router';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Server Implementation",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Key features:",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * - Accepts incoming TCP connections via Bun.serve()",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * - HTTP request parsing and routing",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - WebSocket upgrade handling with full lifecycle management",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Periodic garbage collection (every 30 seconds)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Graceful start/stop lifecycle management",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - TLS support detection",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * The server uses Bun's native WebSocket API for efficient connection handling",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * and automatic binary/text frame management.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * const server = new Server({",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " *   port: 8080,",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " *   host: 'localhost',",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *   logger,",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " *   router,",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " *   maxRequestSize: 1024 * 1024,",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " *   tls: null,",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * });",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " * server.start();",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " * // Server is now accepting connections...",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * // Later, to stop:",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * server.stop();",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "export class Server {",
                    "lineNumber": 39,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * The underlying Bun server instance.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "  private bunServer: ReturnType<typeof Bun.serve> | null = null;",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * Periodic timer for garbage collection.",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  private gcTimer: Timer | null = null;",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * Indicates whether the server is running.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "  private isRunning: boolean = false;",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * Server configuration options.",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "  private readonly config: ServerConfig;",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new HTTP server instance.",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initializes the server with configuration, logger, and router.",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   * Disables automatic garbage collection and sets up periodic manual GC.",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param config - Server configuration object",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(config: ServerConfig) {",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    this.config = config;",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    // Disable automatic garbage collection; we'll do it manually",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    if (typeof gc !== 'undefined') {",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "      // Note: gc.disable() may not be available in all Bun versions",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "      (gc as any).disable?.();",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * Start the HTTP server.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initializes Bun.serve() with the configured port, host, and handlers.",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * Sets up periodic garbage collection and error handling.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * The server will accept both HTTP and WebSocket connections.",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Will log errors but not throw directly; error handling is done",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   *         through the logger interface",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 343,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.1394176483154297
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/config/load.ts",
                "range": {
                  "startPosition": {
                    "line": 222,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 312,
                    "column": 1
                  }
                },
                "contents": "function loadAppsConfig(): AppsConfig {\n\n}\n\n/**\n * Load the complete Reverb configuration from environment variables or config file\n *\n * This function reads all necessary environment variables and constructs\n * a complete ReverbConfig object with sensible defaults matching the PHP\n * Laravel configuration.\n *\n * If a configPath is provided, it will attempt to load and merge that configuration\n * with environment variables (env vars take precedence).\n *\n * Required environment variables:\n * - REVERB_APP_KEY: Application key for authentication\n * - REVERB_APP_SECRET: Application secret for authentication\n * - REVERB_APP_ID: Application ID\n *\n * Optional environment variables (with defaults):\n * - REVERB_SERVER (default: 'reverb')\n * - REVERB_SERVER_HOST (default: '0.0.0.0')\n * - REVERB_SERVER_PORT (default: 8080)\n * - REVERB_SERVER_PATH (default: '')\n * - REVERB_HOST (default: undefined)\n * - REVERB_MAX_REQUEST_SIZE (default: 10000)\n * - REVERB_SCALING_ENABLED (default: false)\n * - REVERB_SCALING_CHANNEL (default: 'reverb')\n * - REDIS_URL (default: undefined)\n * - REDIS_HOST (default: '127.0.0.1')\n * - REDIS_PORT (default: '6379')\n * - REDIS_USERNAME (default: undefined)\n * - REDIS_PASSWORD (default: undefined)\n * - REDIS_DB (default: '0')\n * - REDIS_TIMEOUT (default: 60)\n * - REVERB_PULSE_INGEST_INTERVAL (default: 15)\n * - REVERB_TELESCOPE_INGEST_INTERVAL (default: 15)\n * - REVERB_PORT (default: 443)\n * - REVERB_SCHEME (default: 'https')\n * - REVERB_APP_PING_INTERVAL (default: 60)\n * - REVERB_APP_ACTIVITY_TIMEOUT (default: 30)\n * - REVERB_APP_MAX_CONNECTIONS (default: undefined)\n * - REVERB_APP_MAX_MESSAGE_SIZE (default: 10000)\n * - REVERB_ALLOWED_ORIGINS (default: '*', comma-separated)\n *\n * @param configPath - Optional path to a configuration file to load\n * @throws {Error} If required environment variables are not set\n * @returns The complete Reverb configuration\n */\nexport async function loadConfig(configPath?: string): Promise<ReverbConfig> {\n  const defaultServer = env('REVERB_SERVER', 'reverb')!;\n\n  // Build default config from environment\n  const envConfig: ReverbConfig = {\n    default: defaultServer,\n    servers: {\n      [defaultServer]: loadReverbServerConfig(),\n    },\n    apps: loadAppsConfig(),\n  };\n\n  // If a config file path is provided, try to load and merge it\n  if (configPath) {\n    try {\n      const fileConfig = await import(configPath);\n      const config = fileConfig.default || fileConfig;\n\n      // Merge configs - env vars take precedence\n      return {\n        ...config,\n        ...envConfig,\n        servers: {\n          ...config.servers,\n          ...envConfig.servers,\n        },\n        apps: {\n          ...config.apps,\n          ...envConfig.apps,\n        },\n      };\n    } catch (error) {\n      // If config file doesn't exist or can't be loaded, just use env config\n      console.warn(`Warning: Could not load config file at ${configPath}, using environment variables`);\n    }\n  }\n\n  return envConfig;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "function loadAppsConfig(): AppsConfig {",
                    "lineNumber": 223,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 227,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 228,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 229,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 230,
                    "isSignature": false
                  },
                  {
                    "text": " * Load the complete Reverb configuration from environment variables or config file",
                    "lineNumber": 231,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 232,
                    "isSignature": false
                  },
                  {
                    "text": " * This function reads all necessary environment variables and constructs",
                    "lineNumber": 233,
                    "isSignature": false
                  },
                  {
                    "text": " * a complete ReverbConfig object with sensible defaults matching the PHP",
                    "lineNumber": 234,
                    "isSignature": false
                  },
                  {
                    "text": " * Laravel configuration.",
                    "lineNumber": 235,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 236,
                    "isSignature": false
                  },
                  {
                    "text": " * If a configPath is provided, it will attempt to load and merge that configuration",
                    "lineNumber": 237,
                    "isSignature": false
                  },
                  {
                    "text": " * with environment variables (env vars take precedence).",
                    "lineNumber": 238,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 239,
                    "isSignature": false
                  },
                  {
                    "text": " * Required environment variables:",
                    "lineNumber": 240,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_KEY: Application key for authentication",
                    "lineNumber": 241,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_SECRET: Application secret for authentication",
                    "lineNumber": 242,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_ID: Application ID",
                    "lineNumber": 243,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 244,
                    "isSignature": false
                  },
                  {
                    "text": " * Optional environment variables (with defaults):",
                    "lineNumber": 245,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SERVER (default: 'reverb')",
                    "lineNumber": 246,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SERVER_HOST (default: '0.0.0.0')",
                    "lineNumber": 247,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SERVER_PORT (default: 8080)",
                    "lineNumber": 248,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SERVER_PATH (default: '')",
                    "lineNumber": 249,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_HOST (default: undefined)",
                    "lineNumber": 250,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_MAX_REQUEST_SIZE (default: 10000)",
                    "lineNumber": 251,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SCALING_ENABLED (default: false)",
                    "lineNumber": 252,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SCALING_CHANNEL (default: 'reverb')",
                    "lineNumber": 253,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_URL (default: undefined)",
                    "lineNumber": 254,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_HOST (default: '127.0.0.1')",
                    "lineNumber": 255,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_PORT (default: '6379')",
                    "lineNumber": 256,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_USERNAME (default: undefined)",
                    "lineNumber": 257,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_PASSWORD (default: undefined)",
                    "lineNumber": 258,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_DB (default: '0')",
                    "lineNumber": 259,
                    "isSignature": false
                  },
                  {
                    "text": " * - REDIS_TIMEOUT (default: 60)",
                    "lineNumber": 260,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_PULSE_INGEST_INTERVAL (default: 15)",
                    "lineNumber": 261,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_TELESCOPE_INGEST_INTERVAL (default: 15)",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_PORT (default: 443)",
                    "lineNumber": 263,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_SCHEME (default: 'https')",
                    "lineNumber": 264,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_PING_INTERVAL (default: 60)",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_ACTIVITY_TIMEOUT (default: 30)",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_MAX_CONNECTIONS (default: undefined)",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_APP_MAX_MESSAGE_SIZE (default: 10000)",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": " * - REVERB_ALLOWED_ORIGINS (default: '*', comma-separated)",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": " * @param configPath - Optional path to a configuration file to load",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If required environment variables are not set",
                    "lineNumber": 272,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns The complete Reverb configuration",
                    "lineNumber": 273,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 274,
                    "isSignature": false
                  },
                  {
                    "text": "export async function loadConfig(configPath?: string): Promise<ReverbConfig> {",
                    "lineNumber": 275,
                    "isSignature": true
                  },
                  {
                    "text": "  const defaultServer = env('REVERB_SERVER', 'reverb')!;",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 277,
                    "isSignature": false
                  },
                  {
                    "text": "  // Build default config from environment",
                    "lineNumber": 278,
                    "isSignature": false
                  },
                  {
                    "text": "  const envConfig: ReverbConfig = {",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "    default: defaultServer,",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "    servers: {",
                    "lineNumber": 281,
                    "isSignature": false
                  },
                  {
                    "text": "      [defaultServer]: loadReverbServerConfig(),",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": "    apps: loadAppsConfig(),",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": "  };",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": "  // If a config file path is provided, try to load and merge it",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": "  if (configPath) {",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": "      const fileConfig = await import(configPath);",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": "      const config = fileConfig.default || fileConfig;",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": "      // Merge configs - env vars take precedence",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": "      return {",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": "        ...config,",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": "        ...envConfig,",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": "        servers: {",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": "          ...config.servers,",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": "          ...envConfig.servers,",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": "        apps: {",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": "          ...config.apps,",
                    "lineNumber": 302,
                    "isSignature": false
                  },
                  {
                    "text": "          ...envConfig.apps,",
                    "lineNumber": 303,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 304,
                    "isSignature": false
                  },
                  {
                    "text": "      };",
                    "lineNumber": 305,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 306,
                    "isSignature": false
                  },
                  {
                    "text": "      // If config file doesn't exist or can't be loaded, just use env config",
                    "lineNumber": 307,
                    "isSignature": false
                  },
                  {
                    "text": "      console.warn(`Warning: Could not load config file at ${configPath}, using environment variables`);",
                    "lineNumber": 308,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 309,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 310,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 311,
                    "isSignature": false
                  },
                  {
                    "text": "  return envConfig;",
                    "lineNumber": 312,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 313,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.1335763931274414
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/cli.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 66,
                    "column": 1
                  }
                },
                "contents": "#!/usr/bin/env bun\n\n/**\n * Revurb CLI - Command-line interface for managing the WebSocket server\n *\n * A TypeScript port of Laravel Reverb's CLI commands\n *\n * @module cli\n */\n\nimport { Factory } from './Servers/Reverb/factory';\nimport { loadConfig } from './config/load';\nimport type { ReverbConfig } from './config/types';\nimport { PruneStaleConnections } from './jobs/prune-stale-connections';\nimport { PingInactiveConnections } from './jobs/ping-inactive-connections';\nimport { EventDispatcher } from './events/event-dispatcher';\nimport { ChannelCreated } from './events/channel-created';\nimport { ChannelRemoved } from './events/channel-removed';\nimport { ConnectionPruned } from './events/connection-pruned';\nimport { MessageSent } from './events/message-sent';\nimport { MessageReceived } from './events/message-received';\nimport type { ChannelConnection } from './Protocols/Pusher/Channels/channel-connection';\n\n/**\n * CLI argument parsing result\n */\ninterface ParsedArgs {\n  command: string;\n  options: Record<string, string | boolean>;\n  args: string[];\n}\n\n/**\n * Parse command-line arguments\n */\nfunction parseArgs(argv: string[]): ParsedArgs {\n  const args = argv.slice(2);\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "#!/usr/bin/env bun",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Revurb CLI - Command-line interface for managing the WebSocket server",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * A TypeScript port of Laravel Reverb's CLI commands",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * @module cli",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "import { Factory } from './Servers/Reverb/factory';",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "import { loadConfig } from './config/load';",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ReverbConfig } from './config/types';",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "import { PruneStaleConnections } from './jobs/prune-stale-connections';",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "import { PingInactiveConnections } from './jobs/ping-inactive-connections';",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "import { EventDispatcher } from './events/event-dispatcher';",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "import { ChannelCreated } from './events/channel-created';",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "import { ChannelRemoved } from './events/channel-removed';",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "import { ConnectionPruned } from './events/connection-pruned';",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageSent } from './events/message-sent';",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageReceived } from './events/message-received';",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelConnection } from './Protocols/Pusher/Channels/channel-connection';",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * CLI argument parsing result",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "interface ParsedArgs {",
                    "lineNumber": 27,
                    "isSignature": true
                  },
                  {
                    "text": "  command: string;",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  options: Record<string, string | boolean>;",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  args: string[];",
                    "lineNumber": 30,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 31,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * Parse command-line arguments",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "function parseArgs(argv: string[]): ParsedArgs {",
                    "lineNumber": 36,
                    "isSignature": true
                  },
                  {
                    "text": "  const args = argv.slice(2);",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 67,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.13171279430389404
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/application-manager.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 43,
                    "column": 3
                  }
                },
                "contents": "/**\n * ApplicationManager - Factory for creating application providers\n *\n * Manages the creation of application provider instances based on configured drivers.\n * This is a simplified implementation that replaces Laravel's Manager base class\n * with a basic factory pattern suitable for TypeScript/Bun.\n *\n * Responsibilities:\n * - Creates application provider instances based on driver configuration\n * - Supports multiple driver types (currently only 'config')\n * - Retrieves default driver from configuration\n *\n * Architecture Notes:\n * - Replaces Laravel's Manager class with a simple factory pattern\n * - Configuration is injected via constructor for dependency inversion\n * - Driver methods follow naming convention: create{Driver}Driver()\n *\n * @example\n * ```typescript\n * import { ApplicationManager } from './application-manager';\n * import type { ReverbConfig } from './config/types';\n *\n * // Create manager with configuration\n * const manager = new ApplicationManager(config);\n *\n * // Get default driver provider\n * const provider = manager.driver();\n *\n * // Get specific driver\n * const configProvider = manager.driver('config');\n * ```\n */\n\nimport { ConfigApplicationProvider } from './config-application-provider';\nimport type { ReverbConfig, ReverbAppConfig } from './config/types';\nimport type { IApplicationProvider } from './contracts/application-provider';\n\n/**\n * ApplicationManager class\n *\n * Factory for creating application provider instances based on configured drivers.\n * Provides a simple manager pattern for switching between different application\n * provider implementations (currently only 'config' driver is supported).\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * ApplicationManager - Factory for creating application providers",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Manages the creation of application provider instances based on configured drivers.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * This is a simplified implementation that replaces Laravel's Manager base class",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * with a basic factory pattern suitable for TypeScript/Bun.",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * Responsibilities:",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * - Creates application provider instances based on driver configuration",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * - Supports multiple driver types (currently only 'config')",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * - Retrieves default driver from configuration",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * Architecture Notes:",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Replaces Laravel's Manager class with a simple factory pattern",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Configuration is injected via constructor for dependency inversion",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Driver methods follow naming convention: create{Driver}Driver()",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * import { ApplicationManager } from './application-manager';",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * import type { ReverbConfig } from './config/types';",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * // Create manager with configuration",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * const manager = new ApplicationManager(config);",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " * // Get default driver provider",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * const provider = manager.driver();",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * // Get specific driver",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * const configProvider = manager.driver('config');",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "import { ConfigApplicationProvider } from './config-application-provider';",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ReverbConfig, ReverbAppConfig } from './config/types';",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IApplicationProvider } from './contracts/application-provider';",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " * ApplicationManager class",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory for creating application provider instances based on configured drivers.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides a simple manager pattern for switching between different application",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " * provider implementations (currently only 'config' driver is supported).",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 44,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.12526510655879974
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/jobs/ping-inactive-connections.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 78
                  },
                  "endPosition": {
                    "line": 79,
                    "column": 1
                  }
                },
                "contents": "import type { ILogger } from '../contracts/logger';\nimport type { ChannelManager } from '../Protocols/Pusher/Contracts/channel-manager';\nimport { EventHandler } from '../Protocols/Pusher/event-handler';\n\n/**\n * PingInactiveConnections Job\n *\n * Pings all inactive connections across all applications to detect\n * dead/stale connections and maintain connection health.\n *\n * Execution Flow:\n * 1. Iterate through all applications\n * 2. For each application, scope the channel manager\n * 3. Get all connections for the application\n * 4. Filter for inactive connections (isActive() === false)\n * 5. Send pusher:ping to each inactive connection\n * 6. Log each ping operation\n *\n * @example\n * ```typescript\n * const job = new PingInactiveConnections(applicationProvider, logger, channelManager);\n * await job.handle();\n * ```\n */\nexport class PingInactiveConnections {\n  /**\n   * Create a new PingInactiveConnections job instance.\n   *\n   * @param applicationProvider - Provider for accessing all applications\n   * @param logger - Logger instance for logging operations\n   * @param channels - Channel manager for accessing connections\n   */\n  constructor(\n    protected readonly applicationProvider: IApplicationProvider,\n    protected readonly logger: ILogger,\n    protected readonly channels: ChannelManager\n  ) {}\n\n  /**\n   * Execute the job.\n   *\n   * Iterates through all applications and their connections,\n   * sending ping messages to inactive connections.\n   */\n  async handle(): Promise<void> {\n    this.logger.info('Pinging Inactive Connections');\n\n    const pusher = new EventHandler(this.channels);\n\n    // Get all applications\n    const applications = this.applicationProvider.all();\n\n    // Process each application\n    for (const application of applications) {\n      // Scope channel manager to this application\n      const scopedChannels = this.channels.for(application);\n\n      // Get all connections for this application\n      const allConnections = scopedChannels.connections();\n\n      // Filter and ping inactive connections\n      for (const [, channelConnection] of Object.entries(allConnections)) {\n        // Unwrap the underlying connection from ChannelConnection\n        const connection = channelConnection.connection();\n\n        // Skip active connections\n        if (connection.isActive()) {\n          continue;\n        }\n\n        // Send ping to inactive connection\n        pusher.ping(connection);\n\n        // Log the ping\n        this.logger.info('Connection Pinged', connection.id());\n      }\n    }\n  }\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ILogger } from '../contracts/logger';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from '../Protocols/Pusher/Contracts/channel-manager';",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import { EventHandler } from '../Protocols/Pusher/event-handler';",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * PingInactiveConnections Job",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Pings all inactive connections across all applications to detect",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * dead/stale connections and maintain connection health.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * Execution Flow:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Iterate through all applications",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. For each application, scope the channel manager",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Get all connections for the application",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Filter for inactive connections (isActive() === false)",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Send pusher:ping to each inactive connection",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. Log each ping operation",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * const job = new PingInactiveConnections(applicationProvider, logger, channelManager);",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * await job.handle();",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "export class PingInactiveConnections {",
                    "lineNumber": 26,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new PingInactiveConnections job instance.",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applicationProvider - Provider for accessing all applications",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param logger - Logger instance for logging operations",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - Channel manager for accessing connections",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly applicationProvider: IApplicationProvider,",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly logger: ILogger,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly channels: ChannelManager",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * Execute the job.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * Iterates through all applications and their connections,",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * sending ping messages to inactive connections.",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(): Promise<void> {",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "    this.logger.info('Pinging Inactive Connections');",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    const pusher = new EventHandler(this.channels);",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get all applications",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    const applications = this.applicationProvider.all();",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each application",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const application of applications) {",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "      // Scope channel manager to this application",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "      const scopedChannels = this.channels.for(application);",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "      // Get all connections for this application",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "      const allConnections = scopedChannels.connections();",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "      // Filter and ping inactive connections",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "      for (const [, channelConnection] of Object.entries(allConnections)) {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "        // Unwrap the underlying connection from ChannelConnection",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "        const connection = channelConnection.connection();",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "        // Skip active connections",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "        if (connection.isActive()) {",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "          continue;",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "        // Send ping to inactive connection",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "        pusher.ping(connection);",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "        // Log the ping",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "        this.logger.info('Connection Pinged', connection.id());",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 80,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12267559766769409
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/server.ts",
                "range": {
                  "startPosition": {
                    "line": 38,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 342,
                    "column": 1
                  }
                },
                "contents": "export class Server {\n\n\n  /**\n   * Start the HTTP server.\n   *\n   * Initializes Bun.serve() with the configured port, host, and handlers.\n   * Sets up periodic garbage collection and error handling.\n   * The server will accept both HTTP and WebSocket connections.\n   *\n   * @throws Will log errors but not throw directly; error handling is done\n   *         through the logger interface\n   */\n  start(): void {\n    try {\n      const config: any = {\n        port: this.config.port,\n        hostname: this.config.host,\n        fetch: (req: Request, server: any) => this.handleRequest(req, server),\n        websocket: {\n          open: (ws: any) => this.handleWebSocketOpen(ws),\n          message: (ws: any, message: string | Buffer) => this.handleWebSocketMessage(ws, message),\n          close: (ws: any, code: number, reason: string) => this.handleWebSocketClose(ws, code, reason),\n          ping: (ws: any, data: Buffer) => this.handleWebSocketPing(ws, data),\n          pong: (ws: any, data: Buffer) => this.handleWebSocketPong(ws, data),\n        },\n      };\n\n      // Only add TLS if it's defined (not null or undefined)\n      if (this.config.tls) {\n        config.tls = this.config.tls;\n      }\n\n      this.bunServer = Bun.serve(config);\n\n      this.isRunning = true;\n\n      // Set up periodic garbage collection every 30 seconds\n      this.gcTimer = setInterval(() => {\n        if (typeof gc !== 'undefined') {\n          // Note: gc.collect() may not be available in all Bun versions\n          (gc as any).collect?.();\n        }\n      }, 30_000);\n\n      this.config.logger.info('Server started', `Listening on ${this.config.host}:${this.config.port}`);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.config.logger.error(message);\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Stop the HTTP server.\n   *\n   * Gracefully shuts down the server, stops garbage collection,\n   * and closes all connections.\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 39,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 39,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 39,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 40,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Server {",
                    "lineNumber": 39,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * Start the HTTP server.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initializes Bun.serve() with the configured port, host, and handlers.",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * Sets up periodic garbage collection and error handling.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * The server will accept both HTTP and WebSocket connections.",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Will log errors but not throw directly; error handling is done",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   *         through the logger interface",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "  start(): void {",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "      const config: any = {",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "        port: this.config.port,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "        hostname: this.config.host,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "        fetch: (req: Request, server: any) => this.handleRequest(req, server),",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "        websocket: {",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "          open: (ws: any) => this.handleWebSocketOpen(ws),",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "          message: (ws: any, message: string | Buffer) => this.handleWebSocketMessage(ws, message),",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "          close: (ws: any, code: number, reason: string) => this.handleWebSocketClose(ws, code, reason),",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "          ping: (ws: any, data: Buffer) => this.handleWebSocketPing(ws, data),",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "          pong: (ws: any, data: Buffer) => this.handleWebSocketPong(ws, data),",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      };",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "      // Only add TLS if it's defined (not null or undefined)",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "      if (this.config.tls) {",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "        config.tls = this.config.tls;",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "      this.bunServer = Bun.serve(config);",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "      this.isRunning = true;",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "      // Set up periodic garbage collection every 30 seconds",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      this.gcTimer = setInterval(() => {",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "        if (typeof gc !== 'undefined') {",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "          // Note: gc.collect() may not be available in all Bun versions",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "          (gc as any).collect?.();",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "      }, 30_000);",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "      this.config.logger.info('Server started', `Listening on ${this.config.host}:${this.config.port}`);",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "      const message = error instanceof Error ? error.message : String(error);",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "      this.config.logger.error(message);",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      this.isRunning = false;",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "   * Stop the HTTP server.",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gracefully shuts down the server, stops garbage collection,",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "   * and closes all connections.",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 343,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12231340259313583
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 256,
                    "column": 1
                  }
                },
                "contents": "import type { WebSocket } from \"bun\";\nimport type { IWebSocketConnection, Frame } from \"../../contracts/websocket-connection\";\n\n/**\n * WebSocket Connection Implementation\n *\n * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\n * This class handles WebSocket frame operations, message buffering for fragmented messages,\n * and control frame handling according to RFC 6455.\n *\n * Key responsibilities:\n * - Provide unique connection identification\n * - Send text/binary messages over the WebSocket\n * - Send and handle control frames (PING, PONG, CLOSE)\n * - Manage connection lifecycle with proper cleanup\n *\n * Note: Bun's WebSocket handles frame framing automatically, so we focus on\n * providing a consistent API for message handling and control frames.\n */\nexport class Connection implements IWebSocketConnection {\n  /**\n   * Handler for complete messages.\n   */\n  private onMessageHandler?: (message: string | Buffer) => void;\n\n  /**\n   * Handler for connection close.\n   */\n  // @ts-expect-error - Reserved for future use\n  private _onCloseHandler?: () => void;\n\n  /**\n   * Maximum allowed message payload size in bytes.\n   */\n  private maxMessageSize?: number;\n\n  /**\n   * Unique connection identifier.\n   */\n  private connectionId: string;\n\n  /**\n   * Create a new WebSocket connection instance.\n   *\n   * @param socket - The Bun WebSocket instance\n   */\n  constructor(private socket: WebSocket) {\n    // Generate a unique connection ID using the socket's internal data\n    this.connectionId = this.generateConnectionId();\n    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\n    // not on individual socket objects. We don't need setupHandlers() here.\n  }\n\n  /**\n   * Generate a unique connection identifier.\n   * Uses the socket's remoteAddress and a timestamp for uniqueness.\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { WebSocket } from \"bun\";",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IWebSocketConnection, Frame } from \"../../contracts/websocket-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocket Connection Implementation",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * This class handles WebSocket frame operations, message buffering for fragmented messages,",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * and control frame handling according to RFC 6455.",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * Key responsibilities:",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide unique connection identification",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send text/binary messages over the WebSocket",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send and handle control frames (PING, PONG, CLOSE)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage connection lifecycle with proper cleanup",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * Note: Bun's WebSocket handles frame framing automatically, so we focus on",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * providing a consistent API for message handling and control frames.",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection implements IWebSocketConnection {",
                    "lineNumber": 20,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for complete messages.",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "  private onMessageHandler?: (message: string | Buffer) => void;",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for connection close.",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  // @ts-expect-error - Reserved for future use",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  private _onCloseHandler?: () => void;",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   * Maximum allowed message payload size in bytes.",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "  private maxMessageSize?: number;",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   * Unique connection identifier.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "  private connectionId: string;",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new WebSocket connection instance.",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param socket - The Bun WebSocket instance",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private socket: WebSocket) {",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "    // Generate a unique connection ID using the socket's internal data",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    this.connectionId = this.generateConnectionId();",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    // not on individual socket objects. We don't need setupHandlers() here.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate a unique connection identifier.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   * Uses the socket's remoteAddress and a timestamp for uniqueness.",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 257,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12085729837417603
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Publishing/redis-client-factory.ts",
                "range": {
                  "startPosition": {
                    "line": 83,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 183,
                    "column": 1
                  }
                },
                "contents": "export class RedisClientFactory {\n\n\n  /**\n   * Create a Redis client with the given configuration\n   *\n   * This method creates the actual Redis client connection.\n   * It serves as an extension point for dependency injection.\n   *\n   * @param config - Redis connection configuration\n   * @returns Promise that resolves to a connected Redis client\n   *\n   * @private\n   */\n  private async createClient(_config: Record<string, unknown>): Promise<RedisClient> {\n    // This is where the actual Redis client library would be instantiated\n    // For example, using node-redis:\n    // const redis = require('redis');\n    // const client = redis.createClient(config);\n    // await client.connect();\n    // return client;\n\n    // Placeholder implementation for Bun integration\n    return {\n      ping: async () => 'PONG',\n      subscribe: async () => {},\n      unsubscribe: async () => {},\n      publish: async () => 0,\n      get: async () => null,\n      set: async () => {},\n      del: async () => 0,\n      quit: async () => {},\n      on: () => {},\n    };\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 84,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 84,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 84,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 85,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class RedisClientFactory {",
                    "lineNumber": 84,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a Redis client with the given configuration",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method creates the actual Redis client connection.",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * It serves as an extension point for dependency injection.",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param config - Redis connection configuration",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise that resolves to a connected Redis client",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "  private async createClient(_config: Record<string, unknown>): Promise<RedisClient> {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "    // This is where the actual Redis client library would be instantiated",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "    // For example, using node-redis:",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "    // const redis = require('redis');",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "    // const client = redis.createClient(config);",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "    // await client.connect();",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    // return client;",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // Placeholder implementation for Bun integration",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return {",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "      ping: async () => 'PONG',",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "      subscribe: async () => {},",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "      unsubscribe: async () => {},",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "      publish: async () => 0,",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "      get: async () => null,",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "      set: async () => {},",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "      del: async () => 0,",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "      quit: async () => {},",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "      on: () => {},",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "    };",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 184,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.11524444818496704
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/index.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 9,
                    "column": 35
                  }
                },
                "contents": "/**\n * Revurb - Bun-powered real-time WebSocket server\n * A TypeScript port of Laravel Reverb implementing the Pusher protocol\n *\n * @module revurb\n */\n\nexport * from './contracts/connection';\nexport * from './contracts/websocket-connection';\nexport * from './contracts/logger';",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * Revurb - Bun-powered real-time WebSocket server",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " * A TypeScript port of Laravel Reverb implementing the Pusher protocol",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * @module revurb",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "export * from './contracts/connection';",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "export * from './contracts/websocket-connection';",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "export * from './contracts/logger';",
                    "lineNumber": 10,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.11358559876680374
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/jobs/prune-stale-connections.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 78
                  },
                  "endPosition": {
                    "line": 99,
                    "column": 1
                  }
                },
                "contents": "import type { ILogger } from '../contracts/logger';\nimport type { ChannelManager } from '../Protocols/Pusher/Contracts/channel-manager';\nimport type { ChannelConnection } from '../Protocols/Pusher/Channels/channel-connection';\nimport { ConnectionPruned } from '../events/connection-pruned';\n\n/**\n * PruneStaleConnections Job\n *\n * Removes stale connections (inactive and pinged) across all applications.\n *\n * Execution Flow:\n * 1. Iterate through all applications\n * 2. For each application, scope the channel manager\n * 3. Get all connections for the application\n * 4. Filter for stale connections (isStale() === true)\n * 5. Send pusher:error event with pong timeout code 4201\n * 6. Unsubscribe connection from all channels\n * 7. Disconnect the connection\n * 8. Dispatch ConnectionPruned event\n * 9. Log each prune operation\n *\n * @example\n * ```typescript\n * const job = new PruneStaleConnections(applicationProvider, logger, channelManager);\n * await job.handle();\n * ```\n */\nexport class PruneStaleConnections {\n  /**\n   * Create a new PruneStaleConnections job instance.\n   *\n   * @param applicationProvider - Provider for accessing all applications\n   * @param logger - Logger instance for logging operations\n   * @param channels - Channel manager for accessing connections\n   */\n  constructor(\n    protected readonly applicationProvider: IApplicationProvider,\n    protected readonly logger: ILogger,\n    protected readonly channels: ChannelManager\n  ) {}\n\n  /**\n   * Execute the job.\n   *\n   * Iterates through all applications and their connections,\n   * pruning stale connections that have not responded to pings.\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ILogger } from '../contracts/logger';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from '../Protocols/Pusher/Contracts/channel-manager';",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelConnection } from '../Protocols/Pusher/Channels/channel-connection';",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { ConnectionPruned } from '../events/connection-pruned';",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * PruneStaleConnections Job",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Removes stale connections (inactive and pinged) across all applications.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * Execution Flow:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Iterate through all applications",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. For each application, scope the channel manager",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Get all connections for the application",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Filter for stale connections (isStale() === true)",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Send pusher:error event with pong timeout code 4201",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. Unsubscribe connection from all channels",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * 7. Disconnect the connection",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * 8. Dispatch ConnectionPruned event",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * 9. Log each prune operation",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * const job = new PruneStaleConnections(applicationProvider, logger, channelManager);",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " * await job.handle();",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "export class PruneStaleConnections {",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new PruneStaleConnections job instance.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applicationProvider - Provider for accessing all applications",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param logger - Logger instance for logging operations",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - Channel manager for accessing connections",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly applicationProvider: IApplicationProvider,",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly logger: ILogger,",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly channels: ChannelManager",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * Execute the job.",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * Iterates through all applications and their connections,",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * pruning stale connections that have not responded to pings.",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 100,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.11165879666805267
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/server.ts",
                "range": {
                  "startPosition": {
                    "line": 38,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 342,
                    "column": 1
                  }
                },
                "contents": "export class Server {\n\n\n  /**\n   * Handle incoming HTTP requests.\n   *\n   * Routes HTTP requests and handles WebSocket upgrades.\n   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.\n   * For regular HTTP requests, this routes to the router for application logic.\n   *\n   * @param req - The incoming HTTP request\n   * @param server - The Bun server instance (used for WebSocket upgrades)\n   * @returns A Response object for the request\n   *\n   * @private\n   */\n  private async handleRequest(req: Request, server: any): Promise<Response | undefined> {\n    const url = new URL(req.url);\n    const pathname = url.pathname;\n\n    // Attempt WebSocket upgrade for specific paths\n    if (this.shouldUpgradeToWebSocket(pathname, req)) {\n      if (server.upgrade(req)) {\n        return undefined;\n      }\n    }\n\n    // Route HTTP requests\n    try {\n      // For HTTP requests, pass null as connection since we don't have a Connection object yet\n      const result = await this.config.router.dispatch(req as any, null as any);\n\n      // If result is already a Response, return it\n      if (result instanceof Response) {\n        return result;\n      }\n\n      // Otherwise, wrap result in a Response\n      return new Response(JSON.stringify(result), {\n        status: 200,\n        headers: { 'content-type': 'application/json' },\n      });\n    } catch (error) {\n      if (error instanceof HttpException) {\n        return new Response(error.message, {\n          status: error.statusCode,\n          headers: { 'content-type': 'text/plain' },\n        });\n      }\n\n      const message = error instanceof Error ? error.message : 'Internal server error';\n      this.config.logger.error(message);\n\n      return new Response('Internal server error', {\n        status: 500,\n        headers: { 'content-type': 'text/plain' },\n      });\n    }\n  }\n\n  /**\n   * Determine if a request should be upgraded to WebSocket.\n   *\n   * Checks if the request is a WebSocket upgrade request and if the path\n   * is one that should be handled as a WebSocket connection.\n   *\n   * @param pathname - The request path\n   * @param req - The incoming HTTP request\n   * @returns true if the request should be upgraded to WebSocket\n   *\n   * @private\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 39,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 39,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 39,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 40,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Server {",
                    "lineNumber": 39,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle incoming HTTP requests.",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "   * Routes HTTP requests and handles WebSocket upgrades.",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "   * For regular HTTP requests, this routes to the router for application logic.",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The incoming HTTP request",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param server - The Bun server instance (used for WebSocket upgrades)",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns A Response object for the request",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  private async handleRequest(req: Request, server: any): Promise<Response | undefined> {",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(req.url);",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "    const pathname = url.pathname;",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "    // Attempt WebSocket upgrade for specific paths",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.shouldUpgradeToWebSocket(pathname, req)) {",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "      if (server.upgrade(req)) {",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "        return undefined;",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "    // Route HTTP requests",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "      // For HTTP requests, pass null as connection since we don't have a Connection object yet",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "      const result = await this.config.router.dispatch(req as any, null as any);",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "      // If result is already a Response, return it",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "      if (result instanceof Response) {",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "        return result;",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "      // Otherwise, wrap result in a Response",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(JSON.stringify(result), {",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "        status: 200,",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "        headers: { 'content-type': 'application/json' },",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "      if (error instanceof HttpException) {",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "        return new Response(error.message, {",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "          status: error.statusCode,",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "          headers: { 'content-type': 'text/plain' },",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "        });",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "      const message = error instanceof Error ? error.message : 'Internal server error';",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "      this.config.logger.error(message);",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response('Internal server error', {",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "        status: 500,",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "        headers: { 'content-type': 'text/plain' },",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "   * Determine if a request should be upgraded to WebSocket.",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": "   * Checks if the request is a WebSocket upgrade request and if the path",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": "   * is one that should be handled as a WebSocket connection.",
                    "lineNumber": 221,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param pathname - The request path",
                    "lineNumber": 223,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The incoming HTTP request",
                    "lineNumber": 224,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns true if the request should be upgraded to WebSocket",
                    "lineNumber": 225,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 226,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 227,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 228,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 343,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10998576879501343
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 74
                  },
                  "endPosition": {
                    "line": 118,
                    "column": 1
                  }
                },
                "contents": "import type { IWebSocketConnection, FrameOpcode } from './contracts/websocket-connection';\nimport type { Application } from './application';\nimport { MessageSent } from './events/message-sent';\nimport { FrameOpcode as FrameOpcodeEnum } from './contracts/websocket-connection';\n\n/**\n * Connection Implementation\n *\n * Concrete implementation of the Connection contract that wraps a WebSocket\n * connection with application context and state management.\n *\n * This class implements the Pusher-compatible connection wrapper, handling:\n * - Connection identification and normalization\n * - Message sending with event dispatching\n * - Control frame management (PING/PONG)\n * - Connection lifecycle and termination\n *\n * The connection maintains state through the abstract base class:\n * - lastSeenAt: Timestamp tracking for activity monitoring\n * - hasBeenPinged: Ping state for stale connection detection\n * - usesControlFrames: Whether the connection uses control frames\n *\n * @see Connection contract for state machine documentation\n */\nexport class Connection extends ConnectionContract {\n  /**\n   * The normalized socket ID.\n   *\n   * Cached socket ID in Pusher format (\"number.number\").\n   * Generated once on first access and reused for connection lifetime.\n   *\n   * @private\n   */\n  private _id: string | null = null;\n\n  /**\n   * Create a new connection instance.\n   *\n   * @param connection - The underlying WebSocket connection\n   * @param application - The application this connection belongs to\n   * @param origin - The origin of the connection (nullable)\n   */\n  constructor(\n    connection: IWebSocketConnection,\n    application: Application,\n    origin: string | null\n  ) {\n    super(connection, application, origin);\n  }\n\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * Returns the underlying WebSocket connection's identifier as a string.\n   * This is the raw transport-level identifier, not the normalized socket ID.\n   *\n   * @returns The raw connection identifier as a string\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IWebSocketConnection, FrameOpcode } from './contracts/websocket-connection';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Application } from './application';",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageSent } from './events/message-sent';",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { FrameOpcode as FrameOpcodeEnum } from './contracts/websocket-connection';",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Implementation",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Concrete implementation of the Connection contract that wraps a WebSocket",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * connection with application context and state management.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * This class implements the Pusher-compatible connection wrapper, handling:",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection identification and normalization",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Message sending with event dispatching",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Control frame management (PING/PONG)",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection lifecycle and termination",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * The connection maintains state through the abstract base class:",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - lastSeenAt: Timestamp tracking for activity monitoring",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - hasBeenPinged: Ping state for stale connection detection",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * - usesControlFrames: Whether the connection uses control frames",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * @see Connection contract for state machine documentation",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection extends ConnectionContract {",
                    "lineNumber": 26,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   * The normalized socket ID.",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Cached socket ID in Pusher format (\"number.number\").",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generated once on first access and reused for connection lifetime.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "  private _id: string | null = null;",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new connection instance.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The underlying WebSocket connection",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application this connection belongs to",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param origin - The origin of the connection (nullable)",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "    connection: IWebSocketConnection,",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "    origin: string | null",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    super(connection, application, origin);",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns the underlying WebSocket connection's identifier as a string.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is the raw transport-level identifier, not the normalized socket ID.",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The raw connection identifier as a string",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 119,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10942909866571426
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/jobs/prune-stale-connections.ts",
                "range": {
                  "startPosition": {
                    "line": 28,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 99,
                    "column": 1
                  }
                },
                "contents": "export class PruneStaleConnections {\n\n\n  /**\n   * Execute the job.\n   *\n   * Iterates through all applications and their connections,\n   * pruning stale connections that have not responded to pings.\n   */\n  async handle(): Promise<void> {\n    this.logger.info('Pruning Stale Connections');\n\n    // Get all applications\n    const applications = this.applicationProvider.all();\n\n    // Process each application\n    for (const application of applications) {\n      // Scope channel manager to this application\n      const scopedChannels = this.channels.for(application);\n\n      // Get all connections for this application\n      const allConnections = scopedChannels.connections();\n\n      // Filter and prune stale connections\n      for (const [, channelConnection] of Object.entries(allConnections)) {\n        // Type assertion for ChannelConnection\n        const channelConn = channelConnection as ChannelConnection;\n        // Skip active connections\n        if (!channelConn.isStale()) {\n          continue;\n        }\n\n        // Get the underlying connection for unsubscribeFromAll\n        const connection = channelConn.connection();\n\n        // Send pusher:error event with pong timeout\n        channelConn.send(\n          JSON.stringify({\n            event: 'pusher:error',\n            data: JSON.stringify({\n              code: 4201,\n              message: 'Pong reply not received in time',\n            }),\n          })\n        );\n\n        // Unsubscribe from all channels (requires underlying Connection)\n        scopedChannels.unsubscribeFromAll(connection);\n\n        // Disconnect the connection\n        channelConn.disconnect();\n\n        // Dispatch ConnectionPruned event\n        ConnectionPruned.dispatch(channelConn);\n\n        // Log the prune operation\n        this.logger.info('Connection Pruned', channelConn.id());\n      }\n    }\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 29,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 29,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 29,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 30,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class PruneStaleConnections {",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * Execute the job.",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * Iterates through all applications and their connections,",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * pruning stale connections that have not responded to pings.",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(): Promise<void> {",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "    this.logger.info('Pruning Stale Connections');",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get all applications",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    const applications = this.applicationProvider.all();",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each application",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const application of applications) {",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "      // Scope channel manager to this application",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "      const scopedChannels = this.channels.for(application);",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "      // Get all connections for this application",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "      const allConnections = scopedChannels.connections();",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "      // Filter and prune stale connections",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "      for (const [, channelConnection] of Object.entries(allConnections)) {",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "        // Type assertion for ChannelConnection",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "        const channelConn = channelConnection as ChannelConnection;",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "        // Skip active connections",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "        if (!channelConn.isStale()) {",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "          continue;",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "        // Get the underlying connection for unsubscribeFromAll",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "        const connection = channelConn.connection();",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "        // Send pusher:error event with pong timeout",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "        channelConn.send(",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "          JSON.stringify({",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "            event: 'pusher:error',",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "            data: JSON.stringify({",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "              code: 4201,",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "              message: 'Pong reply not received in time',",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "            }),",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "          })",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "        // Unsubscribe from all channels (requires underlying Connection)",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "        scopedChannels.unsubscribeFromAll(connection);",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "        // Disconnect the connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "        channelConn.disconnect();",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "        // Dispatch ConnectionPruned event",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "        ConnectionPruned.dispatch(channelConn);",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "        // Log the prune operation",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "        this.logger.info('Connection Pruned', channelConn.id());",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 100,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10880090296268463
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/contracts/logger.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 99,
                    "column": 1
                  }
                },
                "contents": "/**\n * Logger Contract\n *\n * Provides a unified interface for logging throughout the Revurb server.\n * Implementations include StandardLogger (file-based), CliLogger (console output),\n * and NullLogger (no-op for testing).\n *\n * @example\n * ```typescript\n * const logger: ILogger = new StandardLogger();\n * logger.info('Server started', 'Listening on port 8080');\n * logger.error('Connection failed');\n * logger.message('{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"presence-chat\"}}');\n * logger.line(2);\n * ```\n */\nexport interface ILogger {\n  /**\n   * Log an informational message.\n   *\n   * This method is used for general informational logging throughout the server.\n   * The message parameter is optional and can provide additional context.\n   *\n   * @param title - The main title or summary of the log entry\n   * @param message - Optional additional details or context\n   *\n   * @example\n   * ```typescript\n   * logger.info('Connection established');\n   * logger.info('Client connected', 'Socket ID: abc123');\n   * ```\n   */\n  info(title: string, message?: string | null): void;\n\n  /**\n   * Log an error message.\n   *\n   * This method is used to log error conditions, exceptions, or critical issues\n   * that occur during server operation.\n   *\n   * @param message - The error message to log\n   *\n   * @example\n   * ```typescript\n   * logger.error('Failed to authenticate client');\n   * logger.error('WebSocket connection closed unexpectedly');\n   * ```\n   */\n  error(message: string): void;\n\n  /**\n   * Log a debug message.\n   *\n   * This method is used for debug-level logging that provides detailed information\n   * about the internal state and operations of the server. Debug messages are typically\n   * only enabled during development or troubleshooting.\n   *\n   * @param message - The debug message to log\n   *\n   * @example\n   * ```typescript\n   * logger.debug('Channel created: presence-chat');\n   * logger.debug('Connection pruned: abc123');\n   * ```\n   */\n  debug(message: string): void;\n\n  /**\n   * Log a WebSocket message sent to the server.\n   *\n   * This method is specifically designed for logging WebSocket protocol messages.\n   * The message should be a JSON string representing a WebSocket event.\n   * Implementations may pretty-print or format the JSON for better readability.\n   *\n   * @param message - A JSON string containing the WebSocket message data\n   *\n   * @example\n   * ```typescript\n   * logger.message('{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"presence-chat\"}}');\n   * logger.message('{\"event\":\"client-message\",\"data\":{\"text\":\"Hello\"}}');\n   * ```\n   */\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * Logger Contract",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides a unified interface for logging throughout the Revurb server.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Implementations include StandardLogger (file-based), CliLogger (console output),",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * and NullLogger (no-op for testing).",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * const logger: ILogger = new StandardLogger();",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * logger.info('Server started', 'Listening on port 8080');",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * logger.error('Connection failed');",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * logger.message('{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"presence-chat\"}}');",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * logger.line(2);",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ILogger {",
                    "lineNumber": 17,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "   * Log an informational message.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method is used for general informational logging throughout the server.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "   * The message parameter is optional and can provide additional context.",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param title - The main title or summary of the log entry",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - Optional additional details or context",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.info('Connection established');",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.info('Client connected', 'Socket ID: abc123');",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  info(title: string, message?: string | null): void;",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   * Log an error message.",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method is used to log error conditions, exceptions, or critical issues",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   * that occur during server operation.",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The error message to log",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.error('Failed to authenticate client');",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.error('WebSocket connection closed unexpectedly');",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "  error(message: string): void;",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * Log a debug message.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method is used for debug-level logging that provides detailed information",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * about the internal state and operations of the server. Debug messages are typically",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   * only enabled during development or troubleshooting.",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The debug message to log",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.debug('Channel created: presence-chat');",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.debug('Connection pruned: abc123');",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "  debug(message: string): void;",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * Log a WebSocket message sent to the server.",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method is specifically designed for logging WebSocket protocol messages.",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   * The message should be a JSON string representing a WebSocket event.",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * Implementations may pretty-print or format the JSON for better readability.",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - A JSON string containing the WebSocket message data",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.message('{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"presence-chat\"}}');",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * logger.message('{\"event\":\"client-message\",\"data\":{\"text\":\"Hello\"}}');",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 99,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 100,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10685370117425919
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 165,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1147,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\n;\n\n  /**\n   * Initialize the factory with configuration\n   *\n   * @param config - The Reverb configuration\n   */\n  public static initialize(config: ReverbConfig): void {\n    this.logger = new CliLogger();\n    // Set the logger in the Log facade so it's available globally\n    Log.setLogger(this.logger);\n    this.appManager = new ApplicationManager(config);\n\n    // Create application provider and channel connection manager\n    this.applicationProvider = this.appManager.driver();\n    const channelConnectionManager = new ArrayChannelConnectionManager();\n\n    this.channelManager = new ArrayChannelManager(\n      this.applicationProvider,\n      channelConnectionManager,\n      this.logger\n    );\n\n    const eventHandler = new EventHandler(this.channelManager);\n    const clientEvent = new ClientEvent(this.channelManager);\n\n    this.pusherServer = new PusherServer(\n      this.channelManager,\n      eventHandler,\n      clientEvent,\n      this.logger\n    );\n\n    // Create a minimal server provider\n    // By default, server does not subscribe to events (standalone mode)\n    this.serverProvider = new class extends ServerProvider {\n      subscribesToEvents(): boolean {\n        return false;\n      }\n    }();\n\n    // Initialize metrics handler with all required dependencies\n    this.metricsHandler = new MetricsHandler(\n      this.serverProvider as any,\n      this.channelManager as any,\n      null as any\n    );\n\n    // Initialize class-based controllers with proper dependencies\n    this.eventsController = new EventsController(this.channelManager, this.metricsHandler);\n    this.eventsBatchController = new EventsBatchController(this.metricsHandler);\n    this.channelsController = new ChannelsController(\n      this.metricsHandler,\n      this.applicationProvider,\n      this.channelManager\n    );\n    this.channelController = new ChannelController(\n      this.applicationProvider,\n      this.channelManager,\n      this.metricsHandler\n    );\n    this.usersTerminateController = new UsersTerminateController(\n      this.applicationProvider,\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 166,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 166,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 166,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 167,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 166,
                    "isSignature": true
                  },
                  {
                    "text": ";",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initialize the factory with configuration",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param config - The Reverb configuration",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "  public static initialize(config: ReverbConfig): void {",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "    this.logger = new CliLogger();",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "    // Set the logger in the Log facade so it's available globally",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "    Log.setLogger(this.logger);",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": "    this.appManager = new ApplicationManager(config);",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 221,
                    "isSignature": false
                  },
                  {
                    "text": "    // Create application provider and channel connection manager",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": "    this.applicationProvider = this.appManager.driver();",
                    "lineNumber": 223,
                    "isSignature": false
                  },
                  {
                    "text": "    const channelConnectionManager = new ArrayChannelConnectionManager();",
                    "lineNumber": 224,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 225,
                    "isSignature": false
                  },
                  {
                    "text": "    this.channelManager = new ArrayChannelManager(",
                    "lineNumber": 226,
                    "isSignature": false
                  },
                  {
                    "text": "      this.applicationProvider,",
                    "lineNumber": 227,
                    "isSignature": false
                  },
                  {
                    "text": "      channelConnectionManager,",
                    "lineNumber": 228,
                    "isSignature": false
                  },
                  {
                    "text": "      this.logger",
                    "lineNumber": 229,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 230,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 231,
                    "isSignature": false
                  },
                  {
                    "text": "    const eventHandler = new EventHandler(this.channelManager);",
                    "lineNumber": 232,
                    "isSignature": false
                  },
                  {
                    "text": "    const clientEvent = new ClientEvent(this.channelManager);",
                    "lineNumber": 233,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 234,
                    "isSignature": false
                  },
                  {
                    "text": "    this.pusherServer = new PusherServer(",
                    "lineNumber": 235,
                    "isSignature": false
                  },
                  {
                    "text": "      this.channelManager,",
                    "lineNumber": 236,
                    "isSignature": false
                  },
                  {
                    "text": "      eventHandler,",
                    "lineNumber": 237,
                    "isSignature": false
                  },
                  {
                    "text": "      clientEvent,",
                    "lineNumber": 238,
                    "isSignature": false
                  },
                  {
                    "text": "      this.logger",
                    "lineNumber": 239,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 240,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 241,
                    "isSignature": false
                  },
                  {
                    "text": "    // Create a minimal server provider",
                    "lineNumber": 242,
                    "isSignature": false
                  },
                  {
                    "text": "    // By default, server does not subscribe to events (standalone mode)",
                    "lineNumber": 243,
                    "isSignature": false
                  },
                  {
                    "text": "    this.serverProvider = new class extends ServerProvider {",
                    "lineNumber": 244,
                    "isSignature": false
                  },
                  {
                    "text": "      subscribesToEvents(): boolean {",
                    "lineNumber": 245,
                    "isSignature": false
                  },
                  {
                    "text": "        return false;",
                    "lineNumber": 246,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 247,
                    "isSignature": false
                  },
                  {
                    "text": "    }();",
                    "lineNumber": 248,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 249,
                    "isSignature": false
                  },
                  {
                    "text": "    // Initialize metrics handler with all required dependencies",
                    "lineNumber": 250,
                    "isSignature": false
                  },
                  {
                    "text": "    this.metricsHandler = new MetricsHandler(",
                    "lineNumber": 251,
                    "isSignature": false
                  },
                  {
                    "text": "      this.serverProvider as any,",
                    "lineNumber": 252,
                    "isSignature": false
                  },
                  {
                    "text": "      this.channelManager as any,",
                    "lineNumber": 253,
                    "isSignature": false
                  },
                  {
                    "text": "      null as any",
                    "lineNumber": 254,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 255,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 256,
                    "isSignature": false
                  },
                  {
                    "text": "    // Initialize class-based controllers with proper dependencies",
                    "lineNumber": 257,
                    "isSignature": false
                  },
                  {
                    "text": "    this.eventsController = new EventsController(this.channelManager, this.metricsHandler);",
                    "lineNumber": 258,
                    "isSignature": false
                  },
                  {
                    "text": "    this.eventsBatchController = new EventsBatchController(this.metricsHandler);",
                    "lineNumber": 259,
                    "isSignature": false
                  },
                  {
                    "text": "    this.channelsController = new ChannelsController(",
                    "lineNumber": 260,
                    "isSignature": false
                  },
                  {
                    "text": "      this.metricsHandler,",
                    "lineNumber": 261,
                    "isSignature": false
                  },
                  {
                    "text": "      this.applicationProvider,",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": "      this.channelManager",
                    "lineNumber": 263,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 264,
                    "isSignature": false
                  },
                  {
                    "text": "    this.channelController = new ChannelController(",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "      this.applicationProvider,",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": "      this.channelManager,",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": "      this.metricsHandler",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": "    this.usersTerminateController = new UsersTerminateController(",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": "      this.applicationProvider,",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1148,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10280320048332214
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/router.ts",
                "range": {
                  "startPosition": {
                    "line": 25,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 419,
                    "column": 1
                  }
                },
                "contents": "export class Router {\n\n\n  /**\n   * Dispatch the HTTP request to the appropriate controller\n   *\n   * This method:\n   * 1. Matches the request URI to a route\n   * 2. Extracts the controller and route parameters\n   * 3. Handles WebSocket upgrades if requested\n   * 4. Resolves controller parameters from route and request context\n   * 5. Calls the controller with appropriate arguments\n   * 6. Handles HTTP errors (404, 405, 500)\n   *\n   * @param request - The HTTP request object\n   * @param connection - The connection object\n   * @returns The controller response (Promise, string, or any result)\n   *\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\n   */\n  async dispatch(request: IHttpRequest, connection: Connection): Promise<any> {\n    try {\n      // Set up route matcher context\n      this.matcher.setContext({\n        method: request.getMethod(),\n        host: request.getHost(),\n      });\n\n      // Attempt to match the route\n      let route: Record<string, any>;\n      try {\n        route = this.matcher.match(request.getPath());\n      } catch (error) {\n        if (this.isMethodNotAllowedException(error)) {\n          const allowedMethods = this.getAllowedMethods(error);\n          this.close(connection, 405, 'Method not allowed.', { Allow: allowedMethods });\n          return null;\n        }\n\n        if (this.isResourceNotFoundException(error)) {\n          this.close(connection, 404, 'Not found.');\n          return null;\n        }\n\n        throw error;\n      }\n\n      // Get the controller from the route\n      const controller = this.controller(route);\n\n      // Check if this is a WebSocket upgrade request\n      if (this.isWebSocketRequest(request)) {\n        const wsConnection = this.attemptUpgrade(request, connection);\n\n        // Call the controller with websocket connection and route parameters\n        const routeParams = this.extractRouteParams(route);\n        return await controller(request, wsConnection, ...Object.values(routeParams));\n      }\n\n      // For HTTP requests, resolve parameters and call controller\n      const routeParameters = {\n        ...this.extractRouteParams(route),\n        request,\n        connection,\n      };\n\n      const args = this.arguments(controller, routeParameters);\n      const response = await controller(...args);\n\n      // Send response and close connection\n      return this.sendResponse(connection, response);\n    } catch (error) {\n      // Handle unexpected errors\n      this.close(connection, 500, 'Internal server error.');\n      throw error;\n    }\n  }\n\n  /**\n   * Get the controller callable for the given route\n   *\n   * @param route - The matched route object\n   * @returns The controller function/callback\n   *\n   * @private\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 26,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 26,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 26,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 27,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Router {",
                    "lineNumber": 26,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * Dispatch the HTTP request to the appropriate controller",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Matches the request URI to a route",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Extracts the controller and route parameters",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Handles WebSocket upgrades if requested",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Resolves controller parameters from route and request context",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Calls the controller with appropriate arguments",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * 6. Handles HTTP errors (404, 405, 500)",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection object",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The controller response (Promise, string, or any result)",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Will close connection with appropriate HTTP error code if route matching fails",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  async dispatch(request: IHttpRequest, connection: Connection): Promise<any> {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "      // Set up route matcher context",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "      this.matcher.setContext({",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "        method: request.getMethod(),",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "        host: request.getHost(),",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "      // Attempt to match the route",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "      let route: Record<string, any>;",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "      try {",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "        route = this.matcher.match(request.getPath());",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "      } catch (error) {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        if (this.isMethodNotAllowedException(error)) {",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "          const allowedMethods = this.getAllowedMethods(error);",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "          this.close(connection, 405, 'Method not allowed.', { Allow: allowedMethods });",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "          return null;",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "        if (this.isResourceNotFoundException(error)) {",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "          this.close(connection, 404, 'Not found.');",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "          return null;",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "        throw error;",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "      // Get the controller from the route",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "      const controller = this.controller(route);",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "      // Check if this is a WebSocket upgrade request",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "      if (this.isWebSocketRequest(request)) {",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "        const wsConnection = this.attemptUpgrade(request, connection);",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "        // Call the controller with websocket connection and route parameters",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "        const routeParams = this.extractRouteParams(route);",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "        return await controller(request, wsConnection, ...Object.values(routeParams));",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "      // For HTTP requests, resolve parameters and call controller",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "      const routeParameters = {",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "        ...this.extractRouteParams(route),",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "        request,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "        connection,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "      };",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "      const args = this.arguments(controller, routeParameters);",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "      const response = await controller(...args);",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "      // Send response and close connection",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "      return this.sendResponse(connection, response);",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      // Handle unexpected errors",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "      this.close(connection, 500, 'Internal server error.');",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "      throw error;",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the controller callable for the given route",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param route - The matched route object",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The controller function/callback",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 420,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10090290009975433
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Protocols/Pusher/server.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 61
                  },
                  "endPosition": {
                    "line": 330,
                    "column": 1
                  }
                },
                "contents": "import type { ILogger } from '../../contracts/logger';\nimport type { Frame, FrameOpcode } from '../../contracts/websocket-connection';\nimport type { PusherMessage } from '../../types/pusher-messages';\nimport { PusherErrorCode } from '../../types/pusher-messages';\nimport { ConnectionLimitExceeded } from './exceptions/connection-limit-exceeded';\nimport { InvalidOrigin } from './exceptions/invalid-origin';\nimport { PusherException } from './exceptions/pusher-exception';\nimport type { ChannelManager } from './Contracts/channel-manager';\nimport type { EventHandler } from './event-handler';\nimport type { ClientEvent } from './client-event';\nimport { MessageReceived } from '../../events/message-received';\n\n/**\n * Pusher Protocol Server\n *\n * Handles the WebSocket server lifecycle for the Pusher protocol, including:\n * - Connection establishment and authentication\n * - Message routing and validation\n * - Control frame handling (PING/PONG)\n * - Error handling and connection cleanup\n * - Origin verification and connection limits\n *\n * This class serves as the main entry point for Pusher protocol operations,\n * delegating specific functionality to EventHandler and ClientEvent handlers.\n *\n * @example\n * ```typescript\n * const server = new Server(channelManager, eventHandler, clientEvent, logger);\n *\n * // Handle new connection\n * server.open(connection);\n *\n * // Handle incoming message\n * server.message(connection, '{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"my-channel\"}}');\n *\n * // Handle control frame\n * server.control(connection, pingFrame);\n *\n * // Handle connection close\n * server.close(connection);\n * ```\n */\nexport class Server {\n  /**\n   * Create a new server instance.\n   *\n   * @param channels - The channel manager for managing channel subscriptions\n   * @param handler - The event handler for Pusher protocol events\n   * @param clientEvent - The client event handler for client-to-client messages\n   * @param logger - The logger instance for logging server operations\n   */\n  constructor(\n    protected readonly channels: ChannelManager,\n    protected readonly handler: EventHandler,\n    protected readonly clientEvent: ClientEvent,\n    protected readonly logger: ILogger\n  ) {}\n\n  /**\n   * Handle a client connection.\n   *\n   * Validates the connection against connection limits and origin restrictions,\n   * then sends a connection_established event to the client with the socket ID\n   * and activity timeout.\n   *\n   * If any errors occur during connection establishment, they are caught and\n   * passed to the error handler.\n   *\n   * @param connection - The connection to open\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ILogger } from '../../contracts/logger';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Frame, FrameOpcode } from '../../contracts/websocket-connection';",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { PusherMessage } from '../../types/pusher-messages';",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { PusherErrorCode } from '../../types/pusher-messages';",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import { ConnectionLimitExceeded } from './exceptions/connection-limit-exceeded';",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import { InvalidOrigin } from './exceptions/invalid-origin';",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "import { PusherException } from './exceptions/pusher-exception';",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from './Contracts/channel-manager';",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "import type { EventHandler } from './event-handler';",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ClientEvent } from './client-event';",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageReceived } from '../../events/message-received';",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * Pusher Protocol Server",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles the WebSocket server lifecycle for the Pusher protocol, including:",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection establishment and authentication",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * - Message routing and validation",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - Control frame handling (PING/PONG)",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - Error handling and connection cleanup",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * - Origin verification and connection limits",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * This class serves as the main entry point for Pusher protocol operations,",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * delegating specific functionality to EventHandler and ClientEvent handlers.",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * const server = new Server(channelManager, eventHandler, clientEvent, logger);",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * // Handle new connection",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " * server.open(connection);",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * // Handle incoming message",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * server.message(connection, '{\"event\":\"pusher:subscribe\",\"data\":{\"channel\":\"my-channel\"}}');",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * // Handle control frame",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " * server.control(connection, pingFrame);",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * // Handle connection close",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * server.close(connection);",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "export class Server {",
                    "lineNumber": 44,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new server instance.",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager for managing channel subscriptions",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param handler - The event handler for Pusher protocol events",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param clientEvent - The client event handler for client-to-client messages",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param logger - The logger instance for logging server operations",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly channels: ChannelManager,",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly handler: EventHandler,",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly clientEvent: ClientEvent,",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly logger: ILogger",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle a client connection.",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates the connection against connection limits and origin restrictions,",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   * then sends a connection_established event to the client with the socket ID",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   * and activity timeout.",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * If any errors occur during connection establishment, they are caught and",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   * passed to the error handler.",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection to open",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 331,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.0987946018576622
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/router.ts",
                "range": {
                  "startPosition": {
                    "line": 25,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 419,
                    "column": 1
                  }
                },
                "contents": "export class Router {\n\n\n  /**\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\n   *\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\n   * 2. Creates the upgrade response with required headers\n   * 3. Sends the response to the client\n   * 4. Wraps the raw connection in a ReverbConnection\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\n   *\n   * @param request - The HTTP request object\n   * @param connection - The raw socket connection\n   * @returns A new ReverbConnection instance for WebSocket communication\n   *\n   * @private\n   */\n  private attemptUpgrade(request: IHttpRequest, connection: Connection): any {\n    // Get the Sec-WebSocket-Key from the request\n    const secWebSocketKey = request.getHeader('sec-websocket-key');\n\n    if (!secWebSocketKey) {\n      this.close(connection, 400, 'Missing Sec-WebSocket-Key header.');\n      throw new Error('WebSocket upgrade failed: missing Sec-WebSocket-Key');\n    }\n\n    // Generate the accept key using RFC 6455 algorithm\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\n\n    // Build the upgrade response\n    const statusLine = 'HTTP/1.1 101 Switching Protocols\\r\\n';\n    const headers = [\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${acceptKey}`,\n      'X-Powered-By: Reverb',\n    ];\n\n    const responseHeaders = headers.join('\\r\\n') + '\\r\\n\\r\\n';\n    const upgradeResponse = statusLine + responseHeaders;\n\n    // Send the upgrade response\n    connection.send(upgradeResponse);\n\n    // Return the connection wrapped as a WebSocket connection\n    // In a real implementation, this would wrap the raw connection\n    // For now, return the connection as-is (the actual WebSocket upgrade\n    // would be handled by the underlying socket layer)\n    return connection;\n  }\n\n  /**\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\n   *\n   * The accept key is generated by:\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\n   * 2. Generating a SHA-1 hash of the concatenated string\n   * 3. Base64 encoding the hash\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\n   *\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\n   * @returns The Sec-WebSocket-Accept header value\n   *\n   * @private\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 26,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 26,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 26,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 27,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Router {",
                    "lineNumber": 26,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method implements the WebSocket opening handshake as defined in RFC 6455:",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Creates the upgrade response with required headers",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Sends the response to the client",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Wraps the raw connection in a ReverbConnection",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The raw socket connection",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns A new ReverbConnection instance for WebSocket communication",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  private attemptUpgrade(request: IHttpRequest, connection: Connection): any {",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get the Sec-WebSocket-Key from the request",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    const secWebSocketKey = request.getHeader('sec-websocket-key');",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!secWebSocketKey) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      this.close(connection, 400, 'Missing Sec-WebSocket-Key header.');",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error('WebSocket upgrade failed: missing Sec-WebSocket-Key');",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "    // Generate the accept key using RFC 6455 algorithm",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    const acceptKey = this.generateAcceptKey(secWebSocketKey);",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // Build the upgrade response",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    const statusLine = 'HTTP/1.1 101 Switching Protocols\\r\\n';",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "    const headers = [",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "      'Upgrade: websocket',",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "      'Connection: Upgrade',",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "      `Sec-WebSocket-Accept: ${acceptKey}`,",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "      'X-Powered-By: Reverb',",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "    ];",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "    const responseHeaders = headers.join('\\r\\n') + '\\r\\n\\r\\n';",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "    const upgradeResponse = statusLine + responseHeaders;",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "    // Send the upgrade response",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "    connection.send(upgradeResponse);",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "    // Return the connection wrapped as a WebSocket connection",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "    // In a real implementation, this would wrap the raw connection",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    // For now, return the connection as-is (the actual WebSocket upgrade",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "    // would be handled by the underlying socket layer)",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "    return connection;",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate the Sec-WebSocket-Accept header value (RFC 6455)",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "   * The accept key is generated by:",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Generating a SHA-1 hash of the concatenated string",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Base64 encoding the hash",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The Sec-WebSocket-Accept header value",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 420,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.0976608395576477
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/cli.ts",
                "range": {
                  "startPosition": {
                    "line": 120,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 255,
                    "column": 1
                  }
                },
                "contents": "async function startServer(options: Record<string, string | boolean>): Promise<void> {\n\n\n    // Create and start server\n    const server = Factory.make(\n      host,\n      port,\n      path,\n      hostname,\n      maxRequestSize,\n      serverOptions as { tls?: Record<string, unknown>; [key: string]: unknown },\n      'pusher',\n    );\n\n    // Setup periodic tasks (equivalent to Laravel's scheduled jobs)\n    setupPeriodicTasks();\n\n    // Setup graceful shutdown\n    setupGracefulShutdown(server);\n\n    // Check if TLS is actually configured (not just an empty object)\n    const hasTls = serverOptions.tls && (serverOptions.tls.cert || serverOptions.tls.key);\n    const scheme = hasTls ? 'wss' : 'ws';\n    const httpScheme = hasTls ? 'https' : 'http';\n\n    console.log('✅ Server started successfully');\n    console.log('');\n    console.log(`  WebSocket: ${scheme}://${hostname || host}:${port}${path}`);\n    console.log(`  HTTP API:  ${httpScheme}://${hostname || host}:${port}${path}`);\n    console.log('');\n    console.log('Press Ctrl+C to stop the server');\n    console.log('');\n\n    // Keep process alive\n    // Bun.serve() returns a server that keeps the process running\n\n  } catch (error) {\n    console.error('❌ Failed to start server:', error);\n    if (error instanceof Error) {\n      console.error(error.message);\n      if (options.debug) {\n        console.error(error.stack);\n      }\n    }\n    process.exit(1);\n  }\n}\n\n/**\n * Setup event listeners for observability and logging\n */\nfunction setupEventListeners(debug: boolean = false): void {\n  const logger = Factory.getLogger();\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 121,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 122,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "async function startServer(options: Record<string, string | boolean>): Promise<void> {",
                    "lineNumber": 121,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "    // Create and start server",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "    const server = Factory.make(",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "      host,",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "      port,",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "      path,",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "      hostname,",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "      maxRequestSize,",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "      serverOptions as { tls?: Record<string, unknown>; [key: string]: unknown },",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "      'pusher',",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "    // Setup periodic tasks (equivalent to Laravel's scheduled jobs)",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "    setupPeriodicTasks();",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "    // Setup graceful shutdown",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    setupGracefulShutdown(server);",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if TLS is actually configured (not just an empty object)",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "    const hasTls = serverOptions.tls && (serverOptions.tls.cert || serverOptions.tls.key);",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "    const scheme = hasTls ? 'wss' : 'ws';",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "    const httpScheme = hasTls ? 'https' : 'http';",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('✅ Server started successfully');",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`  WebSocket: ${scheme}://${hostname || host}:${port}${path}`);",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`  HTTP API:  ${httpScheme}://${hostname || host}:${port}${path}`);",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('Press Ctrl+C to stop the server');",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "    // Keep process alive",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "    // Bun.serve() returns a server that keeps the process running",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "  } catch (error) {",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "    console.error('❌ Failed to start server:', error);",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "    if (error instanceof Error) {",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "      console.error(error.message);",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "      if (options.debug) {",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "        console.error(error.stack);",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "    process.exit(1);",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 216,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": " * Setup event listeners for observability and logging",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": "function setupEventListeners(debug: boolean = false): void {",
                    "lineNumber": 221,
                    "isSignature": true
                  },
                  {
                    "text": "  const logger = Factory.getLogger();",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 256,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09329299628734589
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/certificate.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 144,
                    "column": 1
                  }
                },
                "contents": "/**\n * Certificate resolver for SSL/TLS certificates\n * Searches Laravel Herd and Valet certificate directories for SSL certificates\n *\n * @module certificate\n */\n\nimport { existsSync } from 'fs';\nimport { join, sep } from 'path';\nimport { homedir, platform } from 'os';\n\n/**\n * Certificate utility class for resolving SSL certificates\n * Provides static methods to locate and validate SSL certificate files\n */\nexport class Certificate {\n  /**\n   * Determine if a certificate exists for the given URL\n   *\n   * @param url - The URL to check for certificates\n   * @returns True if both certificate and key files exist\n   *\n   * @example\n   * ```typescript\n   * const hasSSL = Certificate.exists('https://myapp.test');\n   * // Returns true if myapp.test.crt and myapp.test.key exist\n   * ```\n   */\n  public static exists(url: string): boolean {\n    return this.resolve(url) !== null;\n  }\n\n  /**\n   * Resolve the certificate and key paths for the given URL\n   *\n   * Extracts the hostname from the URL and searches configured certificate\n   * directories for matching .crt and .key files\n   *\n   * @param url - The URL to resolve certificates for\n   * @returns Tuple of [certPath, keyPath] if found, null otherwise\n   *\n   * @example\n   * ```typescript\n   * const paths = Certificate.resolve('https://myapp.test');\n   * if (paths) {\n   *   const [certPath, keyPath] = paths;\n   *   console.log(`Cert: ${certPath}, Key: ${keyPath}`);\n   * }\n   * ```\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * Certificate resolver for SSL/TLS certificates",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " * Searches Laravel Herd and Valet certificate directories for SSL certificates",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * @module certificate",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "import { existsSync } from 'fs';",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "import { join, sep } from 'path';",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "import { homedir, platform } from 'os';",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * Certificate utility class for resolving SSL certificates",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides static methods to locate and validate SSL certificate files",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "export class Certificate {",
                    "lineNumber": 16,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "   * Determine if a certificate exists for the given URL",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param url - The URL to check for certificates",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns True if both certificate and key files exist",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * const hasSSL = Certificate.exists('https://myapp.test');",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Returns true if myapp.test.crt and myapp.test.key exist",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  public static exists(url: string): boolean {",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "    return this.resolve(url) !== null;",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   * Resolve the certificate and key paths for the given URL",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   * Extracts the hostname from the URL and searches configured certificate",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "   * directories for matching .crt and .key files",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param url - The URL to resolve certificates for",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Tuple of [certPath, keyPath] if found, null otherwise",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * const paths = Certificate.resolve('https://myapp.test');",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * if (paths) {",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   *   const [certPath, keyPath] = paths;",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   *   console.log(`Cert: ${certPath}, Key: ${keyPath}`);",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * }",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 145,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.0925540030002594
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/cli.ts",
                "range": {
                  "startPosition": {
                    "line": 115,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 215,
                    "column": 1
                  }
                },
                "contents": "/**\n * Start the WebSocket server\n */\nasync function startServer(options: Record<string, string | boolean>): Promise<void> {\n  try {\n    // Load configuration\n    const configPath = typeof options.config === 'string' ? options.config : undefined;\n    const config: ReverbConfig = await loadConfig(configPath);\n\n    // Get server configuration (use 'reverb' as default server name)\n    const serverName = config.default || 'reverb';\n    const serverConfig = config.servers[serverName];\n\n    if (!serverConfig) {\n      console.error(`❌ Server configuration not found for: ${serverName}`);\n      process.exit(1);\n    }\n\n    // Override with CLI options\n    const host = (typeof options.host === 'string' ? options.host : undefined) || serverConfig.host;\n    const port = (typeof options.port === 'string' ? options.port : undefined) || String(serverConfig.port);\n    const path = (typeof options.path === 'string' ? options.path : undefined) || serverConfig.path || '';\n    const hostname = (typeof options.hostname === 'string' ? options.hostname : undefined) || serverConfig.hostname;\n    const maxRequestSize = serverConfig.max_request_size || 10000;\n    const serverOptions = serverConfig.options || {};\n\n    // Log configuration\n    console.log('🚀 Starting Revurb WebSocket Server');\n    console.log('');\n    console.log('Configuration:');\n    console.log(`  Host:     ${host}`);\n    console.log(`  Port:     ${port}`);\n    if (path) {\n      console.log(`  Path:     ${path}`);\n    }\n    if (hostname && hostname !== host) {\n      console.log(`  Hostname: ${hostname}`);\n    }\n    console.log(`  Protocol: pusher`);\n    console.log('');\n\n    // Log applications\n    const apps = config.apps.apps || [];\n    console.log(`Applications: ${apps.length}`);\n    for (const app of apps) {\n      console.log(`  - ${app.app_id} (key: ${app.key})`);\n    }\n    console.log('');\n\n    // Initialize factory with configuration\n    Factory.initialize(config);\n\n    // Setup event listeners for observability\n    setupEventListeners(options.debug === true);\n\n    // Create and start server\n    const server = Factory.make\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": " * Start the WebSocket server",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "async function startServer(options: Record<string, string | boolean>): Promise<void> {",
                    "lineNumber": 121,
                    "isSignature": true
                  },
                  {
                    "text": "  try {",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "    // Load configuration",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "    const configPath = typeof options.config === 'string' ? options.config : undefined;",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    const config: ReverbConfig = await loadConfig(configPath);",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get server configuration (use 'reverb' as default server name)",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const serverName = config.default || 'reverb';",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "    const serverConfig = config.servers[serverName];",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!serverConfig) {",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      console.error(`❌ Server configuration not found for: ${serverName}`);",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "      process.exit(1);",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "    // Override with CLI options",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "    const host = (typeof options.host === 'string' ? options.host : undefined) || serverConfig.host;",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "    const port = (typeof options.port === 'string' ? options.port : undefined) || String(serverConfig.port);",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "    const path = (typeof options.path === 'string' ? options.path : undefined) || serverConfig.path || '';",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "    const hostname = (typeof options.hostname === 'string' ? options.hostname : undefined) || serverConfig.hostname;",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "    const maxRequestSize = serverConfig.max_request_size || 10000;",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "    const serverOptions = serverConfig.options || {};",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "    // Log configuration",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('🚀 Starting Revurb WebSocket Server');",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('Configuration:');",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`  Host:     ${host}`);",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`  Port:     ${port}`);",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "    if (path) {",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "      console.log(`  Path:     ${path}`);",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "    if (hostname && hostname !== host) {",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "      console.log(`  Hostname: ${hostname}`);",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`  Protocol: pusher`);",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "    // Log applications",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    const apps = config.apps.apps || [];",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log(`Applications: ${apps.length}`);",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const app of apps) {",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "      console.log(`  - ${app.app_id} (key: ${app.key})`);",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "    console.log('');",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "    // Initialize factory with configuration",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "    Factory.initialize(config);",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "    // Setup event listeners for observability",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    setupEventListeners(options.debug === true);",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "    // Create and start server",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "    const server = Factory.make",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 216,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09199053049087524
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 19,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 256,
                    "column": 1
                  }
                },
                "contents": "export class Connection implements IWebSocketConnection {\n\n\n  /**\n   * Handle incoming messages.\n   * Processes fragmented messages and dispatches complete messages to handlers.\n   *\n   * @param data - The message data received from the WebSocket\n   */\n  // @ts-expect-error - Reserved for future use\n  private _handleMessage(data: string | Buffer): void {\n    // Check message size if limit is set\n    if (this.maxMessageSize && data.length > this.maxMessageSize) {\n      console.warn(\n        `Message exceeds maximum size (${data.length} > ${this.maxMessageSize}) on connection ${this.connectionId}`\n      );\n      this.close(\"Message size exceeded\");\n      return;\n    }\n\n    // In Bun's WebSocket, fragmentation is handled automatically\n    // This is a simplified implementation that assumes complete messages\n    if (this.onMessageHandler) {\n      this.onMessageHandler(data);\n    }\n  }\n\n  /**\n   * Get the unique connection identifier.\n   *\n   * @returns The connection ID\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 20,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 20,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 20,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 21,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Connection implements IWebSocketConnection {",
                    "lineNumber": 20,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle incoming messages.",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * Processes fragmented messages and dispatches complete messages to handlers.",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param data - The message data received from the WebSocket",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "  // @ts-expect-error - Reserved for future use",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "  private _handleMessage(data: string | Buffer): void {",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check message size if limit is set",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.maxMessageSize && data.length > this.maxMessageSize) {",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "      console.warn(",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "        `Message exceeds maximum size (${data.length} > ${this.maxMessageSize}) on connection ${this.connectionId}`",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "      this.close(\"Message size exceeded\");",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "      return;",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    // In Bun's WebSocket, fragmentation is handled automatically",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "    // This is a simplified implementation that assumes complete messages",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.onMessageHandler) {",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "      this.onMessageHandler(data);",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the unique connection identifier.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The connection ID",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 257,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09144440293312073
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "revurb-ts/src/Servers/Reverb/Http/router.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 419,
                    "column": 1
                  }
                },
                "contents": "import { createHash } from 'crypto';\nimport type { Connection } from '../../../connection';\n\n/**\n * HTTP Router for request dispatch and WebSocket upgrade handling\n *\n * The Router class handles:\n * - Request routing and dispatch to controllers\n * - WebSocket upgrade detection and handshake (RFC 6455)\n * - Controller parameter resolution\n * - HTTP error handling (404, 405, 500)\n *\n * Key Features:\n * - dispatch() method matches request to route and calls controller\n * - WebSocket upgrade detection via \"Upgrade: websocket\" header\n * - RFC 6455 WebSocket handshake negotiation with proper key generation\n * - Controller parameter resolution from route and request context\n * - Graceful HTTP error responses (404, 405, 500)\n *\n * @example\n * ```typescript\n * const router = new Router(routeMatcher);\n * const result = await router.dispatch(request, connection);\n * ```\n */\nexport class Router {\n  /**\n   * WebSocket upgrade magic GUID as defined in RFC 6455\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3\n   */\n  private static readonly WS_GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n\n  /**\n   * Create a new Router instance\n   *\n   * @param matcher - The route matcher instance (implements IRouteMatcher)\n   */\n  constructor(private matcher: IRouteMatcher) {}\n\n  /**\n   * Dispatch the HTTP request to the appropriate controller\n   *\n   * This method:\n   * 1. Matches the request URI to a route\n   * 2. Extracts the controller and route parameters\n   * 3. Handles WebSocket upgrades if requested\n   * 4. Resolves controller parameters from route and request context\n   * 5. Calls the controller with appropriate arguments\n   * 6. Handles HTTP errors (404, 405, 500)\n   *\n   * @param request - The HTTP request object\n   * @param connection - The connection object\n   * @returns The controller response (Promise, string, or any result)\n   *\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import { createHash } from 'crypto';",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from '../../../connection';",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Router for request dispatch and WebSocket upgrade handling",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * The Router class handles:",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * - Request routing and dispatch to controllers",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * - WebSocket upgrade detection and handshake (RFC 6455)",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * - Controller parameter resolution",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * - HTTP error handling (404, 405, 500)",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Features:",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - dispatch() method matches request to route and calls controller",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - WebSocket upgrade detection via \"Upgrade: websocket\" header",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - RFC 6455 WebSocket handshake negotiation with proper key generation",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - Controller parameter resolution from route and request context",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - Graceful HTTP error responses (404, 405, 500)",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * const router = new Router(routeMatcher);",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * const result = await router.dispatch(request, connection);",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "export class Router {",
                    "lineNumber": 26,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   * WebSocket upgrade magic GUID as defined in RFC 6455",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  private static readonly WS_GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new Router instance",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param matcher - The route matcher instance (implements IRouteMatcher)",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private matcher: IRouteMatcher) {}",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   * Dispatch the HTTP request to the appropriate controller",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Matches the request URI to a route",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Extracts the controller and route parameters",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Handles WebSocket upgrades if requested",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Resolves controller parameters from route and request context",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Calls the controller with appropriate arguments",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * 6. Handles HTTP errors (404, 405, 500)",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection object",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The controller response (Promise, string, or any result)",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Will close connection with appropriate HTTP error code if route matching fails",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 420,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.08852379769086838
            }
          ]
        }
      }
    }

### Assistant

Searching for TODO comments:

### Tool · grep (started)

    {
      "args": {
        "pattern": "TODO|FIXME|XXX|HACK",
        "path": "./revurb-ts/src",
        "caseInsensitive": true,
        "multiline": false,
        "toolCallId": "tool_96684563-9e17-40b7-b028-ad089522b74"
      }
    }

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb/revurb-ts && bun test 2>&1 | head -50`
    * **cwd:** `.`
    * **status:** pending

### Tool · grep (completed)

    {
      "args": {
        "pattern": "TODO|FIXME|XXX|HACK",
        "path": "./revurb-ts/src",
        "caseInsensitive": true,
        "multiline": false,
        "toolCallId": "tool_96684563-9e17-40b7-b028-ad089522b74"
      },
      "result": {
        "success": {
          "pattern": "TODO|FIXME|XXX|HACK",
          "path": "./revurb-ts/src",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb/revurb-ts && bun test 2>&1 | head -50`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    bun test v1.3.2 (b131639c)
    
    tests/feature/health-check-controller.test.ts:
    (pass) Health Check Controller > can respond to a health check request [2.02ms]
    (pass) Health Check Controller > health check does not require app ID [0.26ms]
    
    tests/e2e/websocket-connection.test.ts:
      Connection Established ................................. 299767285.734145465
    (pass) WebSocket Connection E2E Tests > should accept WebSocket connection [1.14ms]
      Connection Closed ...................................... 299767285.734145465
      Connection Established ................................. 533309003.739969078
    (pass) WebSocket Connection E2E Tests > should receive connection_established message [0.54ms]
      Connection Closed ...................................... 533309003.739969078
    Error finding application: 75 |    */
    76 |   find(key: string, value: any): Application {
    77 |     const app = this.applications.find((app) => app[key as keyof ApplicationConfig] === value);
    78 | 
    79 |     if (!app) {
    80 |       throw new InvalidApplication();
                     ^
    InvalidApplication: Application does not exist
          at find (/Users/tom/personal/revurb/revurb-ts/src/config-application-provider.ts:80:13)
          at handleWebSocketConnection (/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/factory.ts:665:22)
          at handleRequest (/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/factory.ts:526:42)
          at handleRequest (/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/factory.ts:511:38)
          at fetch (/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/factory.ts:378:89)
    
    (pass) WebSocket Connection E2E Tests > should reject connection with invalid app key [0.50ms]
      Connection Established ................................. 346435057.210455463
      Message Received ....................................... 346435057.210455463
    
      ┌────────────────────────────────────────────────────────────────────────────┐
      │ {                                                                          │
      │   "event": "pusher:ping",                                │
      │   "data": {}                                                      │
      │ }                                                                          │
      └────────────────────────────────────────────────────────────────────────────┘
    
      Message Handled ........................................ 346435057.210455463
    (pass) WebSocket Connection E2E Tests > should handle ping/pong [0.63ms]
    
    tests/e2e/private-channel.test.ts:
      Connection Closed ...................................... 346435057.210455463
      Connection Established ................................. 146431856.848707756
    Connected to WebSocket
    Received: pusher:connection_established
    Socket ID: 146431856.848707756
    Generated auth: private-test-key:8b3b3f641c6de75b5727428593f3fbebd4f0809e79f9eaadabdfe70ec4f6b4a4
      Message Received ....................................... 146431856.848707756

### Assistant

Checking the full test results:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb/revurb-ts && bun test 2>&1 | tail -20`
    * **cwd:** `.`
    * **status:** pending

### Tool · read (started)

    * **path:** `revurb-ts/agent/CURRENT_SESSION.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `revurb-ts/agent/CURRENT_SESSION.md`
    * **status:** success
        * lines: 1-67
    * **content:**

    # Porting Session: 2025-11-12 Late Afternoon
    
    ## Session Accomplishments ✅
    
    ### Major WebSocket Fixes
    1. **Fixed WebSocket Upgrade Handler**
       - Removed incorrect `Sec-WebSocket-Protocol` header that was breaking upgrades
       - Changed return value from `Response(null, 101)` to `undefined` for successful upgrades
       - Updated `handleRequest` return type to `Promise<Response | undefined>`
    
    2. **Fixed Server-Side WebSocket Connection Handler**
       - Removed attempt to override event handlers on server-side WebSocket (Bun handles this)
       - Server-side WebSockets in Bun.serve use global handlers, not per-socket handlers
    
    3. **Fixed Channel Management**
       - Added proper application scoping in `EventHandler.subscribe()`
       - Added proper application scoping in `EventHandler.unsubscribe()`
       - Channels must be accessed via `channels.for(app)` before operations
    
    ### E2E Tests Written ✅
    All tests passing (8/8):
    
    **WebSocket Connection Tests (5 tests)**
    - Connection establishment with valid app key
    - Receiving connection_established message
    - Rejection of invalid app keys
    - Ping/pong protocol messages
    
    **Channel Subscription Tests (3 tests)**
    - Public channel subscription with subscription_succeeded
    - Ping/pong message handling
    - Channel unsubscription
    
    ## Current Status
    
    ### Working Features ✅
    1. WebSocket server with Bun.serve integration
    2. Pusher protocol handshake (connection_established)
    3. Public channel subscriptions
    4. Ping/pong keepalive
    5. Channel unsubscription
    6. Application validation and origin checking
    7. HTTP health check endpoint
    
    ### What's Still Needed
    1. HTTP API endpoint testing (events triggering)
    2. Unit tests for Router, Config, Connection (20% time allocation)
    3. Private/presence channel authentication tests
    4. Redis pub/sub integration (optional for multi-server)
    
    ## Commits Made
    1. `test: add E2E WebSocket connection tests (WIP - needs fixes)`
    2. `fix: correct WebSocket upgrade handler to allow proper connection establishment`
    3. `feat: add E2E tests for channel subscription and fix channel scoping`
    
    ## Key Learnings
    - Bun's WebSocket upgrade requires returning `undefined`, not a 101 Response
    - Server-side WebSocket handlers are global in Bun, not per-socket
    - Channel managers must be scoped to an application before operations
    - Testing revealed critical bugs that would have been hard to spot in code review
    
    ## Notes
    - Following 80/20 rule: 80% porting, 20% testing ✅
    - Making frequent commits per instructions ✅
    - All TypeScript compilation errors: 0 ✅
    - E2E test coverage: Working WebSocket + Channel functionality ✅

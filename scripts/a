#!/usr/bin/env bun

import { spawn } from "bun";
import path from "node:path";
import { marked } from "marked";
import TerminalRenderer from "marked-terminal";

const useColor =
  typeof process !== "undefined" &&
  Boolean(process.stdout?.isTTY) &&
  !("NO_COLOR" in process.env);

function applyStyle(text: string, codes: number[]): string {
  if (!useColor || !codes.length) {
    return text;
  }
  const open = codes.map((code) => `\x1b[${code}m`).join("");
  return `${open}${text}\x1b[0m`;
}

function formatError(text: string): string {
  return applyStyle(text, [1, 31]);
}

const useMarkdown = process.env.A_MARKDOWN !== "0";

const terminalRenderer = new TerminalRenderer();

const defaultMaxLines = Number.parseInt(
  process.env.A_MAX_SECTION_LINES ?? "",
  10,
);
const defaultMaxChars = Number.parseInt(
  process.env.A_MAX_SECTION_CHARS ?? "",
  10,
);
const MAX_SECTION_LINES = Number.isFinite(defaultMaxLines)
  ? defaultMaxLines
  : 200;
const MAX_SECTION_CHARS = Number.isFinite(defaultMaxChars)
  ? defaultMaxChars
  : 8_000;

await main();

async function main(): Promise<void> {
  const args = Bun.argv.slice(2);
  if (args.length === 0) {
    printUsage();
    process.exitCode = 1;
    return;
  }

  if (args.length === 1 && (args[0] === "--help" || args[0] === "-h")) {
    printUsage();
    return;
  }

  const cursorFlags: string[] = [];
  let promptParts: string[] = [];

  const valueFlags = new Set(["--api-key", "--output-format", "--model", "-m"]);

  const separatorIndex = args.indexOf("--");
  if (separatorIndex !== -1) {
    cursorFlags.push(...args.slice(0, separatorIndex));
    promptParts = args.slice(separatorIndex + 1);
  } else {
    let i = 0;
    while (i < args.length) {
      const token = args[i];
      if (token === undefined) {
        break;
      }
      if (token === "--") {
        promptParts = args.slice(i + 1);
        break;
      }
      if (token.startsWith("-") && promptParts.length === 0) {
        cursorFlags.push(token);

        const flagName = token.includes("=")
          ? token.slice(0, token.indexOf("="))
          : token;

        if (
          !token.includes("=") &&
          valueFlags.has(flagName) &&
          i + 1 < args.length
        ) {
          const nextToken = args[i + 1];
          if (typeof nextToken === "string" && !nextToken.startsWith("-")) {
            cursorFlags.push(nextToken);
            i += 1;
          }
        }
        i += 1;
        continue;
      }
      promptParts = args.slice(i);
      break;
    }
  }

  if (!promptParts.length) {
    printUsage();
    process.exitCode = 1;
    return;
  }

  for (let i = 0; i < cursorFlags.length; i += 1) {
    const flag = cursorFlags[i];
    if (typeof flag !== "string") {
      continue;
    }
    if (flag === "-m") {
      cursorFlags[i] = "--model";
    } else if (flag.startsWith("-m=")) {
      cursorFlags[i] = flag.replace(/^-m=/, "--model=");
    }
  }

  const hasModelFlag = cursorFlags.some((flag) => {
    if (typeof flag !== "string") {
      return false;
    }
    return flag === "--model" || flag.startsWith("--model=");
  });

  if (!hasModelFlag) {
    cursorFlags.push("--model");
    cursorFlags.push("composer-1");
  }

  const prompt = promptParts.join(" ").trim();
  if (!prompt) {
    printUsage();
    process.exitCode = 1;
    return;
  }

  let child;
  try {
    child = spawn(
      [
        "cursor-agent",
        ...cursorFlags,
        "--print",
        prompt,
        "--output-format",
        "stream-json",
      ],
      {
        stdout: "pipe",
        stderr: "pipe",
      },
    );
  } catch (error) {
    console.error(
      formatError(
        `Unable to start cursor-agent: ${
          error instanceof Error ? error.message : String(error)
        }`,
      ),
    );
    process.exitCode = 1;
    return;
  }

  let sessionCwd: string | undefined;
  const stdoutDecoder = new TextDecoder();
  const stderrDecoder = new TextDecoder();
  let stdoutBuffer = "";
  let stderrBuffer = "";

  let hasPrintedSection = false;
  let thinkingActive = false;
  let thinkingColumn = 0;

  const stdoutTask = (async () => {
    for await (const chunk of child.stdout) {
      stdoutBuffer += stdoutDecoder.decode(chunk, { stream: true });
      stdoutBuffer = drainLines(stdoutBuffer, processLine);
    }
    stdoutBuffer += stdoutDecoder.decode(new Uint8Array(), { stream: false });
    if (stdoutBuffer.trim()) {
      processLine(stdoutBuffer);
    }
  })();

  const stderrTask = (async () => {
    for await (const chunk of child.stderr) {
      const text = stderrDecoder.decode(chunk, { stream: true });
      if (text) {
        stderrBuffer += text;
      }
    }
    stderrBuffer += stderrDecoder.decode(new Uint8Array(), { stream: false });
  })();

  const exitCode = await child.exited;
  await stdoutTask;
  await stderrTask;

  finishThinking();

  if (stderrBuffer.trim()) {
    writeSection(formatStderr(stderrBuffer.trimEnd()));
  }

  if (exitCode !== 0) {
    process.exitCode = exitCode ?? 1;
  }

  function processLine(rawLine: string) {
    const cleanLine = rawLine.replace(/\r$/, "");
    const trimmed = cleanLine.trim();
    if (!trimmed || trimmed.startsWith("Total output lines:")) {
      return;
    }

    let parsed: unknown;
    try {
      parsed = JSON.parse(trimmed);
    } catch {
      writeSection(formatRaw({ raw: trimmed }));
      return;
    }

    if (
      parsed &&
      typeof parsed === "object" &&
      !("type" in parsed) &&
      "output" in parsed &&
      typeof (parsed as { output: unknown }).output === "string"
    ) {
      const nested = (parsed as { output: string }).output.split("\n");
      nested.forEach((line) => processLine(line));
      return;
    }

    if (!parsed || typeof parsed !== "object" || !("type" in parsed)) {
      writeSection(formatRaw(parsed));
      return;
    }

    const event = parsed as Record<string, unknown>;
    const type = event.type;

    if (type !== "thinking") {
      finishThinking();
    }

    switch (type) {
      case "system":
        sessionCwd = typeof event.cwd === "string" ? event.cwd : sessionCwd;
        writeSection(formatSystem(event));
        break;
      case "user":
        writeSection(formatMessage("User", extractMessageText(event.message)));
        break;
      case "assistant":
        writeSection(
          formatMessage("Assistant", extractMessageText(event.message)),
        );
        break;
      case "thinking":
        handleThinking(event);
        break;
      case "tool_call":
        writeSection(formatTool(event, sessionCwd));
        break;
      case "result":
        writeSection(formatResultEvent(event));
        break;
      default:
        writeSection(formatRaw(event));
        break;
    }
  }

  function writeSection(markdown: string): void {
    const trimmed = markdown.trim();
    if (!trimmed) {
      return;
    }
    if (thinkingActive) {
      finishThinking();
    }
    if (hasPrintedSection) {
      process.stdout.write("\n");
    }
    if (useMarkdown) {
      const rendered = renderMarkdownString(trimmed);
      if (rendered.trim()) {
        process.stdout.write(rendered.replace(/\s+$/, ""));
        process.stdout.write("\n");
      }
    } else {
      process.stdout.write(trimmed);
      process.stdout.write("\n");
    }
    hasPrintedSection = true;
  }

  function renderMarkdownString(markdown: string): string {
    const rendered = marked.parse(markdown, {
      async: false,
      renderer: terminalRenderer as unknown as any,
    });
    return typeof rendered === "string" ? rendered : String(rendered);
  }

  function handleThinking(event: Record<string, unknown>): void {
    const subtype = typeof event.subtype === "string" ? event.subtype : "";
    if (subtype === "delta" && typeof event.text === "string" && event.text) {
      appendThinking(event.text);
    } else if (subtype === "completed") {
      finishThinking();
    }
  }

  function startThinking(): void {
    if (thinkingActive) {
      return;
    }
    if (hasPrintedSection) {
      process.stdout.write("\n");
    }
    if (useMarkdown) {
      const heading = renderMarkdownString("### Thought");
      process.stdout.write(heading.replace(/\s+$/, ""));
      process.stdout.write("\n\n");
    } else {
      process.stdout.write("Thought\n\n");
    }
    hasPrintedSection = true;
    thinkingActive = true;
    thinkingColumn = 0;
  }

  function appendThinking(text: string): void {
    if (!text) {
      return;
    }
    startThinking();
    const normalized = text.replace(/\r/g, "");
    const indent = "  ";
    const segments = normalized.split("\n");
    segments.forEach((segment, index) => {
      if (segment.length > 0) {
        if (thinkingColumn === 0) {
          process.stdout.write(indent);
        }
        process.stdout.write(segment);
        thinkingColumn += segment.length;
      }
      if (index < segments.length - 1) {
        process.stdout.write("\n");
        thinkingColumn = 0;
      }
    });
  }

  function finishThinking(): void {
    if (!thinkingActive) {
      return;
    }
    if (thinkingColumn !== 0) {
      process.stdout.write("\n");
    }
    thinkingActive = false;
    thinkingColumn = 0;
  }

  function formatSystem(event: Record<string, unknown>): string {
    const lines: string[] = ["### System"];
    const entries: string[] = [];
    if (typeof event.model === "string") {
      entries.push(`- **model:** ${event.model}`);
    }
    if (typeof event.cwd === "string") {
      entries.push(`- **cwd:** ${describePath(event.cwd, event.cwd)}`);
    }
    if (typeof event.permissionMode === "string") {
      entries.push(`- **permission:** ${event.permissionMode}`);
    }
    if (typeof event.apiKeySource === "string") {
      entries.push(`- **api key:** ${event.apiKeySource}`);
    }
    if (entries.length) {
      lines.push("", ...entries);
    }
    return lines.join("\n");
  }

  function formatMessage(title: string, text: string): string {
    const lines: string[] = [`### ${title}`];
    const trimmed = text.trim();
    if (!trimmed) {
      lines.push("", "_(empty)_");
      return lines.join("\n");
    }
    const result = truncateMultiline(trimmed);
    lines.push("", result.text);
    if (result.truncated) {
      lines.push("", truncationSummary(result));
    }
    return lines.join("\n");
  }

  function formatTool(
    event: Record<string, unknown>,
    baseCwd: string | undefined,
  ): string {
    const toolCall = event.tool_call as Record<string, unknown> | undefined;
    if (!toolCall) {
      return formatRaw(event);
    }
    const [toolKey] = Object.keys(toolCall);
    const payload =
      toolKey && typeof toolKey === "string"
        ? (toolCall[toolKey] as Record<string, unknown>)
        : undefined;

    const prettyName = toolKey
      ? toolKey.replace(/ToolCall$/, "").replace(/([a-z])([A-Z])/g, "$1 $2")
      : "tool";

    const subtypeLabel =
      typeof event.subtype === "string" && event.subtype.length > 0
        ? ` (${event.subtype})`
        : "";

    const lines: string[] = [`### Tool · ${prettyName}${subtypeLabel}`];

    if (!payload) {
      lines.push("", codeFence(JSON.stringify(toolCall, null, 2), "json"));
      return lines.join("\n");
    }

    switch (toolKey) {
      case "shellToolCall":
        lines.push("", ...formatShellTool(payload, baseCwd));
        break;
      case "readToolCall":
        lines.push("", ...formatReadTool(payload, baseCwd));
        break;
      case "lsToolCall":
        lines.push("", ...formatLsTool(payload, baseCwd));
        break;
      default:
        lines.push("", codeFence(JSON.stringify(payload, null, 2), "json"));
        break;
    }

    return lines.join("\n");
  }

  function formatShellTool(
    payload: Record<string, unknown>,
    baseCwd: string | undefined,
  ): string[] {
    const lines: string[] = [];
    const args = (payload.args ?? {}) as Record<string, unknown>;
    const command = typeof args.command === "string"
      ? args.command
      : Array.isArray(args.simpleCommands)
      ? args.simpleCommands.join(" ")
      : undefined;

    if (command) {
      lines.push(`- **command:** ${inlineCode(command)}`);
    }

    if (typeof args.workingDirectory === "string") {
      lines.push(
        `- **cwd:** ${inlineCode(describePath(args.workingDirectory, baseCwd))}`,
      );
    }

    const result = payload.result as Record<string, unknown> | undefined;
    if (!result) {
      lines.push("- **status:** pending");
      return lines;
    }

    if ("success" in result) {
      const success = result.success as Record<string, unknown>;
      lines.push("- **status:** success");
      if (typeof success.exitCode === "number") {
        lines.push(`  - exit: ${success.exitCode}`);
      }
      const stdoutText = toText(success.stdout).trimEnd();
      if (stdoutText) {
        lines.push(blockWithLabel("stdout", stdoutText, { language: "bash" }));
      }
      const stderrText = toText(success.stderr).trimEnd();
      if (stderrText) {
        lines.push(blockWithLabel("stderr", stderrText, { language: "bash" }));
      }
    } else if ("rejected" in result) {
      const rejected = result.rejected as Record<string, unknown>;
      lines.push("- **status:** rejected");
      const reason =
        typeof rejected.reason === "string" && rejected.reason.trim()
          ? rejected.reason
          : "no reason provided";
      lines.push(`  - reason: ${reason}`);
    } else if ("failed" in result) {
      const failure = result.failed as Record<string, unknown>;
      lines.push("- **status:** failed");
      const reason =
        typeof failure.reason === "string"
          ? failure.reason
          : typeof failure.error === "string"
          ? failure.error
          : undefined;
      if (reason) {
        lines.push(`  - reason: ${reason}`);
      }
      const stdoutText = toText(failure.stdout).trimEnd();
      if (stdoutText) {
        lines.push(blockWithLabel("stdout", stdoutText, { language: "bash" }));
      }
      const stderrText = toText(failure.stderr).trimEnd();
      if (stderrText) {
        lines.push(blockWithLabel("stderr", stderrText, { language: "bash" }));
      }
    } else {
      const statusKey = Object.keys(result)[0];
      if (statusKey) {
        lines.push(`- **status:** ${statusKey}`);
        const value = result[statusKey];
        if (value && typeof value === "object") {
          lines.push(
            blockWithLabel(
              "details",
              JSON.stringify(value, null, 2),
              { language: "json" },
            ),
          );
        } else if (typeof value === "string") {
          lines.push(`  - ${value}`);
        }
      }
    }

    return lines;
  }

  function formatReadTool(
    payload: Record<string, unknown>,
    baseCwd: string | undefined,
  ): string[] {
    const lines: string[] = [];
    const args = (payload.args ?? {}) as Record<string, unknown>;

    if (typeof args.path === "string") {
      lines.push(
        `- **path:** ${inlineCode(describePath(args.path, baseCwd))}`,
      );
    }

    const result = payload.result as Record<string, unknown> | undefined;
    if (!result) {
      lines.push("- **status:** pending");
      return lines;
    }

    if ("success" in result) {
      const success = result.success as Record<string, unknown>;
      lines.push("- **status:** success");
      const range = success.readRange as
        | { startLine?: number; endLine?: number }
        | undefined;
      if (range && typeof range.startLine === "number") {
        const end =
          typeof range.endLine === "number" ? range.endLine : range.startLine;
        lines.push(`  - lines: ${range.startLine}-${end}`);
      }
      if (typeof success.content === "string") {
        lines.push(
          blockWithLabel("content", success.content.trimEnd(), {
            language: guessLanguageFromPath(
              typeof args.path === "string" ? args.path : "",
            ),
          }),
        );
      }
    } else {
      const key = Object.keys(result)[0];
      if (key) {
        lines.push(`- **status:** ${key}`);
        const value = result[key];
        if (typeof value === "string") {
          lines.push(`  - ${value}`);
        } else if (value) {
          lines.push(
            blockWithLabel(
              "details",
              JSON.stringify(value, null, 2),
              { language: "json" },
            ),
          );
        }
      }
    }

    return lines;
  }

  function formatLsTool(
    payload: Record<string, unknown>,
    baseCwd: string | undefined,
  ): string[] {
    const lines: string[] = [];
    const args = (payload.args ?? {}) as Record<string, unknown>;

    if (typeof args.path === "string") {
      lines.push(
        `- **path:** ${inlineCode(describePath(args.path, baseCwd))}`,
      );
    }

    const result = payload.result as Record<string, unknown> | undefined;
    if (!result) {
      lines.push("- **status:** pending");
      return lines;
    }

    if ("success" in result) {
      const success = result.success as Record<string, unknown>;
      lines.push("- **status:** success");
      const root = success.directoryTreeRoot as Record<string, unknown> | undefined;
      if (root) {
        const treeText = renderDirectoryTree(root).join("\n");
        lines.push(blockWithLabel("entries", treeText, { language: "" }));
      }
    } else {
      const key = Object.keys(result)[0];
      if (key) {
        lines.push(`- **status:** ${key}`);
        const value = result[key];
        if (typeof value === "string") {
          lines.push(`  - ${value}`);
        } else if (value) {
          lines.push(
            blockWithLabel(
              "details",
              JSON.stringify(value, null, 2),
              { language: "json" },
            ),
          );
        }
      }
    }

    return lines;
  }

  function renderDirectoryTree(
    node: Record<string, unknown>,
    indentLevel = 0,
  ): string[] {
    const lines: string[] = [];
    const indent = "  ".repeat(indentLevel);
    const fileEntries = Array.isArray(node.childrenFiles)
      ? (node.childrenFiles as Array<{ name?: string }>)
      : [];
    const dirEntries = Array.isArray(node.childrenDirs)
      ? (node.childrenDirs as Array<Record<string, unknown>>)
      : [];

    for (const file of fileEntries) {
      if (file && typeof file.name === "string") {
        lines.push(`${indent}${file.name}`);
      }
    }

    for (const dir of dirEntries) {
      const dirName =
        typeof dir.absPath === "string"
          ? `${path.basename(dir.absPath)}/`
          : typeof dir.name === "string"
          ? `${dir.name}/`
          : "unknown/";
      lines.push(`${indent}${dirName}`);
      if (dir.childrenWereProcessed) {
        lines.push(...renderDirectoryTree(dir, indentLevel + 1));
      } else {
        lines.push(`${indent}  (not expanded)`);
      }
    }

    return lines;
  }

  function formatResultEvent(event: Record<string, unknown>): string {
    const isError = Boolean(event.is_error);
    const lines: string[] = [
      `### ${isError ? "Result (error)" : "Result"}`,
    ];
    if (typeof event.result === "string" && event.result.trim()) {
      const result = truncateMultiline(event.result.trim());
      lines.push("", result.text);
      if (result.truncated) {
        lines.push("", truncationSummary(result));
      }
    }
    const meta: string[] = [];
    if (typeof event.duration_ms === "number") {
      meta.push(`- **duration:** ${event.duration_ms} ms`);
    }
    if (
      typeof event.duration_api_ms === "number" &&
      event.duration_api_ms !== event.duration_ms
    ) {
      meta.push(`- **api duration:** ${event.duration_api_ms} ms`);
    }
    if (meta.length) {
      lines.push("", ...meta);
    }
    return lines.join("\n");
  }

  function formatStderr(text: string): string {
    const truncated = truncateMultiline(text);
    const lines = ["### stderr", "", codeFence(truncated.text, "bash")];
    if (truncated.truncated) {
      lines.push("", truncationSummary(truncated));
    }
    return lines.join("\n");
  }

  function formatRaw(event: unknown): string {
    const json = JSON.stringify(event, null, 2);
    const truncated = truncateMultiline(json);
    const lines = ["### Event", "", codeFence(truncated.text, "json")];
    if (truncated.truncated) {
      lines.push("", truncationSummary(truncated));
    }
    return lines.join("\n");
  }

  function truncateMultiline(
    text: string,
    limits: { maxLines?: number; maxChars?: number } = {},
  ): {
    text: string;
    truncated: boolean;
    linesOmitted: number;
    charsOmitted: number;
  } {
    const maxLines = limits.maxLines ?? MAX_SECTION_LINES;
    const maxChars = limits.maxChars ?? MAX_SECTION_CHARS;
    const normalized = text.replace(/\r/g, "");
    const allLines = normalized.split("\n");
    let truncatedText = normalized;
    let truncated = false;
    let linesOmitted = 0;
    let charsOmitted = 0;

    if (allLines.length > maxLines) {
      truncated = true;
      linesOmitted = allLines.length - maxLines;
      truncatedText = allLines.slice(0, maxLines).join("\n");
    }

    if (truncatedText.length > maxChars) {
      truncated = true;
      const sliced = truncatedText.slice(0, maxChars);
      charsOmitted = truncatedText.length - sliced.length;
      truncatedText = sliced;
    }

    return { text: truncatedText, truncated, linesOmitted, charsOmitted };
  }

  function truncationSummary(info: {
    linesOmitted: number;
    charsOmitted: number;
  }): string {
    const parts: string[] = [];
    if (info.linesOmitted > 0) {
      parts.push(`${info.linesOmitted} lines`);
    }
    if (info.charsOmitted > 0) {
      parts.push(`${info.charsOmitted} chars`);
    }
    const detail = parts.length ? ` (${parts.join(", ")} omitted)` : "";
    return `_… truncated${detail}_`;
  }

  function inlineCode(value: string): string {
    return "`" + escapeBackticks(value) + "`";
  }

  function escapeBackticks(value: string): string {
    return value.replace(/`/g, "\\`");
  }

  function blockWithLabel(
    label: string,
    body: string,
    options: { language?: string; maxLines?: number; maxChars?: number } = {},
  ): string {
    const lines: string[] = [`- **${label}:**`];
    if (!body.trim()) {
      lines.push("  _(empty)_");
      return lines.join("\n");
    }
    const truncated = truncateMultiline(body, options);
    const fence = codeFence(truncated.text, options.language ?? "");
    lines.push("", fence);
    if (truncated.truncated) {
      lines.push("  " + truncationSummary(truncated));
    }
    return lines.join("\n");
  }

  function codeFence(content: string, language = ""): string {
    const fenceLang = language.trim();
    return ["```" + fenceLang, content, "```"].join("\n");
  }

  function indentBlock(block: string, indent: string): string {
    return block
      .split("\n")
      .map((line) => indent + line)
      .join("\n");
  }

  function guessLanguageFromPath(pathname: string): string {
    const lower = pathname.toLowerCase();
    if (lower.endsWith(".ts")) return "ts";
    if (lower.endsWith(".tsx")) return "tsx";
    if (lower.endsWith(".js")) return "js";
    if (lower.endsWith(".jsx")) return "jsx";
    if (lower.endsWith(".json")) return "json";
    if (lower.endsWith(".md")) return "md";
    if (lower.endsWith(".sh")) return "bash";
    return "";
  }

  function describePath(target: unknown, base?: string): string {
    if (typeof target !== "string") {
      return String(target ?? "");
    }
    if (!base) {
      return target;
    }
    try {
      const relative = path.relative(base, target) || ".";
      return relative.includes("..") ? target : relative;
    } catch {
      return target;
    }
  }

  function extractMessageText(message: unknown): string {
    if (!message || typeof message !== "object") {
      return "";
    }

    const parts = Array.isArray((message as { content?: unknown }).content)
      ? ((message as { content?: unknown }).content as unknown[])
      : [];

    if (!parts.length) {
      return "";
    }

    const collected: string[] = [];
    for (const part of parts) {
      if (!part || typeof part !== "object") {
        continue;
      }
      if ("text" in part && typeof (part as { text: unknown }).text === "string") {
        collected.push((part as { text: string }).text);
      } else if ("type" in part && (part as { type: unknown }).type === "image") {
        collected.push("[image]");
      } else {
        collected.push(JSON.stringify(part));
      }
    }

    return collected.join("").trim();
  }

  function toText(value: unknown): string {
    if (value === null || value === undefined) {
      return "";
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((entry) => toText(entry)).join("");
    }
    if (typeof value === "object") {
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    return String(value);
  }

  function drainLines(
    buffer: string,
    handler: (line: string) => void,
  ): string {
    let working = buffer;
    while (true) {
      const breakIndex = working.indexOf("\n");
      if (breakIndex === -1) {
        break;
      }
      const line = working.slice(0, breakIndex);
      handler(line);
      working = working.slice(breakIndex + 1);
    }
    return working;
  }
}

function printUsage(): void {
  const scriptName = "a";
  console.error(`Usage: ${scriptName} [cursor-agent flags...] <prompt>`);
  console.error(`(Defaults to --model composer-1 when not provided)`);
  console.error(`Examples:`);
  console.error(`  ${scriptName} "use bun to search for a popular package"`);
  console.error(`  ${scriptName} --force "retry the last step"`);
  console.error(`  ${scriptName} --model gpt-5 -- "summarize the notes"`);
}

### System

    * **model:** Composer 1
    * **cwd:** .
    * **permission:** default
    * **api key:** login

### User

Read AGENTS.md

Your job is to port Laravel Reverb (PHP) to revurb-ts (Typescript) and maintain the repository.

First, read the ./specs/review.md

    * If the status is `not ok`, address the review feedback first
    * If the status is `ok`, address the current objectives in `./scripts/ralph/current.md`
    * Otherwise procceed with the port

As always, run your test/lint:fix/format rounds before committing.

The Laravel Reverb project is located in ./reverb and you should target ./ for your port.

Make a commit after every single file edit and push your changes before reporting back.

Use the ./notes/ directory as a scratchpad for your work (prefix with YYYY-MM-DD-HHMM-<slug> for clarity). Store long term plans and todo lists there.

The original project was tested with the Pest (https://pestphp.com/) testing framework. When porting, you will need to write end to end and unit tests for the project using Bun's test running (https://bun.com/docs/test.md). But make sure to spend most of your time on the actual porting, not on the testing. A good heuristic is to spend 80% of your time on the actual porting, and 20% on the testing.

### Assistant

Reviewing AGENTS.md and ./specs/review.md to determine next steps.

### Tool · read (started)

    * **path:** `AGENTS.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `AGENTS.md`
    * **status:** success
        * lines: 1-14
    * **content:**

    ## IMPORTANT
    
    - Try to keep things in one function unless composable or reusable
    - DO NOT do unnecessary destructuring of variables
    - DO NOT use `else` statements unless necessary
    - DO NOT use `try`/`catch` if it can be avoided
    - AVOID `try`/`catch` where possible
    - AVOID `else` statements
    - AVOID using `any` type
    - AVOID `let` statements
    - PREFER single word variable names where possible
    - Use as many Bun APIs as possible like Bun.file() and Bun.env (see https://bun.com/reference/bun)
    - ALWAYS USE PARALLEL TOOLS WHEN APPLICABLE.

### Tool · read (started)

    * **path:** `specs/review.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `specs/review.md`
    * **status:** success
        * lines: 1-7
    * **content:**

    last commit: deb78c1
    status: not ok
    review comments:
    - `bun run typecheck` still fails because the mock returned by `Factory.createHttpConnection()` does not satisfy either interface it claims to implement. `EventsBatchController.handle` expects a `contracts/connection.Connection`, but `Factory.handleBatchEvents` passes `HttpConnection` from `./http/connection` at `src/servers/reverb/factory.ts:847`, so TypeScript raises `TS2345` (the mock lacks `lastSeenAt`, `hasBeenPinged`, etc.). The same stub is also typed as `HttpConnection` yet omits required members (`connection`, `close`) and tries to access private fields, triggering the cluster of errors at `src/servers/reverb/factory.ts:1227-1255`. The HTTP controllers still cannot compile until this connection adapter is reworked to satisfy the actual contracts.
    - `Factory.convertToHttpRequest()` now returns an object literal typed as `IHttpRequest & { url: string; httpVersion: string; getSize(): number }`, but it also defines a top-level `headers` property that `IHttpRequest` does not declare. With excess-property checking enabled, TypeScript rejects this at `src/servers/reverb/factory.ts:1191 (TS2353)`, so the build never reaches runtime.
    - Objective 0 from `scripts/ralph/current.md` is unmet: `bun run lint` still reports nine `lint/suspicious/noExplicitAny` violations across the test suite (`tests/e2e/websocket-connection.test.ts:96`, `tests/feature/health-check-controller.test.ts:5`, `tests/unit/channels/channel.test.ts:25` & `61`, and `tests/unit/events/event-dispatcher.test.ts:22`, `75`, `307`, `311`, `315`). Husky will keep blocking commits until these `any` annotations are replaced with concrete types.

### Tool · read (started)

    * **path:** `scripts/ralph/current.md`
    * **status:** pending

### Tool · read (completed)

    * **path:** `scripts/ralph/current.md`
    * **status:** success
        * lines: 1-3
    * **content:**

    0. Fix the lint errors and warnings returned by `bun run lint` either manually or with `bun run lint:fix`
    1. Ensure GitHub Actions run successfully (should reflect @reverb/.github/workflows where relevant)

### Assistant

Review status is "not ok". Addressing the review feedback. Examining the relevant files:

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 840-869
    * **content:**

          const httpRequest = await Factory.convertToHttpRequest(req);
          const httpConnection = Factory.createHttpConnection();
          const app = Factory.appManager.driver().findById(params.appId);
          const channelManager = Factory.channelManager.for(app);
    
          const response = await Factory.eventsBatchController.handle(
            httpRequest,
            httpConnection,
            params.appId,
            app,
            channelManager,
          );
    
          return Factory.convertToResponse(response);
        } catch (error) {
          console.error("Error handling batch events:", error);
          return new Response(
            JSON.stringify({
              error:
                error instanceof Error ? error.message : "Internal server error",
            }),
            { status: 500, headers: { "Content-Type": "application/json" } },
          );
        }
      }
    
      /**
       * Handle connection listing
       *
       * @param req - The incoming request

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1185-1204
    * **content:**

    
        return {
          method,
          path: pathWithQuery,
          url: req.url, // Include full URL with query string for controllers to access query params
          httpVersion: "1.1",
          body,
          getMethod(): string {
            return method;
          },
          getPath(): string {
            // Return path without query string for Pusher signature verification
            // Pusher signatures are calculated over the path without the query string
            return pathWithoutQuery;
          },
          getHost(): string {
            return host;
          },
          getHeader(name: string): string | undefined {
            return headers[name.toLowerCase()];

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1220-1259
    * **content:**

       *
       * @returns HTTP Connection object
       *
       * @private
       */
      private static createHttpConnection(): HttpConnection {
        return new HttpConnection({
          stream: Math.floor(Math.random() * 1000000),
        });
      }
    
      /**
       * Convert controller Response to Bun Response
       *
       * @param controllerResponse - The response from the controller
       * @returns Bun Response object
       *
       * @private
       */
      private static convertToResponse(
        controllerResponse:
          | HttpResponse
          | { status?: number; content?: string | Record<string, unknown> },
      ): Response {
        // Check if it's our custom HttpResponse class
        if (controllerResponse instanceof HttpResponse) {
          const status = controllerResponse.getStatusCode();
          const body = controllerResponse.getContent();
          const headers = controllerResponse.getHeaders();
    
          return new Response(body, {
            status,
            headers,
          });
        }
    
        // Fallback for other response types
        const status = controllerResponse.status || 200;
        const body =
          typeof controllerResponse.content === "string"

### Tool · grep (started)

    {
      "args": {
        "pattern": "createHttpConnection",
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_25ae5f29-302a-4b13-84e9-79ce3595a95"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "createHttpConnection",
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_25ae5f29-302a-4b13-84e9-79ce3595a95"
      },
      "result": {
        "success": {
          "pattern": "createHttpConnection",
          "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "787:      const httpConnection = Factory.createHttpConnection();",
                    "matches": [
                      {
                        "lineNumber": 841,
                        "content": "      const httpConnection = Factory.createHttpConnection();",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 889,
                        "content": "      const httpConnection = Factory.createHttpConnection();",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 932,
                        "content": "      const httpConnection = Factory.createHttpConnection();",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 1020,
                        "content": "      const httpConnection = Factory.createHttpConnection();",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 1225,
                        "content": "  private static createHttpConnection(): HttpConnection {",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  }
                ],
                "totalLines": 5,
                "totalMatchedLines": 5,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · sem Search (started)

    {
      "args": {
        "query": "What is the Connection interface contract that HttpConnection should implement?",
        "targetDirectories": [],
        "explanation": ""
      }
    }

### Tool · sem Search (started)

    {
      "args": {
        "query": "What is the IHttpRequest interface definition?",
        "targetDirectories": [],
        "explanation": ""
      }
    }

### Tool · sem Search (completed)

    {
      "args": {
        "query": "What is the Connection interface contract that HttpConnection should implement?",
        "targetDirectories": [],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"src/contracts/websocket-connection.ts\" startLine=\"52\" endLine=\"168\">\n    52|/**\n    53| * WebSocketConnection Interface\n    54| *\n    55| * Provides the low-level contract for WebSocket transport operations.\n    56| * Implementations of this interface handle the raw WebSocket protocol,\n    57| * including sending messages, control frames, and managing connection lifecycle.\n    58| *\n    59| * Key Responsibilities:\n    60| * - Provide unique connection identification\n    61| * - Send text/binary messages over the WebSocket\n    62| * - Send control frames (PING, PONG, CLOSE)\n    63| * - Close connections gracefully\n    64| *\n    65| * @example\n    66| * ```typescript\n    67| * // Sending a message\n    68| * connection.send(\"Hello, WebSocket!\");\n    69| *\n    70| * // Sending a control frame\n    71| * connection.send({ payload: \"\", opcode: FrameOpcode.PING, getContents: () => Buffer.from(\"\") });\n    72| *\n    73| * // Closing with a message\n    74| * connection.close({ payload: \"Goodbye\", opcode: FrameOpcode.CLOSE, getContents: () => Buffer.from(\"Goodbye\") });\n    75| *\n    76| * // Getting connection ID\n    77| * const connectionId = connection.id();\n    78| * ```\n    79| */\n    80|export interface IWebSocketConnection {\n    81|  /**\n    82|   * Get the raw socket connection identifier.\n    83|   *\n    84|   * This identifier is used internally to track and manage connections.\n    85|   * In the PHP implementation (Ratchet), this returns an integer based on the\n    86|   * socket stream resource. In Bun, this could be based on the WebSocket object's\n    87|   * unique identifier or a generated ID.\n    88|   *\n    89|   * @returns The unique connection identifier (number for efficiency, string for flexibility)\n    90|   *\n    91|   * @example\n    92|   * ```typescript\n    93|   * const id = connection.id();\n    94|   * console.log(`Connection ID: ${id}`);\n    95|   * ```\n    96|   */\n    97|  id(): number | string;\n    98|\n    99|  /**\n   100|   * Send a message or frame to the connection.\n   101|   *\n   102|   * This method handles both regular messages (strings/buffers) and control frames.\n   103|   * When sending a Frame object, the implementation should extract the frame contents\n   104|   * and transmit them according to the WebSocket protocol.\n   105|   *\n   106|   * For regular messages, the implementation may wrap them in appropriate WebSocket\n   107|   * frames (TEXT or BINARY) based on the content type.\n   108|   *\n   109|   * @param message - The message to send. Can be:\n   110|   *   - string: Text message (will be sent as TEXT frame)\n   111|   *   - Buffer: Binary message (will be sent as BINARY frame)\n   112|   *   - Frame: Control frame (PING, PONG, CLOSE)\n   113|   *\n   114|   * @throws Error if the connection is closed or invalid\n   115|   *\n   116|   * @example\n   117|   * ```typescript\n   118|   * // Send a text message\n   119|   * connection.send(\"Hello, client!\");\n   120|   *\n   121|   * // Send a binary message\n   122|   * connection.send(Buffer.from([0x01, 0x02, 0x03]));\n   123|   *\n   124|   * // Send a PING frame\n   125|   * connection.send({\n   126|   *   payload: \"\",\n   127|   *   opcode: FrameOpcode.PING,\n   128|   *   getContents: () => Buffer.from(\"\")\n   129|   * });\n   130|   * ```\n   131|   */\n   ...\n   167|;\n   168|}\n</search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Http/Connection.php\" startLine=\"1\" endLine=\"115\">\n     1|<?php\n     2|\n     3|namespace Laravel\\Reverb\\Servers\\Reverb\\Http;\n     4|\n     5|use BadMethodCallException;\n     6|use React\\Socket\\ConnectionInterface;\n     7|\n     8|class Connection\n     9|{\n    10|    /**\n    11|     * Connection ID.\n    12|     */\n    13|    protected int $id;\n    14|\n    15|    /**\n    16|     * Connection status.\n    17|     */\n    18|    protected bool $connected = false;\n    19|\n    20|    /**\n    21|     * Connection buffer.\n    22|     */\n    23|    protected string $buffer = '';\n    24|\n    25|    /**\n    26|     * Create a new connection instance.\n    27|     */\n    28|    public function __construct(protected ConnectionInterface $connection)\n    29|    {\n    30|        $this->id = (int) $connection->stream;\n    31|    }\n    32|\n    33|    /**\n    34|     * Return the connection ID.\n    35|     */\n    36|    public function id(): int\n    37|    {\n    38|        return $this->id;\n    39|    }\n    40|\n    41|    /**\n    42|     * Mark the connection as connected.\n    43|     */\n    44|    public function connect(): void\n    45|    {\n    46|        $this->connected = true;\n    47|    }\n    48|\n    49|    /**\n    50|     * Determine whether the connection is connected.\n    51|     */\n    52|    public function isConnected(): bool\n    53|    {\n    54|        return $this->connected;\n    55|    }\n    56|\n    57|    /**\n    58|     * Get the HTTP message buffer.\n    59|     */\n    60|    public function buffer(): string\n    61|    {\n    62|        return $this->buffer;\n    63|    }\n    64|\n    65|    /**\n    66|     * Determine whether the connection has an HTTP message buffer set.\n    67|     */\n    68|    public function hasBuffer(): bool\n    69|    {\n    70|        return $this->buffer !== '';\n    71|    }\n    72|\n    73|    /**\n    74|     * Return the HTTP message buffer length.\n    75|     */\n    76|    public function bufferLength(): int\n    77|    {\n    78|        return strlen($this->buffer);\n    79|    }\n    80|\n    81|    /**\n    82|     * Append to the HTTP message buffer.\n    83|     */\n    84|    public function appendToBuffer($message): void\n    85|    {\n    86|        $this->buffer .= $message;\n    87|    }\n    88|\n    89|    /**\n    90|     * Clear the HTTP message buffer.\n    91|     */\n    92|    public function clearBuffer(): void\n    93|    {\n    94|        $this->buffer = '';\n    95|    }\n    96|\n    97|    /**\n    98|     * Send a message to the connection.\n    99|     */\n   100|    public function send($data): self\n   101|    {\n   102|        $this->connection->write($data);\n   103|\n   104|        return $this;\n   105|    }\n   106|\n   107|    /**\n   108|     * Close the connection.\n   109|     */\n   110|    public function close(): self\n   111|    {\n   112|        $this->connection->end();\n   113|\n   114|        return $this;\n   115|    }\n</search_result>\n<search_result path=\"src/connection.ts\" startLine=\"2\" endLine=\"103\">\n     2|import type { FrameOpcode } from \"./contracts/websocket-connection\";\n     3|import { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";\n     4|import { MessageSent } from \"./events/message-sent\";\n     5|\n     6|/**\n     7| * Connection Implementation\n     8| *\n     9| * Concrete implementation of the Connection contract that wraps a WebSocket\n    10| * connection with application context and state management.\n    11| *\n    12| * This class implements the Pusher-compatible connection wrapper, handling:\n    13| * - Connection identification and normalization\n    14| * - Message sending with event dispatching\n    15| * - Control frame management (PING/PONG)\n    16| * - Connection lifecycle and termination\n    17| *\n    18| * The connection maintains state through the abstract base class:\n    19| * - lastSeenAt: Timestamp tracking for activity monitoring\n    20| * - hasBeenPinged: Ping state for stale connection detection\n    21| * - usesControlFrames: Whether the connection uses control frames\n    22| *\n    23| * @see Connection contract for state machine documentation\n    24| */\n    25|export class Connection extends ConnectionContract {\n    26|  /**\n    27|   * The normalized socket ID.\n    28|   *\n    29|   * Cached socket ID in Pusher format (\"number.number\").\n    30|   * Generated once on first access and reused for connection lifetime.\n    31|   *\n    32|   * @private\n    33|   */\n    34|  private _id: string | null = null;\n    35|\n    36|  /**\n    37|   * Get the raw socket connection identifier.\n    38|   *\n    39|   * Returns the underlying WebSocket connection's identifier as a string.\n    40|   * This is the raw transport-level identifier, not the normalized socket ID.\n    41|   *\n    42|   * @returns The raw connection identifier as a string\n    43|   */\n    44|  identifier(): string {\n    45|    return String(this.connection.id());\n    46|  }\n    47|\n    48|  /**\n    49|   * Get the normalized socket ID.\n    50|   *\n    51|   * Returns a Pusher-compatible socket ID in the format \"number.number\".\n    52|   * The ID is generated once and cached for the lifetime of the connection.\n    53|   *\n    54|   * @returns The normalized socket ID (e.g., \"123456789.987654321\")\n    55|   */\n   ...\n   103|}\n</search_result>\n<search_result path=\"src/contracts/connection.ts\" startLine=\"2\" endLine=\"88\">\n     2|import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";\n     3|\n     4|/**\n     5| * Connection State Machine\n     6| *\n     7| * The Connection class tracks connection state using a timestamp-based state machine:\n     8| *\n     9| * State Transitions:\n    10| * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n    11| * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n    12| * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n    13| *\n    14| * State Determination:\n    15| * - isActive(): time() < lastSeenAt + app.pingInterval()\n    16| * - isInactive(): !isActive()\n    17| * - isStale(): isInactive() && hasBeenPinged\n    18| *\n    19| * Lifecycle:\n    20| * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n    21| * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n    22| * 3. No activity for pingInterval → isInactive() = true\n    23| * 4. Ping sent → ping() → hasBeenPinged = true\n    24| * 5. Pong received → pong() → hasBeenPinged = false\n    25| * 6. No response after ping → isStale() = true → connection pruned\n    26| *\n    27| * Timestamps:\n    28| * - All timestamps use SECONDS (not milliseconds)\n    29| * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n    30| * - This matches PHP's time() function behavior\n    31| */\n    32|\n    33|/**\n    34| * Connection Abstract Class\n    35| *\n    36| * Application-aware connection wrapper that manages WebSocket connection state,\n    37| * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n    38| * activity tracking, and state management.\n    39| *\n    40| * Key Responsibilities:\n    41| * - Wrap WebSocketConnection with application context\n    42| * - Track connection activity via lastSeenAt timestamp\n    43| * - Implement state machine (Active/Inactive/Stale)\n    44| * - Manage ping/pong state for connection health\n    45| * - Generate normalized socket IDs\n    46| * - Provide connection lifecycle methods\n    47| *\n    48| * @abstract\n    49| *\n    50| * @example\n    51| * ```typescript\n    52| * class ReverbConnection extends Connection {\n    53| *   identifier(): string {\n    54| *     return String(this.connection.id());\n    55| *   }\n    56| *\n    57| *   id(): string {\n    58| *     if (!this._id) {\n    59| *       this._id = this.generateId();\n    60| *     }\n    61| *     return this._id;\n    62| *   }\n    63| *\n    64| *   send(message: string): void {\n    65| *     this.connection.send(message);\n    66| *     // Dispatch MessageSent event\n    67| *   }\n    68| *\n    69| *   control(type: FrameOpcode = FrameOpcode.PING): void {\n    70| *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n    71| *   }\n    72| *\n    73| *   terminate(): void {\n    74| *     this.connection.close();\n    75| *   }\n    76| * }\n    77| * ```\n    78| */\n    79|export abstract class Connection {\n    80|  /**\n    81|   * The last time the connection was seen (in seconds, not milliseconds).\n    82|   *\n    83|   * Initialized to current time when connection is created.\n    84|   * Updated via touch() when activity is detected.\n    85|   * Used to determine connection state (active/inactive/stale).\n    86|   *\n    87|   * @protected\n    88|   */\n</search_result>\n<search_result path=\"reverb/src/contracts/Connection.php\" startLine=\"1\" endLine=\"101\">\n     1|<?php\n     2|\n     3|namespace Laravel\\Reverb\\Contracts;\n     4|\n     5|use Laravel\\Reverb\\Application;\n     6|use Ratchet\\RFC6455\\Messaging\\Frame;\n     7|\n     8|abstract class Connection\n     9|{\n    10|    /**\n    11|     * The last time the connection was seen.\n    12|     */\n    13|    protected ?int $lastSeenAt;\n    14|\n    15|    /**\n    16|     * Stores the ping state of the connection.\n    17|     */\n    18|    protected $hasBeenPinged = false;\n    19|\n    20|    /**\n    21|     * Indicates if the connection uses control frames.\n    22|     */\n    23|    protected $usesControlFrames = false;\n    24|\n    25|    /**\n    26|     * Create a new connection instance.\n    27|     */\n    28|    public function __construct(protected WebSocketConnection $connection, protected Application $application, protected ?string $origin)\n    29|    {\n    30|        $this->lastSeenAt = time();\n    31|    }\n    32|\n    33|    /**\n    34|     * Get the raw socket connection identifier.\n    35|     */\n    36|    abstract public function identifier(): string;\n    37|\n    38|    /**\n    39|     * Get the normalized socket ID.\n    40|     */\n    41|    abstract public function id(): string;\n    42|\n    43|    /**\n    44|     * Send a message to the connection.\n    45|     */\n    46|    abstract public function send(string $message): void;\n    47|\n    48|    /**\n    49|     * Send a control frame to the connection.\n    50|     */\n    51|    abstract public function control(string $type = Frame::OP_PING): void;\n    52|\n    53|    /**\n    54|     * Terminate a connection.\n    55|     */\n    56|    abstract public function terminate(): void;\n    57|\n    58|    /**\n    59|     * Get the application the connection belongs to.\n    60|     */\n    61|    public function app(): Application\n    62|    {\n    63|        return $this->application;\n    64|    }\n    65|\n    66|    /**\n    67|     * Get the origin of the connection.\n    68|     */\n    69|    public function origin(): ?string\n    70|    {\n    71|        return $this->origin;\n    72|    }\n    73|\n    74|    /**\n    75|     * Mark the connection as pinged.\n    76|     */\n    77|    public function ping(): void\n    78|    {\n    79|        $this->hasBeenPinged = true;\n    80|    }\n    81|\n    82|    /**\n    83|     * Mark the connection as ponged.\n    84|     */\n    85|    public function pong(): void\n    86|    {\n    87|        $this->hasBeenPinged = false;\n    88|    }\n    89|\n    90|    /**\n    91|     * Get the last time the connection was seen.\n    92|     */\n    93|    public function lastSeenAt(): ?int\n    94|    {\n    95|        return $this->lastSeenAt;\n    96|    }\n    97|\n    98|    /**\n    99|     * Set the connection last seen at timestamp.\n   100|     */\n   101|    \n</search_result>\n\n<search_result path=\"reverb/src/contracts/WebSocketConnection.php\" endLine=\"21\"></search_result>\n<search_result path=\"src/servers/reverb/http/connection.ts\" endLine=\"127\"></search_result>\n<search_result path=\"src/servers/reverb/connection.ts\" endLine=\"276\"></search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Connection.php\" endLine=\"81\"></search_result>\n<search_result path=\"reverb/src/Connection.php\" endLine=\"69\"></search_result>\n<search_result path=\"notes/2025-11-13-1300-review-fixes.md\" endLine=\"37\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"37\" endLine=\"57\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"47\" endLine=\"65\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"62\" endLine=\"85\">\n   65|;\n   66|}\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" endLine=\"24\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" showSignaturesOnly=\"true\" startLine=\"70\" endLine=\"280\">\n   71|export class EventsBatchController {\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"82\" endLine=\"115\">\n   85|;\n   86|}\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"115\" endLine=\"737\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"52\" endLine=\"77\">\n   57|;\n   58|}\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"132\" endLine=\"737\">\n  133|export class MetricsHandler {\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" endLine=\"29\"></search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/websocket-connection.ts",
                "range": {
                  "startPosition": {
                    "line": 49,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 167,
                    "column": 1
                  }
                },
                "contents": "/**\n * WebSocketConnection Interface\n *\n * Provides the low-level contract for WebSocket transport operations.\n * Implementations of this interface handle the raw WebSocket protocol,\n * including sending messages, control frames, and managing connection lifecycle.\n *\n * Key Responsibilities:\n * - Provide unique connection identification\n * - Send text/binary messages over the WebSocket\n * - Send control frames (PING, PONG, CLOSE)\n * - Close connections gracefully\n *\n * @example\n * ```typescript\n * // Sending a message\n * connection.send(\"Hello, WebSocket!\");\n *\n * // Sending a control frame\n * connection.send({ payload: \"\", opcode: FrameOpcode.PING, getContents: () => Buffer.from(\"\") });\n *\n * // Closing with a message\n * connection.close({ payload: \"Goodbye\", opcode: FrameOpcode.CLOSE, getContents: () => Buffer.from(\"Goodbye\") });\n *\n * // Getting connection ID\n * const connectionId = connection.id();\n * ```\n */\nexport interface IWebSocketConnection {\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * This identifier is used internally to track and manage connections.\n   * In the PHP implementation (Ratchet), this returns an integer based on the\n   * socket stream resource. In Bun, this could be based on the WebSocket object's\n   * unique identifier or a generated ID.\n   *\n   * @returns The unique connection identifier (number for efficiency, string for flexibility)\n   *\n   * @example\n   * ```typescript\n   * const id = connection.id();\n   * console.log(`Connection ID: ${id}`);\n   * ```\n   */\n  id(): number | string;\n\n  /**\n   * Send a message or frame to the connection.\n   *\n   * This method handles both regular messages (strings/buffers) and control frames.\n   * When sending a Frame object, the implementation should extract the frame contents\n   * and transmit them according to the WebSocket protocol.\n   *\n   * For regular messages, the implementation may wrap them in appropriate WebSocket\n   * frames (TEXT or BINARY) based on the content type.\n   *\n   * @param message - The message to send. Can be:\n   *   - string: Text message (will be sent as TEXT frame)\n   *   - Buffer: Binary message (will be sent as BINARY frame)\n   *   - Frame: Control frame (PING, PONG, CLOSE)\n   *\n   * @throws Error if the connection is closed or invalid\n   *\n   * @example\n   * ```typescript\n   * // Send a text message\n   * connection.send(\"Hello, client!\");\n   *\n   * // Send a binary message\n   * connection.send(Buffer.from([0x01, 0x02, 0x03]));\n   *\n   * // Send a PING frame\n   * connection.send({\n   *   payload: \"\",\n   *   opcode: FrameOpcode.PING,\n   *   getContents: () => Buffer.from(\"\")\n   * });\n   * ```\n   */\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocketConnection Interface",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides the low-level contract for WebSocket transport operations.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " * Implementations of this interface handle the raw WebSocket protocol,",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " * including sending messages, control frames, and managing connection lifecycle.",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Responsibilities:",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide unique connection identification",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send text/binary messages over the WebSocket",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send control frames (PING, PONG, CLOSE)",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " * - Close connections gracefully",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sending a message",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.send(\"Hello, WebSocket!\");",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sending a control frame",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.send({ payload: \"\", opcode: FrameOpcode.PING, getContents: () => Buffer.from(\"\") });",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " * // Closing with a message",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.close({ payload: \"Goodbye\", opcode: FrameOpcode.CLOSE, getContents: () => Buffer.from(\"Goodbye\") });",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * // Getting connection ID",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * const connectionId = connection.id();",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "export interface IWebSocketConnection {",
                    "lineNumber": 80,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * This identifier is used internally to track and manage connections.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * In the PHP implementation (Ratchet), this returns an integer based on the",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * socket stream resource. In Bun, this could be based on the WebSocket object's",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * unique identifier or a generated ID.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The unique connection identifier (number for efficiency, string for flexibility)",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * const id = connection.id();",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * console.log(`Connection ID: ${id}`);",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "  id(): number | string;",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   * Send a message or frame to the connection.",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method handles both regular messages (strings/buffers) and control frames.",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * When sending a Frame object, the implementation should extract the frame contents",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   * and transmit them according to the WebSocket protocol.",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * For regular messages, the implementation may wrap them in appropriate WebSocket",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * frames (TEXT or BINARY) based on the content type.",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The message to send. Can be:",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - string: Text message (will be sent as TEXT frame)",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Buffer: Binary message (will be sent as BINARY frame)",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Frame: Control frame (PING, PONG, CLOSE)",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Error if the connection is closed or invalid",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a text message",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(\"Hello, client!\");",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a binary message",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(Buffer.from([0x01, 0x02, 0x03]));",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a PING frame",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send({",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "   *   payload: \"\",",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "   *   opcode: FrameOpcode.PING,",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "   *   getContents: () => Buffer.from(\"\")",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * });",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 167,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 168,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.5120798945426941
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Http/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 116,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Servers\\Reverb\\Http;\n\nuse BadMethodCallException;\nuse React\\Socket\\ConnectionInterface;\n\nclass Connection\n{\n    /**\n     * Connection ID.\n     */\n    protected int $id;\n\n    /**\n     * Connection status.\n     */\n    protected bool $connected = false;\n\n    /**\n     * Connection buffer.\n     */\n    protected string $buffer = '';\n\n    /**\n     * Create a new connection instance.\n     */\n    public function __construct(protected ConnectionInterface $connection)\n    {\n        $this->id = (int) $connection->stream;\n    }\n\n    /**\n     * Return the connection ID.\n     */\n    public function id(): int\n    {\n        return $this->id;\n    }\n\n    /**\n     * Mark the connection as connected.\n     */\n    public function connect(): void\n    {\n        $this->connected = true;\n    }\n\n    /**\n     * Determine whether the connection is connected.\n     */\n    public function isConnected(): bool\n    {\n        return $this->connected;\n    }\n\n    /**\n     * Get the HTTP message buffer.\n     */\n    public function buffer(): string\n    {\n        return $this->buffer;\n    }\n\n    /**\n     * Determine whether the connection has an HTTP message buffer set.\n     */\n    public function hasBuffer(): bool\n    {\n        return $this->buffer !== '';\n    }\n\n    /**\n     * Return the HTTP message buffer length.\n     */\n    public function bufferLength(): int\n    {\n        return strlen($this->buffer);\n    }\n\n    /**\n     * Append to the HTTP message buffer.\n     */\n    public function appendToBuffer($message): void\n    {\n        $this->buffer .= $message;\n    }\n\n    /**\n     * Clear the HTTP message buffer.\n     */\n    public function clearBuffer(): void\n    {\n        $this->buffer = '';\n    }\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send($data): self\n    {\n        $this->connection->write($data);\n\n        return $this;\n    }\n\n    /**\n     * Close the connection.\n     */\n    public function close(): self\n    {\n        $this->connection->end();\n\n        return $this;\n    }",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Servers\\Reverb\\Http;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use BadMethodCallException;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\Socket\\ConnectionInterface;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "class Connection",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection ID.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "    protected int $id;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection status.",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "    protected bool $connected = false;",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection buffer.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    protected string $buffer = '';",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new connection instance.",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(protected ConnectionInterface $connection)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->id = (int) $connection->stream;",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     * Return the connection ID.",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    public function id(): int",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->id;",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as connected.",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "    public function connect(): void",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connected = true;",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "     * Determine whether the connection is connected.",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    public function isConnected(): bool",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->connected;",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the HTTP message buffer.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "    public function buffer(): string",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->buffer;",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "     * Determine whether the connection has an HTTP message buffer set.",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "    public function hasBuffer(): bool",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->buffer !== '';",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "     * Return the HTTP message buffer length.",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    public function bufferLength(): int",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "        return strlen($this->buffer);",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "     * Append to the HTTP message buffer.",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    public function appendToBuffer($message): void",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer .= $message;",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "     * Clear the HTTP message buffer.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "    public function clearBuffer(): void",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer = '';",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send($data): self",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->write($data);",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this;",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "     * Close the connection.",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "    public function close(): self",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->end();",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this;",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 115,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.503829836845398
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 74
                  },
                  "endPosition": {
                    "line": 102,
                    "column": 1
                  }
                },
                "contents": "import type { FrameOpcode } from \"./contracts/websocket-connection\";\nimport { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";\nimport { MessageSent } from \"./events/message-sent\";\n\n/**\n * Connection Implementation\n *\n * Concrete implementation of the Connection contract that wraps a WebSocket\n * connection with application context and state management.\n *\n * This class implements the Pusher-compatible connection wrapper, handling:\n * - Connection identification and normalization\n * - Message sending with event dispatching\n * - Control frame management (PING/PONG)\n * - Connection lifecycle and termination\n *\n * The connection maintains state through the abstract base class:\n * - lastSeenAt: Timestamp tracking for activity monitoring\n * - hasBeenPinged: Ping state for stale connection detection\n * - usesControlFrames: Whether the connection uses control frames\n *\n * @see Connection contract for state machine documentation\n */\nexport class Connection extends ConnectionContract {\n  /**\n   * The normalized socket ID.\n   *\n   * Cached socket ID in Pusher format (\"number.number\").\n   * Generated once on first access and reused for connection lifetime.\n   *\n   * @private\n   */\n  private _id: string | null = null;\n\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * Returns the underlying WebSocket connection's identifier as a string.\n   * This is the raw transport-level identifier, not the normalized socket ID.\n   *\n   * @returns The raw connection identifier as a string\n   */\n  identifier(): string {\n    return String(this.connection.id());\n  }\n\n  /**\n   * Get the normalized socket ID.\n   *\n   * Returns a Pusher-compatible socket ID in the format \"number.number\".\n   * The ID is generated once and cached for the lifetime of the connection.\n   *\n   * @returns The normalized socket ID (e.g., \"123456789.987654321\")\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { FrameOpcode } from \"./contracts/websocket-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageSent } from \"./events/message-sent\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Implementation",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Concrete implementation of the Connection contract that wraps a WebSocket",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * connection with application context and state management.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * This class implements the Pusher-compatible connection wrapper, handling:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection identification and normalization",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Message sending with event dispatching",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Control frame management (PING/PONG)",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection lifecycle and termination",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * The connection maintains state through the abstract base class:",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * - lastSeenAt: Timestamp tracking for activity monitoring",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - hasBeenPinged: Ping state for stale connection detection",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - usesControlFrames: Whether the connection uses control frames",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * @see Connection contract for state machine documentation",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection extends ConnectionContract {",
                    "lineNumber": 25,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * The normalized socket ID.",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * Cached socket ID in Pusher format (\"number.number\").",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generated once on first access and reused for connection lifetime.",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  private _id: string | null = null;",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns the underlying WebSocket connection's identifier as a string.",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is the raw transport-level identifier, not the normalized socket ID.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The raw connection identifier as a string",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  identifier(): string {",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "    return String(this.connection.id());",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the normalized socket ID.",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns a Pusher-compatible socket ID in the format \"number.number\".",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * The ID is generated once and cached for the lifetime of the connection.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The normalized socket ID (e.g., \"123456789.987654321\")",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 103,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4839983880519867
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 50
                  },
                  "endPosition": {
                    "line": 344,
                    "column": 0
                  }
                },
                "contents": "import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";\n\n/**\n * Connection State Machine\n *\n * The Connection class tracks connection state using a timestamp-based state machine:\n *\n * State Transitions:\n * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n *\n * State Determination:\n * - isActive(): time() < lastSeenAt + app.pingInterval()\n * - isInactive(): !isActive()\n * - isStale(): isInactive() && hasBeenPinged\n *\n * Lifecycle:\n * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n * 3. No activity for pingInterval → isInactive() = true\n * 4. Ping sent → ping() → hasBeenPinged = true\n * 5. Pong received → pong() → hasBeenPinged = false\n * 6. No response after ping → isStale() = true → connection pruned\n *\n * Timestamps:\n * - All timestamps use SECONDS (not milliseconds)\n * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n * - This matches PHP's time() function behavior\n */\n\n/**\n * Connection Abstract Class\n *\n * Application-aware connection wrapper that manages WebSocket connection state,\n * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n * activity tracking, and state management.\n *\n * Key Responsibilities:\n * - Wrap WebSocketConnection with application context\n * - Track connection activity via lastSeenAt timestamp\n * - Implement state machine (Active/Inactive/Stale)\n * - Manage ping/pong state for connection health\n * - Generate normalized socket IDs\n * - Provide connection lifecycle methods\n *\n * @abstract\n *\n * @example\n * ```typescript\n * class ReverbConnection extends Connection {\n *   identifier(): string {\n *     return String(this.connection.id());\n *   }\n *\n *   id(): string {\n *     if (!this._id) {\n *       this._id = this.generateId();\n *     }\n *     return this._id;\n *   }\n *\n *   send(message: string): void {\n *     this.connection.send(message);\n *     // Dispatch MessageSent event\n *   }\n *\n *   control(type: FrameOpcode = FrameOpcode.PING): void {\n *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n *   }\n *\n *   terminate(): void {\n *     this.connection.close();\n *   }\n * }\n * ```\n */\nexport abstract class Connection {\n  /**\n   * The last time the connection was seen (in seconds, not milliseconds).\n   *\n   * Initialized to current time when connection is created.\n   * Updated via touch() when activity is detected.\n   * Used to determine connection state (active/inactive/stale).\n   *\n   * @protected\n   */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection State Machine",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * The Connection class tracks connection state using a timestamp-based state machine:",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * State Transitions:",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * State Determination:",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - isActive(): time() < lastSeenAt + app.pingInterval()",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - isInactive(): !isActive()",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - isStale(): isInactive() && hasBeenPinged",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Lifecycle:",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. No activity for pingInterval → isInactive() = true",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Ping sent → ping() → hasBeenPinged = true",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Pong received → pong() → hasBeenPinged = false",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. No response after ping → isStale() = true → connection pruned",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * Timestamps:",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * - All timestamps use SECONDS (not milliseconds)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * - Use Math.floor(Date.now() / 1000) to get current time in seconds",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * - This matches PHP's time() function behavior",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Abstract Class",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-aware connection wrapper that manages WebSocket connection state,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * tracking, and lifecycle. Extends raw WebSocketConnection with application context,",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " * activity tracking, and state management.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Responsibilities:",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * - Wrap WebSocketConnection with application context",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * - Track connection activity via lastSeenAt timestamp",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " * - Implement state machine (Active/Inactive/Stale)",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage ping/pong state for connection health",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " * - Generate normalized socket IDs",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide connection lifecycle methods",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " * @abstract",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * class ReverbConnection extends Connection {",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *   identifier(): string {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " *     return String(this.connection.id());",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   id(): string {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     if (!this._id) {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *       this._id = this.generateId();",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " *     return this._id;",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " *   send(message: string): void {",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send(message);",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " *     // Dispatch MessageSent event",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " *   control(type: FrameOpcode = FrameOpcode.PING): void {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " *   terminate(): void {",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.close();",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "export abstract class Connection {",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * The last time the connection was seen (in seconds, not milliseconds).",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initialized to current time when connection is created.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Updated via touch() when activity is detected.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * Used to determine connection state (active/inactive/stale).",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 88,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4701789617538452
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/contracts/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 100,
                    "column": 4
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Contracts;\n\nuse Laravel\\Reverb\\Application;\nuse Ratchet\\RFC6455\\Messaging\\Frame;\n\nabstract class Connection\n{\n    /**\n     * The last time the connection was seen.\n     */\n    protected ?int $lastSeenAt;\n\n    /**\n     * Stores the ping state of the connection.\n     */\n    protected $hasBeenPinged = false;\n\n    /**\n     * Indicates if the connection uses control frames.\n     */\n    protected $usesControlFrames = false;\n\n    /**\n     * Create a new connection instance.\n     */\n    public function __construct(protected WebSocketConnection $connection, protected Application $application, protected ?string $origin)\n    {\n        $this->lastSeenAt = time();\n    }\n\n    /**\n     * Get the raw socket connection identifier.\n     */\n    abstract public function identifier(): string;\n\n    /**\n     * Get the normalized socket ID.\n     */\n    abstract public function id(): string;\n\n    /**\n     * Send a message to the connection.\n     */\n    abstract public function send(string $message): void;\n\n    /**\n     * Send a control frame to the connection.\n     */\n    abstract public function control(string $type = Frame::OP_PING): void;\n\n    /**\n     * Terminate a connection.\n     */\n    abstract public function terminate(): void;\n\n    /**\n     * Get the application the connection belongs to.\n     */\n    public function app(): Application\n    {\n        return $this->application;\n    }\n\n    /**\n     * Get the origin of the connection.\n     */\n    public function origin(): ?string\n    {\n        return $this->origin;\n    }\n\n    /**\n     * Mark the connection as pinged.\n     */\n    public function ping(): void\n    {\n        $this->hasBeenPinged = true;\n    }\n\n    /**\n     * Mark the connection as ponged.\n     */\n    public function pong(): void\n    {\n        $this->hasBeenPinged = false;\n    }\n\n    /**\n     * Get the last time the connection was seen.\n     */\n    public function lastSeenAt(): ?int\n    {\n        return $this->lastSeenAt;\n    }\n\n    /**\n     * Set the connection last seen at timestamp.\n     */\n    ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Contracts;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Application;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\Frame;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "abstract class Connection",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "     * The last time the connection was seen.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "    protected ?int $lastSeenAt;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "     * Stores the ping state of the connection.",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $hasBeenPinged = false;",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "     * Indicates if the connection uses control frames.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $usesControlFrames = false;",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new connection instance.",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(protected WebSocketConnection $connection, protected Application $application, protected ?string $origin)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->lastSeenAt = time();",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the raw socket connection identifier.",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function identifier(): string;",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the normalized socket ID.",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function id(): string;",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function send(string $message): void;",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a control frame to the connection.",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function control(string $type = Frame::OP_PING): void;",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "     * Terminate a connection.",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function terminate(): void;",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the application the connection belongs to.",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    public function app(): Application",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->application;",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the origin of the connection.",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    public function origin(): ?string",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->origin;",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as pinged.",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    public function ping(): void",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->hasBeenPinged = true;",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as ponged.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    public function pong(): void",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->hasBeenPinged = false;",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the last time the connection was seen.",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "    public function lastSeenAt(): ?int",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->lastSeenAt;",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "     * Set the connection last seen at timestamp.",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 101,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4682500958442688
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/contracts/WebSocketConnection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 21,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Contracts;\n\ninterface WebSocketConnection\n{\n    /**\n     * Get the raw socket connection identifier.\n     */\n    public function id(): int|string;\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send(mixed $message): void;\n\n    /**\n     * Close the connection.\n     */\n    public function close(mixed $message = null): void;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Contracts;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "interface WebSocketConnection",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the raw socket connection identifier.",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "    public function id(): int|string;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send(mixed $message): void;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "     * Close the connection.",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "    public function close(mixed $message = null): void;",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 21,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4666300117969513
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 127,
                    "column": 1
                  }
                },
                "contents": "/**\n * HTTP Connection Wrapper\n *\n * Wraps an underlying socket/connection and manages state for HTTP message handling.\n * This class is used by the Reverb server to manage HTTP connections before they're\n * upgraded to WebSocket connections.\n */\nexport class Connection {\n  private id: number;\n  private connected = false;\n  private _buffer = \"\";\n\n  /**\n   * Create a new HTTP connection instance.\n   *\n   * @param connection - The underlying socket/connection object\n   */\n  constructor(\n    private readonly connection: {\n      stream?: unknown;\n      write?: (data: string | Uint8Array) => void;\n      end?: () => void;\n    },\n  ) {\n    this.id = Number(connection.stream) || 0;\n  }\n\n  /**\n   * Get the connection ID.\n   *\n   * @returns The connection ID as a number\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Connection Wrapper",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Wraps an underlying socket/connection and manages state for HTTP message handling.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * This class is used by the Reverb server to manage HTTP connections before they're",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * upgraded to WebSocket connections.",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection {",
                    "lineNumber": 8,
                    "isSignature": true
                  },
                  {
                    "text": "  private id: number;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "  private connected = false;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "  private _buffer = \"\";",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new HTTP connection instance.",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The underlying socket/connection object",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "    private readonly connection: {",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "      stream?: unknown;",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "      write?: (data: string | Uint8Array) => void;",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "      end?: () => void;",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    this.id = Number(connection.stream) || 0;",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the connection ID.",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The connection ID as a number",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 128,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4621523916721344
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 276,
                    "column": 1
                  }
                },
                "contents": "import type { WebSocket } from \"bun\";\nimport type {\n  Frame,\n  IWebSocketConnection,\n} from \"../../contracts/websocket-connection\";\n\n/**\n * WebSocket Connection Implementation\n *\n * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\n * This class handles WebSocket frame operations, message buffering for fragmented messages,\n * and control frame handling according to RFC 6455.\n *\n * Key responsibilities:\n * - Provide unique connection identification\n * - Send text/binary messages over the WebSocket\n * - Send and handle control frames (PING, PONG, CLOSE)\n * - Manage connection lifecycle with proper cleanup\n *\n * Note: Bun's WebSocket handles frame framing automatically, so we focus on\n * providing a consistent API for message handling and control frames.\n */\nexport class Connection implements IWebSocketConnection {\n  /**\n   * Unique connection identifier.\n   */\n  private connectionId: string;\n\n  /**\n   * Handler for complete messages.\n   */\n  private onMessageHandler?: (message: string | Buffer) => void;\n\n  /**\n   * Handler for connection close events.\n   */\n  private _onCloseHandler?: () => void;\n\n  /**\n   * Maximum allowed message size in bytes.\n   */\n  private maxMessageSize?: number;\n\n  /**\n   * Create a new WebSocket connection instance.\n   *\n   * @param socket - The Bun WebSocket instance\n   */\n  constructor(private socket: WebSocket) {\n    // Generate a unique connection ID using the socket's internal data\n    this.connectionId = this.generateConnectionId();\n    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\n    // not on individual socket objects. We don't need setupHandlers() here.\n  }\n\n  /**\n   * Generate a unique connection identifier.\n   * Uses the socket's remoteAddress and a timestamp for uniqueness.\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { WebSocket } from \"bun\";",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "import type {",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "  Frame,",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "  IWebSocketConnection,",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "} from \"../../contracts/websocket-connection\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocket Connection Implementation",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * This class handles WebSocket frame operations, message buffering for fragmented messages,",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * and control frame handling according to RFC 6455.",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Key responsibilities:",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide unique connection identification",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send text/binary messages over the WebSocket",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send and handle control frames (PING, PONG, CLOSE)",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage connection lifecycle with proper cleanup",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * Note: Bun's WebSocket handles frame framing automatically, so we focus on",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * providing a consistent API for message handling and control frames.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection implements IWebSocketConnection {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * Unique connection identifier.",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  private connectionId: string;",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for complete messages.",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  private onMessageHandler?: (message: string | Buffer) => void;",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for connection close events.",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  private _onCloseHandler?: () => void;",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * Maximum allowed message size in bytes.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  private maxMessageSize?: number;",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new WebSocket connection instance.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param socket - The Bun WebSocket instance",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private socket: WebSocket) {",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "    // Generate a unique connection ID using the socket's internal data",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    this.connectionId = this.generateConnectionId();",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    // not on individual socket objects. We don't need setupHandlers() here.",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate a unique connection identifier.",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Uses the socket's remoteAddress and a timestamp for uniqueness.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 277,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4451148509979248
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 78,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 344,
                    "column": 0
                  }
                },
                "contents": "export \n\n\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * Returns the underlying WebSocket connection's identifier.\n   * This is typically a raw socket ID or resource identifier.\n   *\n   * @returns The raw connection identifier as a string\n   *\n   * @abstract\n   */\n  abstract identifier(): string;\n\n  /**\n   * Get the normalized socket ID.\n   *\n   * Returns a Pusher-compatible socket ID (format: \"number.number\").\n   * This ID is generated once and cached for the connection lifetime.\n   *\n   * @returns The normalized socket ID (e.g., \"123456789.987654321\")\n   *\n   * @abstract\n   */\n  abstract id(): string;\n\n  /**\n   * Send a message to the connection.\n   *\n   * Sends a message over the WebSocket connection.\n   * Implementations should dispatch a MessageSent event after sending.\n   *\n   * @param message - The message to send\n   *\n   * @abstract\n   */\n  abstract send(message: string): void;\n\n  /**\n   * Send a control frame to the connection.\n   *\n   * Sends a WebSocket control frame (PING, PONG, or CLOSE).\n   * Default is PING frame for connection health checks.\n   *\n   * @param type - The frame opcode (default: PING)\n   *\n   * @abstract\n   */\n  abstract control(type?: FrameOpcode): void;\n\n  /**\n   * Terminate a connection.\n   *\n   * Closes the underlying WebSocket connection.\n   * This is the final operation on a connection.\n   *\n   * @abstract\n   */\n  abstract terminate(): void;\n\n  /**\n   * Get the application the connection belongs to.\n   *\n   * @returns The Application instance\n   */\n  app(): Application {\n    return this.application;\n  }\n\n  /**\n   * Get the origin of the connection.\n   *\n   * @returns The connection origin or null\n   */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 79,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 79,
                        "column": 8
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export ",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns the underlying WebSocket connection's identifier.",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is typically a raw socket ID or resource identifier.",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The raw connection identifier as a string",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "  abstract identifier(): string;",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the normalized socket ID.",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns a Pusher-compatible socket ID (format: \"number.number\").",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   * This ID is generated once and cached for the connection lifetime.",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The normalized socket ID (e.g., \"123456789.987654321\")",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "  abstract id(): string;",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   * Send a message to the connection.",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   * Sends a message over the WebSocket connection.",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * Implementations should dispatch a MessageSent event after sending.",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The message to send",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "  abstract send(message: string): void;",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "   * Send a control frame to the connection.",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "   * Sends a WebSocket control frame (PING, PONG, or CLOSE).",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "   * Default is PING frame for connection health checks.",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The frame opcode (default: PING)",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "  abstract control(type?: FrameOpcode): void;",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   * Terminate a connection.",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * Closes the underlying WebSocket connection.",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is the final operation on a connection.",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "  abstract terminate(): void;",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the application the connection belongs to.",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The Application instance",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "  app(): Application {",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "    return this.application;",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the origin of the connection.",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The connection origin or null",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 199,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4433068037033081
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/websocket-connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 41,
                    "column": 3
                  }
                },
                "contents": "import type { WebSocket } from \"bun\";\n\n/**\n * WebSocketConnection Interface\n *\n * Low-level transport interface for WebSocket connections.\n * This interface abstracts the underlying WebSocket implementation details\n * and provides a consistent API for connection management, message sending,\n * and lifecycle control.\n *\n * In the PHP implementation, this is implemented by `Servers/Reverb/Connection`\n * which wraps the Ratchet WebSocket server. In the TypeScript implementation,\n * this will wrap Bun's native WebSocket server.\n *\n * @see {@link https://bun.sh/docs/api/websockets Bun WebSocket API}\n */\n\n/**\n * Frame opcodes for WebSocket control frames.\n * Based on RFC 6455 WebSocket Protocol.\n *\n * @see {@link https://datatracker.ietf.org/doc/html/rfc6455#section-11.8 RFC 6455 Opcodes}\n */\nexport enum FrameOpcode {\n  /** Continuation frame (0x0) */\n  CONTINUATION = 0x0,\n  /** Text frame (0x1) */\n  TEXT = 0x1,\n  /** Binary frame (0x2) */\n  BINARY = 0x2,\n  /** Connection close frame (0x8) */\n  CLOSE = 0x8,\n  /** Ping frame (0x9) */\n  PING = 0x9,\n  /** Pong frame (0xA) */\n  PONG = 0xa,\n}\n\n/**\n * Represents a WebSocket frame for control messages.\n * Used for sending PING, PONG, and CLOSE frames.\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { WebSocket } from \"bun\";",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocketConnection Interface",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * Low-level transport interface for WebSocket connections.",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * This interface abstracts the underlying WebSocket implementation details",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * and provides a consistent API for connection management, message sending,",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * and lifecycle control.",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * In the PHP implementation, this is implemented by `Servers/Reverb/Connection`",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * which wraps the Ratchet WebSocket server. In the TypeScript implementation,",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * this will wrap Bun's native WebSocket server.",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * @see {@link https://bun.sh/docs/api/websockets Bun WebSocket API}",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Frame opcodes for WebSocket control frames.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * Based on RFC 6455 WebSocket Protocol.",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * @see {@link https://datatracker.ietf.org/doc/html/rfc6455#section-11.8 RFC 6455 Opcodes}",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "export enum FrameOpcode {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Continuation frame (0x0) */",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  CONTINUATION = 0x0,",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Text frame (0x1) */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  TEXT = 0x1,",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Binary frame (0x2) */",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  BINARY = 0x2,",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Connection close frame (0x8) */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  CLOSE = 0x8,",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Ping frame (0x9) */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  PING = 0x9,",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Pong frame (0xA) */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "  PONG = 0xa,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * Represents a WebSocket frame for control messages.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * Used for sending PING, PONG, and CLOSE frames.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 42,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.42949169874191284
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/websocket-connection.ts",
                "range": {
                  "startPosition": {
                    "line": 79,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 167,
                    "column": 1
                  }
                },
                "contents": "export interface IWebSocketConnection {\n\n  id(): number | string;\n\n  /**\n   * Send a message or frame to the connection.\n   *\n   * This method handles both regular messages (strings/buffers) and control frames.\n   * When sending a Frame object, the implementation should extract the frame contents\n   * and transmit them according to the WebSocket protocol.\n   *\n   * For regular messages, the implementation may wrap them in appropriate WebSocket\n   * frames (TEXT or BINARY) based on the content type.\n   *\n   * @param message - The message to send. Can be:\n   *   - string: Text message (will be sent as TEXT frame)\n   *   - Buffer: Binary message (will be sent as BINARY frame)\n   *   - Frame: Control frame (PING, PONG, CLOSE)\n   *\n   * @throws Error if the connection is closed or invalid\n   *\n   * @example\n   * ```typescript\n   * // Send a text message\n   * connection.send(\"Hello, client!\");\n   *\n   * // Send a binary message\n   * connection.send(Buffer.from([0x01, 0x02, 0x03]));\n   *\n   * // Send a PING frame\n   * connection.send({\n   *   payload: \"\",\n   *   opcode: FrameOpcode.PING,\n   *   getContents: () => Buffer.from(\"\")\n   * });\n   * ```\n   */\n  send(message: string | Buffer | Frame): void;\n\n  /**\n   * Close the WebSocket connection.\n   *\n   * Gracefully terminates the connection. If a message is provided, it will be\n   * sent as a CLOSE frame before closing the connection. The message can be a\n   * Frame object with a CLOSE opcode, or a string/buffer that will be wrapped\n   * in a CLOSE frame.\n   *\n   * After calling this method, the connection should be considered terminated\n   * and no further messages should be sent or received.\n   *\n   * @param message - Optional close message or frame. Can be:\n   *   - undefined: Close without a message\n   *   - string: Close message (will be sent as CLOSE frame)\n   *   - Buffer: Close message (will be sent as CLOSE frame)\n   *   - Frame: Close frame with custom opcode and payload\n   *\n   * @example\n   * ```typescript\n   * // Close without a message\n   * connection.close();\n   *\n   * // Close with a message\n   * connection.close(\"Server shutting down\");\n   *\n   * // Close with a custom frame\n   * connection.close({\n   *   payload: \"Protocol violation\",\n   *   opcode: FrameOpcode.CLOSE,\n   *   getContents: () => Buffer.from(\"Protocol violation\")\n   * });\n   * ```\n   */\n;\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 80,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 80,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 80,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 81,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export interface IWebSocketConnection {",
                    "lineNumber": 80,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "  id(): number | string;",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   * Send a message or frame to the connection.",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method handles both regular messages (strings/buffers) and control frames.",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * When sending a Frame object, the implementation should extract the frame contents",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   * and transmit them according to the WebSocket protocol.",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * For regular messages, the implementation may wrap them in appropriate WebSocket",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * frames (TEXT or BINARY) based on the content type.",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The message to send. Can be:",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - string: Text message (will be sent as TEXT frame)",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Buffer: Binary message (will be sent as BINARY frame)",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Frame: Control frame (PING, PONG, CLOSE)",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Error if the connection is closed or invalid",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a text message",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(\"Hello, client!\");",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a binary message",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(Buffer.from([0x01, 0x02, 0x03]));",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a PING frame",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send({",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "   *   payload: \"\",",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "   *   opcode: FrameOpcode.PING,",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "   *   getContents: () => Buffer.from(\"\")",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * });",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "  send(message: string | Buffer | Frame): void;",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "   * Close the WebSocket connection.",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gracefully terminates the connection. If a message is provided, it will be",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "   * sent as a CLOSE frame before closing the connection. The message can be a",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "   * Frame object with a CLOSE opcode, or a string/buffer that will be wrapped",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "   * in a CLOSE frame.",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "   * After calling this method, the connection should be considered terminated",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "   * and no further messages should be sent or received.",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - Optional close message or frame. Can be:",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - undefined: Close without a message",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - string: Close message (will be sent as CLOSE frame)",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Buffer: Close message (will be sent as CLOSE frame)",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Frame: Close frame with custom opcode and payload",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Close without a message",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.close();",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Close with a message",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.close(\"Server shutting down\");",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Close with a custom frame",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.close({",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "   *   payload: \"Protocol violation\",",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "   *   opcode: FrameOpcode.CLOSE,",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "   *   getContents: () => Buffer.from(\"Protocol violation\")",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "   * });",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 167,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 168,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4248215854167938
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 81,
                    "column": 12
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Servers\\Reverb;\n\nuse Evenement\\EventEmitter;\nuse Laravel\\Reverb\\Contracts\\WebSocketConnection;\nuse Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection as HttpConnection;\nuse Ratchet\\RFC6455\\Messaging\\CloseFrameChecker;\nuse Ratchet\\RFC6455\\Messaging\\DataInterface;\nuse Ratchet\\RFC6455\\Messaging\\Frame;\nuse Ratchet\\RFC6455\\Messaging\\FrameInterface;\nuse Ratchet\\RFC6455\\Messaging\\MessageBuffer;\n\nclass Connection extends EventEmitter implements WebSocketConnection\n{\n    /**\n     * The message buffer.\n     *\n     * @var \\Ratchet\\RFC6455\\Messaging\\MessageBuffer\n     */\n    protected $buffer;\n\n    /**\n     * The message handler.\n     *\n     * @var ?callable\n     */\n    protected $onMessage;\n\n    /**\n     * The control frame handler.\n     *\n     * @var ?callable\n     */\n    protected $onControl;\n\n    /**\n     * The connection close handler.\n     *\n     * @var ?callable\n     */\n    protected $onClose;\n\n    /**\n     * The maximum number of allowed bytes for each message.\n     *\n     * @var int\n     */\n    protected $maxMessageSize;\n\n    /**\n     * Create a new websocket connection instance.\n     */\n    public function __construct(public HttpConnection $connection)\n    {\n        //\n    }\n\n    /**\n     * Undocumented function\n     */\n    public function openBuffer(): void\n    {\n        $this->buffer = new MessageBuffer(\n            new CloseFrameChecker,\n            maxMessagePayloadSize: $this->maxMessageSize,\n            onMessage: $this->onMessage ?: fn () => null,\n            onControl: fn (FrameInterface $message) => $this->control($message),\n            sender: [$this->connection, 'send']\n        );\n\n        $this->connection->on('data', [$this->buffer, 'onData']);\n        $this->connection->on('close', $this->onClose ?: fn () => null);\n    }\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send(mixed $message): void\n    {\n        $this->connection->send(\n            ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Servers\\Reverb;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Evenement\\EventEmitter;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Contracts\\WebSocketConnection;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection as HttpConnection;",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\CloseFrameChecker;",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\DataInterface;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\Frame;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\FrameInterface;",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\MessageBuffer;",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "class Connection extends EventEmitter implements WebSocketConnection",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     * The message buffer.",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var \\Ratchet\\RFC6455\\Messaging\\MessageBuffer",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $buffer;",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "     * The message handler.",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onMessage;",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "     * The control frame handler.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onControl;",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "     * The connection close handler.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onClose;",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "     * The maximum number of allowed bytes for each message.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var int",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $maxMessageSize;",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new websocket connection instance.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(public HttpConnection $connection)",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "        //",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "     * Undocumented function",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    public function openBuffer(): void",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer = new MessageBuffer(",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "            new CloseFrameChecker,",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "            maxMessagePayloadSize: $this->maxMessageSize,",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "            onMessage: $this->onMessage ?: fn () => null,",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "            onControl: fn (FrameInterface $message) => $this->control($message),",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "            sender: [$this->connection, 'send']",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->on('data', [$this->buffer, 'onData']);",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->on('close', $this->onClose ?: fn () => null);",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send(mixed $message): void",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->send(",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "            ",
                    "lineNumber": 82,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.41194605827331543
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 69,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb;\n\nuse Laravel\\Reverb\\Concerns\\GeneratesIdentifiers;\nuse Laravel\\Reverb\\Contracts\\Connection as ConnectionContract;\nuse Laravel\\Reverb\\Events\\MessageSent;\nuse Ratchet\\RFC6455\\Messaging\\Frame;\n\nclass Connection extends ConnectionContract\n{\n    use GeneratesIdentifiers;\n\n    /**\n     * The normalized socket ID.\n     */\n    protected ?string $id = null;\n\n    /**\n     * Stores the ping state of the connection.\n     */\n    protected $hasBeenPinged = false;\n\n    /**\n     * Get the raw socket connection identifier.\n     */\n    public function identifier(): string\n    {\n        return (string) $this->connection->id();\n    }\n\n    /**\n     * Get the normalized socket ID.\n     */\n    public function id(): string\n    {\n        if (! $this->id) {\n            $this->id = $this->generateId();\n        }\n\n        return $this->id;\n    }\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send(string $message): void\n    {\n        $this->connection->send($message);\n\n        MessageSent::dispatch($this, $message);\n    }\n\n    /**\n     * Send a control frame to the connection.\n     */\n    public function control(string $type = Frame::OP_PING): void\n    {\n        $this->connection->send(new Frame('', opcode: $type));\n    }\n\n    /**\n     * Terminate a connection.\n     */\n    public function terminate(): void\n    {\n        $this->connection->close();\n    }\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Concerns\\GeneratesIdentifiers;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Contracts\\Connection as ConnectionContract;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Events\\MessageSent;",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\Frame;",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "class Connection extends ConnectionContract",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "    use GeneratesIdentifiers;",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "     * The normalized socket ID.",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "    protected ?string $id = null;",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "     * Stores the ping state of the connection.",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $hasBeenPinged = false;",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the raw socket connection identifier.",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "    public function identifier(): string",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "        return (string) $this->connection->id();",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the normalized socket ID.",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "    public function id(): string",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "        if (! $this->id) {",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->id = $this->generateId();",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->id;",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send(string $message): void",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->send($message);",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "        MessageSent::dispatch($this, $message);",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a control frame to the connection.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    public function control(string $type = Frame::OP_PING): void",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->send(new Frame('', opcode: $type));",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "     * Terminate a connection.",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    public function terminate(): void",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->close();",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 69,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.40902864933013916
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "notes/2025-11-13-1300-review-fixes.md",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 37,
                    "column": 0
                  }
                },
                "contents": "# Review Fixes - 2025-11-13\n\n## Status: ✅ All Issues Resolved\n\nFixed all review feedback from `specs/review.md`:\n\n### 1. Fixed Factory.createHttpConnection() Type Issues\n- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface\n- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 2. Fixed Factory.convertToHttpRequest() Headers Property\n- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)\n- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 3. Fixed EventsBatchController Connection Type\n- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)\n- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers\n- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`\n\n### 4. Fixed All `any` Type Violations in Tests\n- **Problem**: 9 `noExplicitAny` lint violations across test suite\n- **Solution**: Replaced all `any` types with proper types:\n  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)\n  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`\n  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)\n  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)\n- **Files**: \n  - `tests/unit/channels/channel.test.ts`\n  - `tests/e2e/websocket-connection.test.ts`\n  - `tests/feature/health-check-controller.test.ts`\n  - `tests/unit/events/event-dispatcher.test.ts`\n\n## Verification\n- ✅ `bun run typecheck` - Passes\n- ✅ `bun run lint` - No violations",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "# Review Fixes - 2025-11-13",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "## Status: ✅ All Issues Resolved",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "Fixed all review feedback from `specs/review.md`:",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "### 1. Fixed Factory.createHttpConnection() Type Issues",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "### 2. Fixed Factory.convertToHttpRequest() Headers Property",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "### 3. Fixed EventsBatchController Connection Type",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "### 4. Fixed All `any` Type Violations in Tests",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: 9 `noExplicitAny` lint violations across test suite",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Replaced all `any` types with proper types:",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: ",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/channels/channel.test.ts`",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/e2e/websocket-connection.test.ts`",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/feature/health-check-controller.test.ts`",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/events/event-dispatcher.test.ts`",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "## Verification",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run typecheck` - Passes",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run lint` - No violations",
                    "lineNumber": 37,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.36611616611480713
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 37,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 57,
                    "column": 1
                  }
                },
                "contents": "/**\n * Connection data structure.\n */\nexport interface ConnectionData {\n  /** User identifier */\n  user_id: string;\n  /** Additional connection metadata */\n  [key: string]: unknown;\n}\n\n/**\n * Channel interface for metrics gathering.\n */\nexport interface Channel {\n  /** Get the channel name */\n  name(): string\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection data structure.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ConnectionData {",
                    "lineNumber": 43,
                    "isSignature": true
                  },
                  {
                    "text": "  /** User identifier */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "  user_id: string;",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Additional connection metadata */",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  [key: string]: unknown;",
                    "lineNumber": 47,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 48,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel interface for metrics gathering.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "export interface Channel {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get the channel name */",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  name(): string",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2969580888748169
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 47,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 65,
                    "column": 1
                  }
                },
                "contents": "/**\n * Channel interface for metrics gathering.\n */\nexport interface Channel {\n  /** Get the channel name */\n  name(): string;\n  /** Get all connections to the channel */\n  connections(): Record<string, ChannelConnection>;\n}\n\n/**\n * Channel manager interface for accessing channels.\n */\nexport interface ChannelManager {\n  /** Get channel manager for a specific application */\n  for(application: Application): ApplicationChannelManager;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel interface for metrics gathering.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "export interface Channel {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get the channel name */",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  name(): string;",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Get all connections to the channel */",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  connections(): Record<string, ChannelConnection>;",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel manager interface for accessing channels.",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelManager {",
                    "lineNumber": 63,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get channel manager for a specific application */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "  for(application: Application): ApplicationChannelManager;",
                    "lineNumber": 65,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 66,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.251120388507843
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 62,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 85,
                    "column": 1
                  }
                },
                "contents": ";\n}\n\n/**\n * Application-specific channel manager interface.\n */\nexport interface ApplicationChannelManager {\n  /** Get all channels */\n  all(): Record<string, Channel>;\n  /** Find a specific channel by name */\n  find(name: string): Channel | null;\n  /** Get all connections for the application */\n  connections(): Record<string, unknown>;\n}\n\n/**\n * Server provider manager interface.\n */\nexport interface ServerProviderManager {\n  /** Check if the server subscribes to events */\n  subscribesToEvents(): boolean;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": ";",
                    "lineNumber": 65,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 66,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-specific channel manager interface.",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ApplicationChannelManager {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get all channels */",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "  all(): Record<string, Channel>;",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Find a specific channel by name */",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "  find(name: string): Channel | null;",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Get all connections for the application */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "  connections(): Record<string, unknown>;",
                    "lineNumber": 77,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 78,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": " * Server provider manager interface.",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ServerProviderManager {",
                    "lineNumber": 83,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Check if the server subscribes to events */",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "  subscribesToEvents(): boolean;",
                    "lineNumber": 85,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 86,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2220158576965332
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 24,
                    "column": 1
                  }
                },
                "contents": "import type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport { dispatch } from \"../../event-dispatcher\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * Batch item structure\n */\ninterface BatchItem {\n  name: string;\n  channel: string;\n  data: string;\n  socket_id?: string;\n  info?: string;\n}\n\n/**\n * Validation error structure\n */\ninterface ValidationErrors {\n  [key: string]: string[];\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import { dispatch } from \"../../event-dispatcher\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Batch item structure",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "interface BatchItem {",
                    "lineNumber": 12,
                    "isSignature": true
                  },
                  {
                    "text": "  name: string;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  channel: string;",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  data: string;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "  socket_id?: string;",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string;",
                    "lineNumber": 17,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 18,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * Validation error structure",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "interface ValidationErrors {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  [key: string]: string[];",
                    "lineNumber": 24,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 25,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.21084213256835938
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\nconst ;\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map((item) => {\n      // Dispatch the event\n      const channelConnection = item.socket_id\n        ? (channels.connections()[item.socket_id] ?? null)\n        : null;\n      const excludeConnection = channelConnection\n        ? channelConnection.connection()\n        : null;\n\n      dispatch(\n        application,\n        {\n          event: item.name,\n          channel: item.channel,\n          data: item.data,\n        },\n        channels,\n        excludeConnection,\n      );\n\n      // Return promise for metrics gathering if requested\n      return item.info\n        ? this.metricsHandler.gather(application, \"channel\", {\n            channel: item.channel,\n            info: item.info,\n          })\n        : Promise.resolve({});\n    });\n\n    // Check if any items requested metrics\n    const hasMetrics = batch.some((item) => item.info);\n\n    if (hasMetrics) {\n      // Wait for all metrics to be gathered\n      const results = await Promise.all(items);\n      return new Response({\n        batch: results.map((result) => result || {}),\n      });\n    }\n\n    // No metrics requested, return empty batch object\n    return new Response({ batch: {} });\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    },
                    {
                      "startPosition": {
                        "line": 95,
                        "column": 3
                      },
                      "endPosition": {
                        "line": 102,
                        "column": 5
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "const ;",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map((item) => {",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      // Dispatch the event",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelConnection = item.socket_id",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "        ? (channels.connections()[item.socket_id] ?? null)",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "      const excludeConnection = channelConnection",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "        ? channelConnection.connection()",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      dispatch(",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "        application,",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "          event: item.name,",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "          channel: item.channel,",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "          data: item.data,",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "        excludeConnection,",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "      // Return promise for metrics gathering if requested",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return item.info",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "        ? this.metricsHandler.gather(application, \"channel\", {",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "            channel: item.channel,",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "            info: item.info,",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "          })",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "        : Promise.resolve({});",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if any items requested metrics",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    const hasMetrics = batch.some((item) => item.info);",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    if (hasMetrics) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      // Wait for all metrics to be gathered",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      const results = await Promise.all(items);",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "        batch: results.map((result) => result || {}),",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // No metrics requested, return empty batch object",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ batch: {} });",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.18335750699043274
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 82,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 115,
                    "column": 1
                  }
                },
                "contents": ";\n}\n\n/**\n * PubSub provider interface for distributed metrics.\n */\nexport interface PubSubProvider {\n  /**\n   * Publish a message to all subscribers.\n   * @returns Promise resolving to the number of subscribers\n   */\n  publish(message: PubSubMessage): Promise<number>;\n\n  /**\n   * Subscribe to events from other servers.\n   */\n  on(event: string, handler: (payload: unknown) => void): void;\n}\n\n/**\n * PubSub message structure.\n */\nexport interface PubSubMessage {\n  /** Message type */\n  type: string\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": ";",
                    "lineNumber": 85,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 86,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": " * PubSub provider interface for distributed metrics.",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "export interface PubSubProvider {",
                    "lineNumber": 91,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * Publish a message to all subscribers.",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the number of subscribers",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "  publish(message: PubSubMessage): Promise<number>;",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "   * Subscribe to events from other servers.",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  on(event: string, handler: (payload: unknown) => void): void;",
                    "lineNumber": 101,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 102,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": " * PubSub message structure.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "export interface PubSubMessage {",
                    "lineNumber": 107,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Message type */",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "  type: string",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 115,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 116,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.16199429333209991
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 115,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "/**\n * Metrics handler for gathering channel and connection statistics.\n *\n * This class handles metrics collection for Pusher-compatible channels,\n * supporting both single-server and distributed (multi-server) deployments.\n *\n * In distributed mode, it coordinates metrics gathering across all servers\n * using the PubSub provider with a timeout-based collection strategy.\n *\n * Metrics Types:\n * - channel: Information about a specific channel\n * - channels: Information about multiple channels\n * - channel_users: List of unique users in a presence channel\n * - connections: All connections for an application\n */\nexport class MetricsHandler {\n  /**\n   * The metrics being gathered from subscribers.\n   */\n  protected metrics: unknown[] = [];\n\n  /**\n   * The total number of subscribers gathering metrics.\n   */\n  protected subscribers: number | null = null;\n\n  /**\n   * Create an instance of the metrics handler.\n   */\n  constructor(\n    protected serverProviderManager: ServerProviderManager,\n    protected channels: ChannelManager,\n    protected pubSubProvider: PubSubProvider | null,\n  ) {}\n\n  /**\n   * Gather the metrics for the given type.\n   *\n   * @param application - The application to gather metrics for\n   * @param type - The type of metrics to gather\n   * @param options - Additional options for the metrics request\n   * @returns Promise resolving to the metrics data\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics handler for gathering channel and connection statistics.",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": " * This class handles metrics collection for Pusher-compatible channels,",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": " * supporting both single-server and distributed (multi-server) deployments.",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": " * In distributed mode, it coordinates metrics gathering across all servers",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": " * using the PubSub provider with a timeout-based collection strategy.",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics Types:",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": " * - channel: Information about a specific channel",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": " * - channels: Information about multiple channels",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": " * - channel_users: List of unique users in a presence channel",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": " * - connections: All connections for an application",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "   * The metrics being gathered from subscribers.",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "  protected metrics: unknown[] = [];",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "   * The total number of subscribers gathering metrics.",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "  protected subscribers: number | null = null;",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create an instance of the metrics handler.",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "    protected serverProviderManager: ServerProviderManager,",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "    protected channels: ChannelManager,",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "    protected pubSubProvider: PubSubProvider | null,",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gather the metrics for the given type.",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to gather metrics for",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to gather",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the metrics data",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.14410585165023804
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 52,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 77,
                    "column": 1
                  }
                },
                "contents": ";\n}\n\n/**\n * Channel manager interface for accessing channels.\n */\nexport interface ChannelManager {\n  /** Get channel manager for a specific application */\n  for(application: Application): ApplicationChannelManager;\n}\n\n/**\n * Application-specific channel manager interface.\n */\nexport interface ApplicationChannelManager {\n  /** Get all channels */\n  all(): Record<string, Channel>\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": ";",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel manager interface for accessing channels.",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelManager {",
                    "lineNumber": 63,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get channel manager for a specific application */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "  for(application: Application): ApplicationChannelManager;",
                    "lineNumber": 65,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 66,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-specific channel manager interface.",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ApplicationChannelManager {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get all channels */",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "  all(): Record<string, Channel>",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 77,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 78,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.13403594493865967
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\n\n\n  /**\n   * Handle the batch events request.\n   *\n   * This method:\n   * 1. Parses and validates the request body\n   * 2. Dispatches each event to its channel\n   * 3. Gathers metrics for events that request channel info\n   * 4. Returns the batch results\n   *\n   * @param request - The HTTP request object\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from route parameters\n   * @param application - The verified application instance\n   * @param channels - The channel manager scoped to the application\n   * @returns Response object with batch results\n   */\n  async handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\n    // Parse request body\n    const body = this.getBody(request);\n    let payload: unknown;\n\n    try {\n      payload = JSON.parse(body) as { batch?: BatchItem[] };\n    } catch (_error) {\n      return new Response(\n        {\n          message: \"Invalid JSON in request body\",\n          errors: { body: [\"The body must be valid JSON\"] },\n        },\n        422,\n      );\n    }\n\n    // Validate payload\n    const validationErrors = this.validate(payload);\n    if (validationErrors) {\n      return new Response(\n        { message: \"Validation failed\", errors: validationErrors },\n        422,\n      );\n    }\n\n    const typedPayload = payload as { batch: BatchItem[] };\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map\n;\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the batch events request.",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Dispatches each event to its channel",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Gathers metrics for events that request channel info",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Returns the batch results",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from route parameters",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The verified application instance",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager scoped to the application",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response object with batch results",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse request body",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = this.getBody(request);",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "    let payload: unknown;",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "      payload = JSON.parse(body) as { batch?: BatchItem[] };",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (_error) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "          message: \"Invalid JSON in request body\",",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "          errors: { body: [\"The body must be valid JSON\"] },",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate payload",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "    const validationErrors = this.validate(payload);",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    if (validationErrors) {",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "        { message: \"Validation failed\", errors: validationErrors },",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    const typedPayload = payload as { batch: BatchItem[] };",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.13091790676116943
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Get the connections for the given application.\n   *\n   * @param application - The application\n   * @returns Connection information\n   */\n  protected connections(application: Application): Record<string, unknown> {\n    return this.channels.for(application).connections();\n  }\n\n  /**\n   * Gather metrics from all subscribers for the given type.\n   *\n   * @param application - The application to gather metrics for\n   * @param type - The type of metrics to gather\n   * @param options - Additional options for the metrics request\n   * @returns Promise resolving to the aggregated metrics\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the connections for the given application.",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Connection information",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": "  protected connections(application: Application): Record<string, unknown> {",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": "    return this.channels.for(application).connections();",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 302,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 303,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gather metrics from all subscribers for the given type.",
                    "lineNumber": 304,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 305,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to gather metrics for",
                    "lineNumber": 306,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to gather",
                    "lineNumber": 307,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 308,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the aggregated metrics",
                    "lineNumber": 309,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 310,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12881875038146973
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 53
                  },
                  "endPosition": {
                    "line": 29,
                    "column": 1
                  }
                },
                "contents": "import type { ChannelConnection } from \"./channels/channel-connection\";\n\n/**\n * Metrics collection options for different metric types.\n */\nexport interface MetricsOptions {\n  /** Channel name (for 'channel' and 'channel_users' types) */\n  channel?: string;\n  /** Array of channel names (for 'channels' type) */\n  channels?: string[];\n  /** Info fields to include (comma-separated or array) */\n  info?: string | string[];\n  /** Filter prefix for channel names (for 'channels' type) */\n  filter?: string;\n}\n\n/**\n * Channel information structure.\n */\nexport interface ChannelInfo {\n  /** Whether the channel is occupied (has connections) */\n  occupied?: boolean\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ChannelConnection } from \"./channels/channel-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics collection options for different metric types.",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "export interface MetricsOptions {",
                    "lineNumber": 7,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Channel name (for 'channel' and 'channel_users' types) */",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "  channel?: string;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Array of channel names (for 'channels' type) */",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "  channels?: string[];",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Info fields to include (comma-separated or array) */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string | string[];",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Filter prefix for channel names (for 'channels' type) */",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  filter?: string;",
                    "lineNumber": 15,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 16,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel information structure.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelInfo {",
                    "lineNumber": 21,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Whether the channel is occupied (has connections) */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "  occupied?: boolean",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 30,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12843860685825348
            }
          ]
        }
      }
    }

### Tool · sem Search (completed)

    {
      "args": {
        "query": "What is the IHttpRequest interface definition?",
        "targetDirectories": [],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"src/servers/reverb/http/router.ts\" startLine=\"27\" endLine=\"548\">\n    27|export class Router {\n   ...\n   477|private getStatusText(statusCode: number): string {\n   ...\n   485|\n   486|  }\n   487|}\n   488|\n   489|/**\n   490| * HTTP Request interface\n   491| *\n   492| * Represents an HTTP request object with methods to access headers, method, path, etc.\n   493| */\n   494|export interface IHttpRequest {\n   495|  /**\n   496|   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\n   497|   */\n   498|  method: string;\n   499|\n   500|  /**\n   501|   * Request path with query string - property for direct access\n   502|   */\n   503|  path: string;\n   504|\n   505|  /**\n   506|   * Request body content - property for direct access\n   507|   */\n   508|  body: string;\n   509|\n   510|  /**\n   511|   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n   512|   */\n   513|  getMethod(): string;\n   514|\n   515|  /**\n   516|   * Get the request path\n   517|   */\n   518|  getPath(): string;\n   519|\n   520|  /**\n   521|   * Get the request host\n   522|   */\n   523|  getHost(): string;\n   524|\n   525|  /**\n   526|   * Get a specific header value\n   527|   */\n   528|  getHeader(name: string): string | undefined;\n   529|\n   530|  /**\n   531|   * Get all headers\n   532|   */\n   533|  getHeaders(): Record<string, string>;\n   534|\n   535|  /**\n   536|   * Get the request URI\n   537|   */\n   538|  getUri(): {\n   539|    path: string;\n   540|    host: string;\n   541|  };\n   542|}\n   543|\n   544|/**\n   545| * Route matcher interface\n   546| *\n   547| * Handles route matching and context management\n   548| */\n</search_result>\n<search_result path=\"src/servers/reverb/http/request.ts\" startLine=\"1\" endLine=\"34\">\n     1|/**\n     2| * HTTP Request Parser\n     3| *\n     4| * Handles parsing raw HTTP message strings into Request objects.\n     5| * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.\n     6| */\n     7|\n     8|// Re-export IHttpRequest for use by controllers\n     9|export type { IHttpRequest } from \"./router\";\n    10|\n    11|import type { IHttpRequest } from \"./router\";\n    12|\n    13|/**\n    14| * Extended HTTP Request interface with additional properties for internal use.\n    15| */\n    16|interface IHttpRequestInternal extends IHttpRequest {\n    17|  /** HTTP method (GET, POST, etc.) - property for direct access */\n    18|  method: string;\n    19|  /** Request path with query string - property for direct access */\n    20|  path: string;\n    21|  /** HTTP version (1.0, 1.1, 2.0) */\n    22|  httpVersion: string;\n    23|  /** Headers mapping header names to values */\n    24|  headers: Record<string, string>;\n    25|  /** Request body content */\n    26|  body: string;\n    27|  /** Get body size in bytes */\n    28|  getSize(): number;\n    29|}\n    30|\n    31|/**\n    32| * End of message delimiter per HTTP specification.\n    33| */\n    34|const EOM = \"\\r\\n\\r\\n\";\n</search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-0000.md\" startLine=\"1138\" endLine=\"1255\">\n  1138|    * **path:** `src/Servers/Reverb/Http/router.ts`\n  1139|    * **status:** success\n  1140|        * lines: 420-469\n  1141|    * **content:**\n  1142|\n  1143|    }\n  1144|    \n  1145|    /**\n  1146|     * HTTP Request interface\n  1147|     *\n  1148|     * Represents an HTTP request object with methods to access headers, method, path, etc.\n  1149|     */\n  1150|    export interface IHttpRequest {\n  1151|      /**\n  1152|       * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\n  1153|       */\n  1154|      method: string;\n  1155|    \n  1156|      /**\n  1157|       * Request path with query string - property for direct access\n  1158|       */\n  1159|      path: string;\n  1160|    \n  1161|      /**\n  1162|       * Request body content - property for direct access\n  1163|       */\n  1164|      body: string;\n  1165|    \n  1166|      /**\n  1167|       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n  1168|       */\n  1169|      getMethod(): string;\n  1170|    \n  1171|      /**\n  1172|       * Get the request path\n  1173|       */\n  1174|      getPath(): string;\n  1175|    \n  1176|      /**\n  1177|       * Get the request host\n  1178|       */\n  1179|      getHost(): string;\n  1180|    \n  1181|      /**\n  1182|       * Get a specific header value\n  1183|       */\n  1184|      getHeader(name: string): string | undefined;\n  1185|    \n  1186|      /**\n  1187|       * Get all headers\n  1188|       */\n  1189|      getHeaders(): Record<string, string>;\n  1190|    \n  1191|      /**\n  1192|       * Get the request URI\n  1193|\n  1194|### Tool · read (started)\n  1195|\n  1196|    * **path:** `src/Servers/Reverb/Http/request.ts`\n  1197|    * **status:** pending\n  1198|\n  1199|### Tool · read (completed)\n  1200|\n  1201|    * **path:** `src/Servers/Reverb/Http/request.ts`\n  1202|    * **status:** success\n  1203|        * lines: 1-261\n  1204|    * **content:**\n  1205|\n  1206|    /**\n  1207|     * HTTP Request Parser\n  1208|     *\n  1209|     * Handles parsing raw HTTP message strings into Request objects.\n  1210|     * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.\n  1211|     */\n  1212|    \n  1213|    // Re-export IHttpRequest for use by controllers\n  1214|    export type { IHttpRequest } from './router';\n  1215|    \n  1216|    import type { IHttpRequest } from './router';\n  1217|    \n  1218|    /**\n  1219|     * Extended HTTP Request interface with additional properties for internal use.\n  1220|     */\n  1221|    interface IHttpRequestInternal extends IHttpRequest {\n  1222|      /** HTTP method (GET, POST, etc.) - property for direct access */\n  1223|      method: string;\n  1224|      /** Request path with query string - property for direct access */\n  1225|      path: string;\n  1226|      /** HTTP version (1.0, 1.1, 2.0) */\n  1227|      httpVersion: string;\n  1228|      /** Headers mapping header names to values */\n  1229|      headers: Record<string, string>;\n  1230|      /** Request body content */\n  1231|      body: string;\n  1232|      /** Get body size in bytes */\n  1233|      getSize(): number;\n  1234|    }\n  1235|    \n  1236|    /**\n  1237|     * HTTP Request class for parsing and managing HTTP requests.\n  1238|     *\n  1239|     * Parses raw HTTP message strings according to HTTP specification.\n  1240|     * Handles buffer management with configurable size limits.\n  1241|     * Validates Content-Length headers to ensure complete message receipt.\n  1242|     *\n  1243|     * @class Request\n  1244|     */\n  1245|    class Request {\n  1246|      /**\n  1247|       * End of message delimiter per HTTP specification.\n  1248|       *\n  1249|       * @private\n  1250|       * @readonly\n  1251|       */\n  1252|      private static readonly EOM = '\\r\\n\\r\\n';\n  1253|    \n  1254|      /**\n  1255|       * Parse a raw HTTP message string into a Request object.\n</search_result>\n\n<search_result path=\"src/servers/reverb/http/server.ts\" showSignaturesOnly=\"true\" startLine=\"40\" endLine=\"448\">\n   41|export class Server {\n</search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2339.md\" startLine=\"8116\" endLine=\"8201\"></search_result>\n<search_result path=\"src/servers/reverb/factory.ts\" showSignaturesOnly=\"true\" startLine=\"189\" endLine=\"1272\">\n  190|export class Factory {\n</search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2339.md\" startLine=\"9247\" endLine=\"9341\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" showSignaturesOnly=\"true\" startLine=\"70\" endLine=\"301\">\n   71|export class EventsBatchController {\n</search_result>\n<search_result path=\"notes/2025-11-13-1300-review-fixes.md\" endLine=\"37\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" endLine=\"24\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" showSignaturesOnly=\"true\" startLine=\"70\" endLine=\"280\">\n   71|export class EventsBatchController {\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"101\" endLine=\"131\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"47\" endLine=\"65\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"82\" endLine=\"115\">\n   85|;\n   86|}\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"62\" endLine=\"85\">\n   65|;\n   66|}\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" showSignaturesOnly=\"true\" startLine=\"70\" endLine=\"314\">\n   71|export class EventsBatchController {\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" endLine=\"29\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" startLine=\"24\" endLine=\"280\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"37\" endLine=\"57\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"132\" endLine=\"737\">\n  133|export class MetricsHandler {\n</search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/router.ts",
                "range": {
                  "startPosition": {
                    "line": 26,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 547,
                    "column": 3
                  }
                },
                "contents": "export class Router {\nprivate getStatusText(statusCode: number): string {\n\n  }\n}\n\n/**\n * HTTP Request interface\n *\n * Represents an HTTP request object with methods to access headers, method, path, etc.\n */\nexport interface IHttpRequest {\n  /**\n   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\n   */\n  method: string;\n\n  /**\n   * Request path with query string - property for direct access\n   */\n  path: string;\n\n  /**\n   * Request body content - property for direct access\n   */\n  body: string;\n\n  /**\n   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n   */\n  getMethod(): string;\n\n  /**\n   * Get the request path\n   */\n  getPath(): string;\n\n  /**\n   * Get the request host\n   */\n  getHost(): string;\n\n  /**\n   * Get a specific header value\n   */\n  getHeader(name: string): string | undefined;\n\n  /**\n   * Get all headers\n   */\n  getHeaders(): Record<string, string>;\n\n  /**\n   * Get the request URI\n   */\n  getUri(): {\n    path: string;\n    host: string;\n  };\n}\n\n/**\n * Route matcher interface\n *\n * Handles route matching and context management\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "export class Router {",
                    "lineNumber": 27,
                    "isSignature": true
                  },
                  {
                    "text": "private getStatusText(statusCode: number): string {",
                    "lineNumber": 477,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 485,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 486,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 487,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 488,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 489,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Request interface",
                    "lineNumber": 490,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 491,
                    "isSignature": false
                  },
                  {
                    "text": " * Represents an HTTP request object with methods to access headers, method, path, etc.",
                    "lineNumber": 492,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 493,
                    "isSignature": false
                  },
                  {
                    "text": "export interface IHttpRequest {",
                    "lineNumber": 494,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 495,
                    "isSignature": false
                  },
                  {
                    "text": "   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access",
                    "lineNumber": 496,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 497,
                    "isSignature": false
                  },
                  {
                    "text": "  method: string;",
                    "lineNumber": 498,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 499,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 500,
                    "isSignature": false
                  },
                  {
                    "text": "   * Request path with query string - property for direct access",
                    "lineNumber": 501,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 502,
                    "isSignature": false
                  },
                  {
                    "text": "  path: string;",
                    "lineNumber": 503,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 504,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 505,
                    "isSignature": false
                  },
                  {
                    "text": "   * Request body content - property for direct access",
                    "lineNumber": 506,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 507,
                    "isSignature": false
                  },
                  {
                    "text": "  body: string;",
                    "lineNumber": 508,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 509,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 510,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)",
                    "lineNumber": 511,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 512,
                    "isSignature": false
                  },
                  {
                    "text": "  getMethod(): string;",
                    "lineNumber": 513,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 514,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 515,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request path",
                    "lineNumber": 516,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 517,
                    "isSignature": false
                  },
                  {
                    "text": "  getPath(): string;",
                    "lineNumber": 518,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 519,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 520,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request host",
                    "lineNumber": 521,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 522,
                    "isSignature": false
                  },
                  {
                    "text": "  getHost(): string;",
                    "lineNumber": 523,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 524,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 525,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get a specific header value",
                    "lineNumber": 526,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 527,
                    "isSignature": false
                  },
                  {
                    "text": "  getHeader(name: string): string | undefined;",
                    "lineNumber": 528,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 529,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 530,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get all headers",
                    "lineNumber": 531,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 532,
                    "isSignature": false
                  },
                  {
                    "text": "  getHeaders(): Record<string, string>;",
                    "lineNumber": 533,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 534,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 535,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request URI",
                    "lineNumber": 536,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 537,
                    "isSignature": false
                  },
                  {
                    "text": "  getUri(): {",
                    "lineNumber": 538,
                    "isSignature": false
                  },
                  {
                    "text": "    path: string;",
                    "lineNumber": 539,
                    "isSignature": false
                  },
                  {
                    "text": "    host: string;",
                    "lineNumber": 540,
                    "isSignature": false
                  },
                  {
                    "text": "  };",
                    "lineNumber": 541,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 542,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 543,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 544,
                    "isSignature": false
                  },
                  {
                    "text": " * Route matcher interface",
                    "lineNumber": 545,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 546,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles route matching and context management",
                    "lineNumber": 547,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 548,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.5413514971733093
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/request.ts",
                "range": {
                  "startPosition": {
                    "line": 8,
                    "column": 45
                  },
                  "endPosition": {
                    "line": 33,
                    "column": 23
                  }
                },
                "contents": "import type { IHttpRequest } from \"./router\";\n\n/**\n * Extended HTTP Request interface with additional properties for internal use.\n */\ninterface IHttpRequestInternal extends IHttpRequest {\n  /** HTTP method (GET, POST, etc.) - property for direct access */\n  method: string;\n  /** Request path with query string - property for direct access */\n  path: string;\n  /** HTTP version (1.0, 1.1, 2.0) */\n  httpVersion: string;\n  /** Headers mapping header names to values */\n  headers: Record<string, string>;\n  /** Request body content */\n  body: string;\n  /** Get body size in bytes */\n  getSize(): number;\n}\n\n/**\n * End of message delimiter per HTTP specification.\n */\nconst EOM = \"\\r\\n\\r\\n\";",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IHttpRequest } from \"./router\";",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Extended HTTP Request interface with additional properties for internal use.",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "interface IHttpRequestInternal extends IHttpRequest {",
                    "lineNumber": 16,
                    "isSignature": true
                  },
                  {
                    "text": "  /** HTTP method (GET, POST, etc.) - property for direct access */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "  method: string;",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Request path with query string - property for direct access */",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "  path: string;",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "  /** HTTP version (1.0, 1.1, 2.0) */",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "  httpVersion: string;",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Headers mapping header names to values */",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "  headers: Record<string, string>;",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Request body content */",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  body: string;",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Get body size in bytes */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  getSize(): number;",
                    "lineNumber": 28,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " * End of message delimiter per HTTP specification.",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "const EOM = \"\\r\\n\\r\\n\";",
                    "lineNumber": 34,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.5014863014221191
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/request.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 10,
                    "column": 45
                  }
                },
                "contents": "/**\n * HTTP Request Parser\n *\n * Handles parsing raw HTTP message strings into Request objects.\n * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.\n */\n\n// Re-export IHttpRequest for use by controllers\nexport type { IHttpRequest } from \"./router\";\n\nimport type { IHttpRequest } from \"./router\";",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Request Parser",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles parsing raw HTTP message strings into Request objects.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "// Re-export IHttpRequest for use by controllers",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "export type { IHttpRequest } from \"./router\";",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"./router\";",
                    "lineNumber": 11,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4655666947364807
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-0000.md",
                "range": {
                  "startPosition": {
                    "line": 1199,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1255,
                    "column": 0
                  }
                },
                "contents": "    * **path:** `src/Servers/Reverb/Http/request.ts`\n    * **status:** success\n        * lines: 1-261\n    * **content:**\n\n    /**\n     * HTTP Request Parser\n     *\n     * Handles parsing raw HTTP message strings into Request objects.\n     * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.\n     */\n    \n    // Re-export IHttpRequest for use by controllers\n    export type { IHttpRequest } from './router';\n    \n    import type { IHttpRequest } from './router';\n    \n    /**\n     * Extended HTTP Request interface with additional properties for internal use.\n     */\n    interface IHttpRequestInternal extends IHttpRequest {\n      /** HTTP method (GET, POST, etc.) - property for direct access */\n      method: string;\n      /** Request path with query string - property for direct access */\n      path: string;\n      /** HTTP version (1.0, 1.1, 2.0) */\n      httpVersion: string;\n      /** Headers mapping header names to values */\n      headers: Record<string, string>;\n      /** Request body content */\n      body: string;\n      /** Get body size in bytes */\n      getSize(): number;\n    }\n    \n    /**\n     * HTTP Request class for parsing and managing HTTP requests.\n     *\n     * Parses raw HTTP message strings according to HTTP specification.\n     * Handles buffer management with configurable size limits.\n     * Validates Content-Length headers to ensure complete message receipt.\n     *\n     * @class Request\n     */\n    class Request {\n      /**\n       * End of message delimiter per HTTP specification.\n       *\n       * @private\n       * @readonly\n       */\n      private static readonly EOM = '\\r\\n\\r\\n';\n    \n      /**\n       * Parse a raw HTTP message string into a Request object.",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    * **path:** `src/Servers/Reverb/Http/request.ts`",
                    "lineNumber": 1201,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 1202,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 1-261",
                    "lineNumber": 1203,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 1204,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1205,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 1206,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Request Parser",
                    "lineNumber": 1207,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1208,
                    "isSignature": false
                  },
                  {
                    "text": "     * Handles parsing raw HTTP message strings into Request objects.",
                    "lineNumber": 1209,
                    "isSignature": false
                  },
                  {
                    "text": "     * Implements HTTP message buffering with size limits and End-Of-Message (EOM) detection.",
                    "lineNumber": 1210,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 1211,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1212,
                    "isSignature": false
                  },
                  {
                    "text": "    // Re-export IHttpRequest for use by controllers",
                    "lineNumber": 1213,
                    "isSignature": false
                  },
                  {
                    "text": "    export type { IHttpRequest } from './router';",
                    "lineNumber": 1214,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1215,
                    "isSignature": false
                  },
                  {
                    "text": "    import type { IHttpRequest } from './router';",
                    "lineNumber": 1216,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1217,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 1218,
                    "isSignature": false
                  },
                  {
                    "text": "     * Extended HTTP Request interface with additional properties for internal use.",
                    "lineNumber": 1219,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 1220,
                    "isSignature": false
                  },
                  {
                    "text": "    interface IHttpRequestInternal extends IHttpRequest {",
                    "lineNumber": 1221,
                    "isSignature": false
                  },
                  {
                    "text": "      /** HTTP method (GET, POST, etc.) - property for direct access */",
                    "lineNumber": 1222,
                    "isSignature": false
                  },
                  {
                    "text": "      method: string;",
                    "lineNumber": 1223,
                    "isSignature": false
                  },
                  {
                    "text": "      /** Request path with query string - property for direct access */",
                    "lineNumber": 1224,
                    "isSignature": false
                  },
                  {
                    "text": "      path: string;",
                    "lineNumber": 1225,
                    "isSignature": false
                  },
                  {
                    "text": "      /** HTTP version (1.0, 1.1, 2.0) */",
                    "lineNumber": 1226,
                    "isSignature": false
                  },
                  {
                    "text": "      httpVersion: string;",
                    "lineNumber": 1227,
                    "isSignature": false
                  },
                  {
                    "text": "      /** Headers mapping header names to values */",
                    "lineNumber": 1228,
                    "isSignature": false
                  },
                  {
                    "text": "      headers: Record<string, string>;",
                    "lineNumber": 1229,
                    "isSignature": false
                  },
                  {
                    "text": "      /** Request body content */",
                    "lineNumber": 1230,
                    "isSignature": false
                  },
                  {
                    "text": "      body: string;",
                    "lineNumber": 1231,
                    "isSignature": false
                  },
                  {
                    "text": "      /** Get body size in bytes */",
                    "lineNumber": 1232,
                    "isSignature": false
                  },
                  {
                    "text": "      getSize(): number;",
                    "lineNumber": 1233,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 1234,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1235,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 1236,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Request class for parsing and managing HTTP requests.",
                    "lineNumber": 1237,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1238,
                    "isSignature": false
                  },
                  {
                    "text": "     * Parses raw HTTP message strings according to HTTP specification.",
                    "lineNumber": 1239,
                    "isSignature": false
                  },
                  {
                    "text": "     * Handles buffer management with configurable size limits.",
                    "lineNumber": 1240,
                    "isSignature": false
                  },
                  {
                    "text": "     * Validates Content-Length headers to ensure complete message receipt.",
                    "lineNumber": 1241,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1242,
                    "isSignature": false
                  },
                  {
                    "text": "     * @class Request",
                    "lineNumber": 1243,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 1244,
                    "isSignature": false
                  },
                  {
                    "text": "    class Request {",
                    "lineNumber": 1245,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1246,
                    "isSignature": false
                  },
                  {
                    "text": "       * End of message delimiter per HTTP specification.",
                    "lineNumber": 1247,
                    "isSignature": false
                  },
                  {
                    "text": "       *",
                    "lineNumber": 1248,
                    "isSignature": false
                  },
                  {
                    "text": "       * @private",
                    "lineNumber": 1249,
                    "isSignature": false
                  },
                  {
                    "text": "       * @readonly",
                    "lineNumber": 1250,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1251,
                    "isSignature": false
                  },
                  {
                    "text": "      private static readonly EOM = '\\r\\n\\r\\n';",
                    "lineNumber": 1252,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1253,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1254,
                    "isSignature": false
                  },
                  {
                    "text": "       * Parse a raw HTTP message string into a Request object.",
                    "lineNumber": 1255,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.41199520230293274
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-0000.md",
                "range": {
                  "startPosition": {
                    "line": 1136,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1201,
                    "column": 0
                  }
                },
                "contents": "    * **path:** `src/Servers/Reverb/Http/router.ts`\n    * **status:** success\n        * lines: 420-469\n    * **content:**\n\n    }\n    \n    /**\n     * HTTP Request interface\n     *\n     * Represents an HTTP request object with methods to access headers, method, path, etc.\n     */\n    export interface IHttpRequest {\n      /**\n       * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\n       */\n      method: string;\n    \n      /**\n       * Request path with query string - property for direct access\n       */\n      path: string;\n    \n      /**\n       * Request body content - property for direct access\n       */\n      body: string;\n    \n      /**\n       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n       */\n      getMethod(): string;\n    \n      /**\n       * Get the request path\n       */\n      getPath(): string;\n    \n      /**\n       * Get the request host\n       */\n      getHost(): string;\n    \n      /**\n       * Get a specific header value\n       */\n      getHeader(name: string): string | undefined;\n    \n      /**\n       * Get all headers\n       */\n      getHeaders(): Record<string, string>;\n    \n      /**\n       * Get the request URI\n\n### Tool · read (started)\n\n    * **path:** `src/Servers/Reverb/Http/request.ts`\n    * **status:** pending\n\n### Tool · read (completed)\n\n    * **path:** `src/Servers/Reverb/Http/request.ts`",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    * **path:** `src/Servers/Reverb/Http/router.ts`",
                    "lineNumber": 1138,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 1139,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 420-469",
                    "lineNumber": 1140,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 1141,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1142,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 1143,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1144,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 1145,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Request interface",
                    "lineNumber": 1146,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1147,
                    "isSignature": false
                  },
                  {
                    "text": "     * Represents an HTTP request object with methods to access headers, method, path, etc.",
                    "lineNumber": 1148,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 1149,
                    "isSignature": false
                  },
                  {
                    "text": "    export interface IHttpRequest {",
                    "lineNumber": 1150,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1151,
                    "isSignature": false
                  },
                  {
                    "text": "       * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access",
                    "lineNumber": 1152,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1153,
                    "isSignature": false
                  },
                  {
                    "text": "      method: string;",
                    "lineNumber": 1154,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1155,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1156,
                    "isSignature": false
                  },
                  {
                    "text": "       * Request path with query string - property for direct access",
                    "lineNumber": 1157,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1158,
                    "isSignature": false
                  },
                  {
                    "text": "      path: string;",
                    "lineNumber": 1159,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1160,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1161,
                    "isSignature": false
                  },
                  {
                    "text": "       * Request body content - property for direct access",
                    "lineNumber": 1162,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1163,
                    "isSignature": false
                  },
                  {
                    "text": "      body: string;",
                    "lineNumber": 1164,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1165,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1166,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)",
                    "lineNumber": 1167,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1168,
                    "isSignature": false
                  },
                  {
                    "text": "      getMethod(): string;",
                    "lineNumber": 1169,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1170,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1171,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request path",
                    "lineNumber": 1172,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1173,
                    "isSignature": false
                  },
                  {
                    "text": "      getPath(): string;",
                    "lineNumber": 1174,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1175,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1176,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request host",
                    "lineNumber": 1177,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1178,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string;",
                    "lineNumber": 1179,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1180,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1181,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get a specific header value",
                    "lineNumber": 1182,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1183,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined;",
                    "lineNumber": 1184,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1185,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1186,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get all headers",
                    "lineNumber": 1187,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 1188,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeaders(): Record<string, string>;",
                    "lineNumber": 1189,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1190,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 1191,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request URI",
                    "lineNumber": 1192,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1193,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (started)",
                    "lineNumber": 1194,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1195,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `src/Servers/Reverb/Http/request.ts`",
                    "lineNumber": 1196,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** pending",
                    "lineNumber": 1197,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1198,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (completed)",
                    "lineNumber": 1199,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1200,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `src/Servers/Reverb/Http/request.ts`",
                    "lineNumber": 1201,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4115825891494751
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/request.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 185,
                    "column": 3
                  }
                },
                "contents": "function parseRequest(buffer: string): IHttpRequestInternal | null {\n\n\n  // Create request object matching Router's IHttpRequest interface\n  const request: IHttpRequestInternal = {\n    method,\n    path,\n    httpVersion,\n    headers,\n    body: bodySection,\n    getMethod(): string {\n      return method;\n    },\n    getPath(): string {\n      return path;\n    },\n    getHost(): string {\n      return host;\n    },\n    getHeader(name: string): string | undefined {\n      return headers[name.toLowerCase()];\n    },\n    getHeaders(): Record<string, string> {\n      return { ...headers };\n    },\n    getUri(): { path: string; host: string } {\n      return { path, host };\n    },\n    getSize(): number {\n      return Buffer.byteLength(bodySection, \"utf8\");\n    },\n  };\n\n  return request;\n}\n\n/**\n * Parse a raw HTTP message string into a Request object.\n *\n * This function handles the core logic of:\n * 1. Appending the message to the connection buffer\n * 2. Checking buffer size limits (throws OverflowException if exceeded)\n * 3. Detecting End-Of-Message marker\n * 4. Parsing headers and body\n * 5. Validating Content-Length header\n * 6. Clearing buffer on successful parse\n *\n * @param message - Raw HTTP message string to parse\n * @param connection - Connection object with buffer management methods\n * @param maxRequestSize - Maximum allowed buffer size in bytes\n * @returns Parsed Request object if complete, null if incomplete\n * @throws {Error} Throws error if buffer exceeds maxRequestSize\n *\n * @example\n * ```typescript\n * const request = parseHttpRequest(httpMessage, connection, 4096);\n * if (request) {\n *   console.log(request.method, request.path);\n * }\n * ```\n */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "function parseRequest(buffer: string): IHttpRequestInternal | null {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "  // Create request object matching Router's IHttpRequest interface",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "  const request: IHttpRequestInternal = {",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    method,",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "    path,",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "    httpVersion,",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    headers,",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "    body: bodySection,",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "    getMethod(): string {",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "      return method;",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "    getPath(): string {",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      return path;",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "    getHost(): string {",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "      return host;",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "    getHeader(name: string): string | undefined {",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "      return headers[name.toLowerCase()];",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "    getHeaders(): Record<string, string> {",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      return { ...headers };",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "    getUri(): { path: string; host: string } {",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return { path, host };",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "    getSize(): number {",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "      return Buffer.byteLength(bodySection, \"utf8\");",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "  };",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  return request;",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 160,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": " * Parse a raw HTTP message string into a Request object.",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": " * This function handles the core logic of:",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Appending the message to the connection buffer",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Checking buffer size limits (throws OverflowException if exceeded)",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Detecting End-Of-Message marker",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Parsing headers and body",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Validating Content-Length header",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. Clearing buffer on successful parse",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": " * @param message - Raw HTTP message string to parse",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": " * @param connection - Connection object with buffer management methods",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": " * @param maxRequestSize - Maximum allowed buffer size in bytes",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Parsed Request object if complete, null if incomplete",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} Throws error if buffer exceeds maxRequestSize",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": " * const request = parseHttpRequest(httpMessage, connection, 4096);",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": " * if (request) {",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": " *   console.log(request.method, request.path);",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 186,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.39869049191474915
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/server.ts",
                "range": {
                  "startPosition": {
                    "line": 40,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 448,
                    "column": 1
                  }
                },
                "contents": "export class Server {\n\n\n  /**\n   * Convert Bun Request to IHttpRequest.\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {\n    const url = new URL(req.url);\n    const body =\n      req.method !== \"GET\" && req.method !== \"HEAD\" ? await req.text() : \"\";\n    const method = req.method;\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    return {\n      method,\n      path: pathWithQuery,\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n    };\n  }\n\n  /**\n   * Determine whether the server has TLS support.\n   *\n   * Checks if the server was configured with TLS certificates.\n   *\n   * @returns true if TLS is configured, false otherwise\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 41,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 41,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 41,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 42,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Server {",
                    "lineNumber": 41,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 380,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 381,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 382,
                    "isSignature": false
                  },
                  {
                    "text": "   * Convert Bun Request to IHttpRequest.",
                    "lineNumber": 383,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 384,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The Bun Request object",
                    "lineNumber": 385,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns IHttpRequest interface",
                    "lineNumber": 386,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 387,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 388,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 389,
                    "isSignature": false
                  },
                  {
                    "text": "  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {",
                    "lineNumber": 390,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(req.url);",
                    "lineNumber": 391,
                    "isSignature": false
                  },
                  {
                    "text": "    const body =",
                    "lineNumber": 392,
                    "isSignature": false
                  },
                  {
                    "text": "      req.method !== \"GET\" && req.method !== \"HEAD\" ? await req.text() : \"\";",
                    "lineNumber": 393,
                    "isSignature": false
                  },
                  {
                    "text": "    const method = req.method;",
                    "lineNumber": 394,
                    "isSignature": false
                  },
                  {
                    "text": "    const pathWithQuery = url.pathname + url.search;",
                    "lineNumber": 395,
                    "isSignature": false
                  },
                  {
                    "text": "    const pathWithoutQuery = url.pathname;",
                    "lineNumber": 396,
                    "isSignature": false
                  },
                  {
                    "text": "    const host = url.host;",
                    "lineNumber": 397,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 398,
                    "isSignature": false
                  },
                  {
                    "text": "    // Convert Headers to Record<string, string>",
                    "lineNumber": 399,
                    "isSignature": false
                  },
                  {
                    "text": "    const headers: Record<string, string> = {};",
                    "lineNumber": 400,
                    "isSignature": false
                  },
                  {
                    "text": "    req.headers.forEach((value, key) => {",
                    "lineNumber": 401,
                    "isSignature": false
                  },
                  {
                    "text": "      headers[key.toLowerCase()] = value;",
                    "lineNumber": 402,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 403,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 404,
                    "isSignature": false
                  },
                  {
                    "text": "    return {",
                    "lineNumber": 405,
                    "isSignature": false
                  },
                  {
                    "text": "      method,",
                    "lineNumber": 406,
                    "isSignature": false
                  },
                  {
                    "text": "      path: pathWithQuery,",
                    "lineNumber": 407,
                    "isSignature": false
                  },
                  {
                    "text": "      body,",
                    "lineNumber": 408,
                    "isSignature": false
                  },
                  {
                    "text": "      getMethod(): string {",
                    "lineNumber": 409,
                    "isSignature": false
                  },
                  {
                    "text": "        return method;",
                    "lineNumber": 410,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 411,
                    "isSignature": false
                  },
                  {
                    "text": "      getPath(): string {",
                    "lineNumber": 412,
                    "isSignature": false
                  },
                  {
                    "text": "        return pathWithoutQuery;",
                    "lineNumber": 413,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 414,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string {",
                    "lineNumber": 415,
                    "isSignature": false
                  },
                  {
                    "text": "        return host;",
                    "lineNumber": 416,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 417,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined {",
                    "lineNumber": 418,
                    "isSignature": false
                  },
                  {
                    "text": "        return headers[name.toLowerCase()];",
                    "lineNumber": 419,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 420,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeaders(): Record<string, string> {",
                    "lineNumber": 421,
                    "isSignature": false
                  },
                  {
                    "text": "        return { ...headers };",
                    "lineNumber": 422,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 423,
                    "isSignature": false
                  },
                  {
                    "text": "      getUri(): { path: string; host: string } {",
                    "lineNumber": 424,
                    "isSignature": false
                  },
                  {
                    "text": "        return { path: pathWithoutQuery, host };",
                    "lineNumber": 425,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 426,
                    "isSignature": false
                  },
                  {
                    "text": "    };",
                    "lineNumber": 427,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 428,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 429,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 430,
                    "isSignature": false
                  },
                  {
                    "text": "   * Determine whether the server has TLS support.",
                    "lineNumber": 431,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 432,
                    "isSignature": false
                  },
                  {
                    "text": "   * Checks if the server was configured with TLS certificates.",
                    "lineNumber": 433,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 434,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns true if TLS is configured, false otherwise",
                    "lineNumber": 435,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 436,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 449,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3899815082550049
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2339.md",
                "range": {
                  "startPosition": {
                    "line": 8116,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 8201,
                    "column": 0
                  }
                },
                "contents": "### Tool · read (completed)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`\n    * **status:** success\n        * lines: 240-259\n    * **content:**\n\n        );\n    \n        // Create a minimal server provider\n        // By default, server does not subscribe to events (standalone mode)\n        this.serverProvider = new class extends ServerProvider {\n          subscribesToEvents(): boolean {\n            return false;\n          }\n        }();\n    \n        // Initialize metrics handler with all required dependencies\n        this.metricsHandler = new MetricsHandler(\n          this.serverProvider as any,\n          this.channelManager as any,\n          null as any\n        );\n    \n        // Initialize class-based controllers with proper dependencies\n        this.eventsController = new EventsController(this.channelManager, this.metricsHandler);\n        this.eventsBatchController = new EventsBatchController(this.metricsHandler);\n\n### Assistant\n\nChecking the IHttpRequest interface definition:\n\n### Tool · read (started)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`\n    * **status:** pending\n\n### Tool · read (started)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/Http/request.ts`\n    * **status:** pending\n\n### Tool · read (completed)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`\n    * **status:** success\n        * lines: 420-449\n    * **content:**\n\n    }\n    \n    /**\n     * HTTP Request interface\n     *\n     * Represents an HTTP request object with methods to access headers, method, path, etc.\n     */\n    export interface IHttpRequest {\n      /**\n       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n       */\n      getMethod(): string;\n    \n      /**\n       * Get the request path\n       */\n      getPath(): string;\n    \n      /**\n       * Get the request host\n       */\n      getHost(): string;\n    \n      /**\n       * Get a specific header value\n       */\n      getHeader(name: string): string | undefined;\n    \n      /**\n       * Get all headers\n\n### Tool · grep (started)\n\n    {\n      \"args\": {\n        \"pattern\": \"data\\\\(\\\\)|ConnectionData\",",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "### Tool · read (completed)",
                    "lineNumber": 8117,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8118,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/factory.ts`",
                    "lineNumber": 8119,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 8120,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 240-259",
                    "lineNumber": 8121,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 8122,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8123,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 8124,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8125,
                    "isSignature": false
                  },
                  {
                    "text": "        // Create a minimal server provider",
                    "lineNumber": 8126,
                    "isSignature": false
                  },
                  {
                    "text": "        // By default, server does not subscribe to events (standalone mode)",
                    "lineNumber": 8127,
                    "isSignature": false
                  },
                  {
                    "text": "        this.serverProvider = new class extends ServerProvider {",
                    "lineNumber": 8128,
                    "isSignature": false
                  },
                  {
                    "text": "          subscribesToEvents(): boolean {",
                    "lineNumber": 8129,
                    "isSignature": false
                  },
                  {
                    "text": "            return false;",
                    "lineNumber": 8130,
                    "isSignature": false
                  },
                  {
                    "text": "          }",
                    "lineNumber": 8131,
                    "isSignature": false
                  },
                  {
                    "text": "        }();",
                    "lineNumber": 8132,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8133,
                    "isSignature": false
                  },
                  {
                    "text": "        // Initialize metrics handler with all required dependencies",
                    "lineNumber": 8134,
                    "isSignature": false
                  },
                  {
                    "text": "        this.metricsHandler = new MetricsHandler(",
                    "lineNumber": 8135,
                    "isSignature": false
                  },
                  {
                    "text": "          this.serverProvider as any,",
                    "lineNumber": 8136,
                    "isSignature": false
                  },
                  {
                    "text": "          this.channelManager as any,",
                    "lineNumber": 8137,
                    "isSignature": false
                  },
                  {
                    "text": "          null as any",
                    "lineNumber": 8138,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 8139,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8140,
                    "isSignature": false
                  },
                  {
                    "text": "        // Initialize class-based controllers with proper dependencies",
                    "lineNumber": 8141,
                    "isSignature": false
                  },
                  {
                    "text": "        this.eventsController = new EventsController(this.channelManager, this.metricsHandler);",
                    "lineNumber": 8142,
                    "isSignature": false
                  },
                  {
                    "text": "        this.eventsBatchController = new EventsBatchController(this.metricsHandler);",
                    "lineNumber": 8143,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8144,
                    "isSignature": false
                  },
                  {
                    "text": "### Assistant",
                    "lineNumber": 8145,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8146,
                    "isSignature": false
                  },
                  {
                    "text": "Checking the IHttpRequest interface definition:",
                    "lineNumber": 8147,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8148,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (started)",
                    "lineNumber": 8149,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8150,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`",
                    "lineNumber": 8151,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** pending",
                    "lineNumber": 8152,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8153,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (started)",
                    "lineNumber": 8154,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8155,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/Http/request.ts`",
                    "lineNumber": 8156,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** pending",
                    "lineNumber": 8157,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8158,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (completed)",
                    "lineNumber": 8159,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8160,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`",
                    "lineNumber": 8161,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 8162,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 420-449",
                    "lineNumber": 8163,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 8164,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8165,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 8166,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8167,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 8168,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Request interface",
                    "lineNumber": 8169,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 8170,
                    "isSignature": false
                  },
                  {
                    "text": "     * Represents an HTTP request object with methods to access headers, method, path, etc.",
                    "lineNumber": 8171,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 8172,
                    "isSignature": false
                  },
                  {
                    "text": "    export interface IHttpRequest {",
                    "lineNumber": 8173,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 8174,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)",
                    "lineNumber": 8175,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 8176,
                    "isSignature": false
                  },
                  {
                    "text": "      getMethod(): string;",
                    "lineNumber": 8177,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8178,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 8179,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request path",
                    "lineNumber": 8180,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 8181,
                    "isSignature": false
                  },
                  {
                    "text": "      getPath(): string;",
                    "lineNumber": 8182,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8183,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 8184,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request host",
                    "lineNumber": 8185,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 8186,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string;",
                    "lineNumber": 8187,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8188,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 8189,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get a specific header value",
                    "lineNumber": 8190,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 8191,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined;",
                    "lineNumber": 8192,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 8193,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 8194,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get all headers",
                    "lineNumber": 8195,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8196,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · grep (started)",
                    "lineNumber": 8197,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8198,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 8199,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 8200,
                    "isSignature": false
                  },
                  {
                    "text": "        \"pattern\": \"data\\\\(\\\\)|ConnectionData\",",
                    "lineNumber": 8201,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3887292146682739
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 189,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1272,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\n\n\n  /**\n   * Determine whether the server uses TLS\n   *\n   * Checks if TLS context has both certificate and key configured.\n   *\n   * @param context - TLS context to check\n   * @returns True if TLS is configured, false otherwise\n   *\n   * @private\n   */\n  private static usesTls(context: TlsContext): boolean {\n    return !!(context.local_cert || context.local_pk);\n  }\n\n  /**\n   * Convert Bun Request to IHttpRequest\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\n    const url = new URL(req.url);\n    const body = req.method !== \"GET\" ? await req.text() : \"\";\n    const method = req.method;\n    // Store pathname + search for full path, but pathname only for signature verification\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    return {\n      method,\n      path: pathWithQuery,\n      url: req.url, // Include full URL with query string for controllers to access query params\n      httpVersion: \"1.1\",\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        // Return path without query string for Pusher signature verification\n        // Pusher signatures are calculated over the path without the query string\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      }\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 184,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 185,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 190,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 1143,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1144,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 1145,
                    "isSignature": false
                  },
                  {
                    "text": "   * Determine whether the server uses TLS",
                    "lineNumber": 1146,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1147,
                    "isSignature": false
                  },
                  {
                    "text": "   * Checks if TLS context has both certificate and key configured.",
                    "lineNumber": 1148,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1149,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param context - TLS context to check",
                    "lineNumber": 1150,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns True if TLS is configured, false otherwise",
                    "lineNumber": 1151,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1152,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 1153,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 1154,
                    "isSignature": false
                  },
                  {
                    "text": "  private static usesTls(context: TlsContext): boolean {",
                    "lineNumber": 1155,
                    "isSignature": false
                  },
                  {
                    "text": "    return !!(context.local_cert || context.local_pk);",
                    "lineNumber": 1156,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 1157,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1158,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 1159,
                    "isSignature": false
                  },
                  {
                    "text": "   * Convert Bun Request to IHttpRequest",
                    "lineNumber": 1160,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1161,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The Bun Request object",
                    "lineNumber": 1162,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns IHttpRequest interface",
                    "lineNumber": 1163,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1164,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 1165,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 1166,
                    "isSignature": false
                  },
                  {
                    "text": "  private static async convertToHttpRequest(",
                    "lineNumber": 1167,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 1168,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<",
                    "lineNumber": 1169,
                    "isSignature": false
                  },
                  {
                    "text": "    IHttpRequest & { url: string; httpVersion: string; getSize(): number }",
                    "lineNumber": 1170,
                    "isSignature": false
                  },
                  {
                    "text": "  > {",
                    "lineNumber": 1171,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(req.url);",
                    "lineNumber": 1172,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = req.method !== \"GET\" ? await req.text() : \"\";",
                    "lineNumber": 1173,
                    "isSignature": false
                  },
                  {
                    "text": "    const method = req.method;",
                    "lineNumber": 1174,
                    "isSignature": false
                  },
                  {
                    "text": "    // Store pathname + search for full path, but pathname only for signature verification",
                    "lineNumber": 1175,
                    "isSignature": false
                  },
                  {
                    "text": "    const pathWithQuery = url.pathname + url.search;",
                    "lineNumber": 1176,
                    "isSignature": false
                  },
                  {
                    "text": "    const pathWithoutQuery = url.pathname;",
                    "lineNumber": 1177,
                    "isSignature": false
                  },
                  {
                    "text": "    const host = url.host;",
                    "lineNumber": 1178,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1179,
                    "isSignature": false
                  },
                  {
                    "text": "    // Convert Headers to Record<string, string>",
                    "lineNumber": 1180,
                    "isSignature": false
                  },
                  {
                    "text": "    const headers: Record<string, string> = {};",
                    "lineNumber": 1181,
                    "isSignature": false
                  },
                  {
                    "text": "    req.headers.forEach((value, key) => {",
                    "lineNumber": 1182,
                    "isSignature": false
                  },
                  {
                    "text": "      headers[key.toLowerCase()] = value;",
                    "lineNumber": 1183,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 1184,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1185,
                    "isSignature": false
                  },
                  {
                    "text": "    return {",
                    "lineNumber": 1186,
                    "isSignature": false
                  },
                  {
                    "text": "      method,",
                    "lineNumber": 1187,
                    "isSignature": false
                  },
                  {
                    "text": "      path: pathWithQuery,",
                    "lineNumber": 1188,
                    "isSignature": false
                  },
                  {
                    "text": "      url: req.url, // Include full URL with query string for controllers to access query params",
                    "lineNumber": 1189,
                    "isSignature": false
                  },
                  {
                    "text": "      httpVersion: \"1.1\",",
                    "lineNumber": 1190,
                    "isSignature": false
                  },
                  {
                    "text": "      body,",
                    "lineNumber": 1191,
                    "isSignature": false
                  },
                  {
                    "text": "      getMethod(): string {",
                    "lineNumber": 1192,
                    "isSignature": false
                  },
                  {
                    "text": "        return method;",
                    "lineNumber": 1193,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1194,
                    "isSignature": false
                  },
                  {
                    "text": "      getPath(): string {",
                    "lineNumber": 1195,
                    "isSignature": false
                  },
                  {
                    "text": "        // Return path without query string for Pusher signature verification",
                    "lineNumber": 1196,
                    "isSignature": false
                  },
                  {
                    "text": "        // Pusher signatures are calculated over the path without the query string",
                    "lineNumber": 1197,
                    "isSignature": false
                  },
                  {
                    "text": "        return pathWithoutQuery;",
                    "lineNumber": 1198,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1199,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string {",
                    "lineNumber": 1200,
                    "isSignature": false
                  },
                  {
                    "text": "        return host;",
                    "lineNumber": 1201,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1202,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined {",
                    "lineNumber": 1203,
                    "isSignature": false
                  },
                  {
                    "text": "        return headers[name.toLowerCase()];",
                    "lineNumber": 1204,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1205,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeaders(): Record<string, string> {",
                    "lineNumber": 1206,
                    "isSignature": false
                  },
                  {
                    "text": "        return { ...headers };",
                    "lineNumber": 1207,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 1208,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 1216,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1273,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3883747458457947
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2339.md",
                "range": {
                  "startPosition": {
                    "line": 9247,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 9341,
                    "column": 0
                  }
                },
                "contents": "          }\n        }\n      }\n    }\n\n### Assistant\n\nReading the full interface definition:\n\n### Tool · read (started)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`\n    * **status:** pending\n\n### Tool · read (completed)\n\n    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`\n    * **status:** success\n        * lines: 420-469\n    * **content:**\n\n    }\n    \n    /**\n     * HTTP Request interface\n     *\n     * Represents an HTTP request object with methods to access headers, method, path, etc.\n     */\n    export interface IHttpRequest {\n      /**\n       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\n       */\n      getMethod(): string;\n    \n      /**\n       * Get the request path\n       */\n      getPath(): string;\n    \n      /**\n       * Get the request host\n       */\n      getHost(): string;\n    \n      /**\n       * Get a specific header value\n       */\n      getHeader(name: string): string | undefined;\n    \n      /**\n       * Get all headers\n       */\n      getHeaders(): Record<string, string>;\n    \n      /**\n       * Get the request URI\n       */\n      getUri(): {\n        path: string;\n        host: string;\n      };\n    }\n    \n    /**\n     * Route matcher interface\n     *\n     * Handles route matching and context management\n     */\n    export interface IRouteMatcher {\n      /**\n       * Set the matcher context (method, host, etc.)\n\n### Assistant\n\nFixing the issues, starting with the IHttpRequest interface:\n\n### Tool · edit (started)\n\n    {\n      \"args\": {\n        \"path\": \"/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/Http/router.ts\"\n      }\n    }\n\n### Tool · read (started)\n\n    * **path:** `revurb-ts/src/Protocols/Pusher/metrics-handler.ts`\n    * **status:** pending\n\n### Tool · edit (completed)\n\n    {\n      \"args\": {\n        \"path\": \"/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/Http/router.ts\"",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "          }",
                    "lineNumber": 9248,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 9249,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 9250,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 9251,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9252,
                    "isSignature": false
                  },
                  {
                    "text": "### Assistant",
                    "lineNumber": 9253,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9254,
                    "isSignature": false
                  },
                  {
                    "text": "Reading the full interface definition:",
                    "lineNumber": 9255,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9256,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (started)",
                    "lineNumber": 9257,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9258,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`",
                    "lineNumber": 9259,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** pending",
                    "lineNumber": 9260,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9261,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (completed)",
                    "lineNumber": 9262,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9263,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Servers/Reverb/Http/router.ts`",
                    "lineNumber": 9264,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 9265,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 420-469",
                    "lineNumber": 9266,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 9267,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9268,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 9269,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9270,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 9271,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Request interface",
                    "lineNumber": 9272,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 9273,
                    "isSignature": false
                  },
                  {
                    "text": "     * Represents an HTTP request object with methods to access headers, method, path, etc.",
                    "lineNumber": 9274,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 9275,
                    "isSignature": false
                  },
                  {
                    "text": "    export interface IHttpRequest {",
                    "lineNumber": 9276,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9277,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)",
                    "lineNumber": 9278,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9279,
                    "isSignature": false
                  },
                  {
                    "text": "      getMethod(): string;",
                    "lineNumber": 9280,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9281,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9282,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request path",
                    "lineNumber": 9283,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9284,
                    "isSignature": false
                  },
                  {
                    "text": "      getPath(): string;",
                    "lineNumber": 9285,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9286,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9287,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request host",
                    "lineNumber": 9288,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9289,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string;",
                    "lineNumber": 9290,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9291,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9292,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get a specific header value",
                    "lineNumber": 9293,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9294,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined;",
                    "lineNumber": 9295,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9296,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9297,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get all headers",
                    "lineNumber": 9298,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9299,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeaders(): Record<string, string>;",
                    "lineNumber": 9300,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9301,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9302,
                    "isSignature": false
                  },
                  {
                    "text": "       * Get the request URI",
                    "lineNumber": 9303,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 9304,
                    "isSignature": false
                  },
                  {
                    "text": "      getUri(): {",
                    "lineNumber": 9305,
                    "isSignature": false
                  },
                  {
                    "text": "        path: string;",
                    "lineNumber": 9306,
                    "isSignature": false
                  },
                  {
                    "text": "        host: string;",
                    "lineNumber": 9307,
                    "isSignature": false
                  },
                  {
                    "text": "      };",
                    "lineNumber": 9308,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 9309,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 9310,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 9311,
                    "isSignature": false
                  },
                  {
                    "text": "     * Route matcher interface",
                    "lineNumber": 9312,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 9313,
                    "isSignature": false
                  },
                  {
                    "text": "     * Handles route matching and context management",
                    "lineNumber": 9314,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 9315,
                    "isSignature": false
                  },
                  {
                    "text": "    export interface IRouteMatcher {",
                    "lineNumber": 9316,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 9317,
                    "isSignature": false
                  },
                  {
                    "text": "       * Set the matcher context (method, host, etc.)",
                    "lineNumber": 9318,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9319,
                    "isSignature": false
                  },
                  {
                    "text": "### Assistant",
                    "lineNumber": 9320,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9321,
                    "isSignature": false
                  },
                  {
                    "text": "Fixing the issues, starting with the IHttpRequest interface:",
                    "lineNumber": 9322,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9323,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (started)",
                    "lineNumber": 9324,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9325,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 9326,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 9327,
                    "isSignature": false
                  },
                  {
                    "text": "        \"path\": \"/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/Http/router.ts\"",
                    "lineNumber": 9328,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 9329,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 9330,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9331,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · read (started)",
                    "lineNumber": 9332,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9333,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `revurb-ts/src/Protocols/Pusher/metrics-handler.ts`",
                    "lineNumber": 9334,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** pending",
                    "lineNumber": 9335,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9336,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (completed)",
                    "lineNumber": 9337,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9338,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 9339,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 9340,
                    "isSignature": false
                  },
                  {
                    "text": "        \"path\": \"/Users/tom/personal/revurb/revurb-ts/src/Servers/Reverb/Http/router.ts\"",
                    "lineNumber": 9341,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.38749799132347107
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 301,
                    "column": 3
                  }
                },
                "contents": "export class EventsBatchController {\n\n\n  /**\n   * Get the request body content.\n   *\n   * Extracts the body string from the HTTP request object.\n   * The body should contain the JSON-encoded batch payload.\n   *\n   * @param request - The HTTP request object\n   * @returns The request body as a string\n   */\n  protected getBody(request: IHttpRequest): string {\n    // Access body from the request object\n    // IHttpRequest has a body property directly\n    return request.body || \"\";\n  }\n}\n\n/**\n * Factory function to create a controller handler.\n *\n * This function creates a controller callback that can be used with the router.\n * It handles dependency injection and wires up the controller with its dependencies.\n *\n * Usage Notes:\n * - This assumes that request verification (authentication) happens at the router level\n * - The application and channels parameters must be provided by the route handler\n * - This follows the pattern where controllers receive pre-verified context\n *\n * @param metricsHandler - The metrics handler instance\n * @returns Controller callback function\n *\n * @example\n * ```typescript\n * const handler = createEventsBatchController(metricsHandler);\n * router.post('/apps/:appId/batch_events', handler);\n * ```\n */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request body content.",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": "   * Extracts the body string from the HTTP request object.",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": "   * The body should contain the JSON-encoded batch payload.",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 272,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 273,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The request body as a string",
                    "lineNumber": 274,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 275,
                    "isSignature": false
                  },
                  {
                    "text": "  protected getBody(request: IHttpRequest): string {",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "    // Access body from the request object",
                    "lineNumber": 277,
                    "isSignature": false
                  },
                  {
                    "text": "    // IHttpRequest has a body property directly",
                    "lineNumber": 278,
                    "isSignature": false
                  },
                  {
                    "text": "    return request.body || \"\";",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory function to create a controller handler.",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": " * This function creates a controller callback that can be used with the router.",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": " * It handles dependency injection and wires up the controller with its dependencies.",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": " * Usage Notes:",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": " * - This assumes that request verification (authentication) happens at the router level",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": " * - The application and channels parameters must be provided by the route handler",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": " * - This follows the pattern where controllers receive pre-verified context",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": " * @param metricsHandler - The metrics handler instance",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Controller callback function",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": " * const handler = createEventsBatchController(metricsHandler);",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": " * router.post('/apps/:appId/batch_events', handler);",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 302,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.27400821447372437
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "notes/2025-11-13-1300-review-fixes.md",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 37,
                    "column": 0
                  }
                },
                "contents": "# Review Fixes - 2025-11-13\n\n## Status: ✅ All Issues Resolved\n\nFixed all review feedback from `specs/review.md`:\n\n### 1. Fixed Factory.createHttpConnection() Type Issues\n- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface\n- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 2. Fixed Factory.convertToHttpRequest() Headers Property\n- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)\n- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 3. Fixed EventsBatchController Connection Type\n- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)\n- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers\n- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`\n\n### 4. Fixed All `any` Type Violations in Tests\n- **Problem**: 9 `noExplicitAny` lint violations across test suite\n- **Solution**: Replaced all `any` types with proper types:\n  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)\n  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`\n  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)\n  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)\n- **Files**: \n  - `tests/unit/channels/channel.test.ts`\n  - `tests/e2e/websocket-connection.test.ts`\n  - `tests/feature/health-check-controller.test.ts`\n  - `tests/unit/events/event-dispatcher.test.ts`\n\n## Verification\n- ✅ `bun run typecheck` - Passes\n- ✅ `bun run lint` - No violations",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "# Review Fixes - 2025-11-13",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "## Status: ✅ All Issues Resolved",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "Fixed all review feedback from `specs/review.md`:",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "### 1. Fixed Factory.createHttpConnection() Type Issues",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "### 2. Fixed Factory.convertToHttpRequest() Headers Property",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "### 3. Fixed EventsBatchController Connection Type",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "### 4. Fixed All `any` Type Violations in Tests",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: 9 `noExplicitAny` lint violations across test suite",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Replaced all `any` types with proper types:",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: ",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/channels/channel.test.ts`",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/e2e/websocket-connection.test.ts`",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/feature/health-check-controller.test.ts`",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/events/event-dispatcher.test.ts`",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "## Verification",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run typecheck` - Passes",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run lint` - No violations",
                    "lineNumber": 37,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2555946111679077
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 24,
                    "column": 1
                  }
                },
                "contents": "import type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport { dispatch } from \"../../event-dispatcher\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * Batch item structure\n */\ninterface BatchItem {\n  name: string;\n  channel: string;\n  data: string;\n  socket_id?: string;\n  info?: string;\n}\n\n/**\n * Validation error structure\n */\ninterface ValidationErrors {\n  [key: string]: string[];\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import { dispatch } from \"../../event-dispatcher\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Batch item structure",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "interface BatchItem {",
                    "lineNumber": 12,
                    "isSignature": true
                  },
                  {
                    "text": "  name: string;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  channel: string;",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  data: string;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "  socket_id?: string;",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string;",
                    "lineNumber": 17,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 18,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * Validation error structure",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "interface ValidationErrors {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  [key: string]: string[];",
                    "lineNumber": 24,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 25,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.21207726001739502
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\n\n\n  /**\n   * Handle the batch events request.\n   *\n   * This method:\n   * 1. Parses and validates the request body\n   * 2. Dispatches each event to its channel\n   * 3. Gathers metrics for events that request channel info\n   * 4. Returns the batch results\n   *\n   * @param request - The HTTP request object\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from route parameters\n   * @param application - The verified application instance\n   * @param channels - The channel manager scoped to the application\n   * @returns Response object with batch results\n   */\n  async handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\n    // Parse request body\n    const body = this.getBody(request);\n    let payload: unknown;\n\n    try {\n      payload = JSON.parse(body) as { batch?: BatchItem[] };\n    } catch (_error) {\n      return new Response(\n        {\n          message: \"Invalid JSON in request body\",\n          errors: { body: [\"The body must be valid JSON\"] },\n        },\n        422,\n      );\n    }\n\n    // Validate payload\n    const validationErrors = this.validate(payload);\n    if (validationErrors) {\n      return new Response(\n        { message: \"Validation failed\", errors: validationErrors },\n        422,\n      );\n    }\n\n    const typedPayload = payload as { batch: BatchItem[] };\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map\n;\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the batch events request.",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Dispatches each event to its channel",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Gathers metrics for events that request channel info",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Returns the batch results",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from route parameters",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The verified application instance",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager scoped to the application",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response object with batch results",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse request body",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = this.getBody(request);",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "    let payload: unknown;",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "      payload = JSON.parse(body) as { batch?: BatchItem[] };",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (_error) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "          message: \"Invalid JSON in request body\",",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "          errors: { body: [\"The body must be valid JSON\"] },",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate payload",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "    const validationErrors = this.validate(payload);",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    if (validationErrors) {",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "        { message: \"Validation failed\", errors: validationErrors },",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    const typedPayload = payload as { batch: BatchItem[] };",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.17233480513095856
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 101,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 131,
                    "column": 3
                  }
                },
                "contents": "/**\n * PubSub message structure.\n */\nexport interface PubSubMessage {\n  /** Message type */\n  type: string;\n  /** Unique key for correlating requests/responses */\n  key?: string;\n  /** Serialized application data */\n  application?: string;\n  /** Message payload */\n  payload?: unknown;\n}\n\n/**\n * Metrics handler for gathering channel and connection statistics.\n *\n * This class handles metrics collection for Pusher-compatible channels,\n * supporting both single-server and distributed (multi-server) deployments.\n *\n * In distributed mode, it coordinates metrics gathering across all servers\n * using the PubSub provider with a timeout-based collection strategy.\n *\n * Metrics Types:\n * - channel: Information about a specific channel\n * - channels: Information about multiple channels\n * - channel_users: List of unique users in a presence channel\n * - connections: All connections for an application\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": " * PubSub message structure.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "export interface PubSubMessage {",
                    "lineNumber": 107,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Message type */",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "  type: string;",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Unique key for correlating requests/responses */",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "  key?: string;",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Serialized application data */",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "  application?: string;",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Message payload */",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "  payload?: unknown;",
                    "lineNumber": 115,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 116,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics handler for gathering channel and connection statistics.",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": " * This class handles metrics collection for Pusher-compatible channels,",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": " * supporting both single-server and distributed (multi-server) deployments.",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": " * In distributed mode, it coordinates metrics gathering across all servers",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": " * using the PubSub provider with a timeout-based collection strategy.",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics Types:",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": " * - channel: Information about a specific channel",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": " * - channels: Information about multiple channels",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": " * - channel_users: List of unique users in a presence channel",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": " * - connections: All connections for an application",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 132,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.13178789615631104
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 47,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 65,
                    "column": 1
                  }
                },
                "contents": "/**\n * Channel interface for metrics gathering.\n */\nexport interface Channel {\n  /** Get the channel name */\n  name(): string;\n  /** Get all connections to the channel */\n  connections(): Record<string, ChannelConnection>;\n}\n\n/**\n * Channel manager interface for accessing channels.\n */\nexport interface ChannelManager {\n  /** Get channel manager for a specific application */\n  for(application: Application): ApplicationChannelManager;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel interface for metrics gathering.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "export interface Channel {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get the channel name */",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  name(): string;",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Get all connections to the channel */",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  connections(): Record<string, ChannelConnection>;",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel manager interface for accessing channels.",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelManager {",
                    "lineNumber": 63,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get channel manager for a specific application */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "  for(application: Application): ApplicationChannelManager;",
                    "lineNumber": 65,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 66,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12053140252828598
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 82,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 115,
                    "column": 1
                  }
                },
                "contents": ";\n}\n\n/**\n * PubSub provider interface for distributed metrics.\n */\nexport interface PubSubProvider {\n  /**\n   * Publish a message to all subscribers.\n   * @returns Promise resolving to the number of subscribers\n   */\n  publish(message: PubSubMessage): Promise<number>;\n\n  /**\n   * Subscribe to events from other servers.\n   */\n  on(event: string, handler: (payload: unknown) => void): void;\n}\n\n/**\n * PubSub message structure.\n */\nexport interface PubSubMessage {\n  /** Message type */\n  type: string\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": ";",
                    "lineNumber": 85,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 86,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": " * PubSub provider interface for distributed metrics.",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "export interface PubSubProvider {",
                    "lineNumber": 91,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * Publish a message to all subscribers.",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the number of subscribers",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "  publish(message: PubSubMessage): Promise<number>;",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "   * Subscribe to events from other servers.",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  on(event: string, handler: (payload: unknown) => void): void;",
                    "lineNumber": 101,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 102,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": " * PubSub message structure.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "export interface PubSubMessage {",
                    "lineNumber": 107,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Message type */",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "  type: string",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 115,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 116,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.11063670367002487
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 62,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 85,
                    "column": 1
                  }
                },
                "contents": ";\n}\n\n/**\n * Application-specific channel manager interface.\n */\nexport interface ApplicationChannelManager {\n  /** Get all channels */\n  all(): Record<string, Channel>;\n  /** Find a specific channel by name */\n  find(name: string): Channel | null;\n  /** Get all connections for the application */\n  connections(): Record<string, unknown>;\n}\n\n/**\n * Server provider manager interface.\n */\nexport interface ServerProviderManager {\n  /** Check if the server subscribes to events */\n  subscribesToEvents(): boolean;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": ";",
                    "lineNumber": 65,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 66,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-specific channel manager interface.",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ApplicationChannelManager {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get all channels */",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "  all(): Record<string, Channel>;",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Find a specific channel by name */",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "  find(name: string): Channel | null;",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Get all connections for the application */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "  connections(): Record<string, unknown>;",
                    "lineNumber": 77,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 78,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": " * Server provider manager interface.",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ServerProviderManager {",
                    "lineNumber": 83,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Check if the server subscribes to events */",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "  subscribesToEvents(): boolean;",
                    "lineNumber": 85,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 86,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10676649957895279
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 314,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nprotected getBody(request: IHttpRequest): string {\n\n  }\n}\n\n/**\n * Factory function to create a controller handler.\n *\n * This function creates a controller callback that can be used with the router.\n * It handles dependency injection and wires up the controller with its dependencies.\n *\n * Usage Notes:\n * - This assumes that request verification (authentication) happens at the router level\n * - The application and channels parameters must be provided by the route handler\n * - This follows the pattern where controllers receive pre-verified context\n *\n * @param metricsHandler - The metrics handler instance\n * @returns Controller callback function\n *\n * @example\n * ```typescript\n * const handler = createEventsBatchController(metricsHandler);\n * router.post('/apps/:appId/batch_events', handler);\n * ```\n */\nexport function createEventsBatchController(\n  metricsHandler: MetricsHandler,\n): (\n  request: IHttpRequest,\n  connection: Connection,\n  appId: string,\n  application: Application,\n  channels: ChannelManager,\n) => Promise<Response> {\n  const controller = new EventsBatchController(metricsHandler);\n  return (request, _connection, _appId, application, channels) =>\n    controller.handle(request, _connection, _appId, application, channels);\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "protected getBody(request: IHttpRequest): string {",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory function to create a controller handler.",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": " * This function creates a controller callback that can be used with the router.",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": " * It handles dependency injection and wires up the controller with its dependencies.",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": " * Usage Notes:",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": " * - This assumes that request verification (authentication) happens at the router level",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": " * - The application and channels parameters must be provided by the route handler",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": " * - This follows the pattern where controllers receive pre-verified context",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": " * @param metricsHandler - The metrics handler instance",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Controller callback function",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": " * const handler = createEventsBatchController(metricsHandler);",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": " * router.post('/apps/:appId/batch_events', handler);",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 302,
                    "isSignature": false
                  },
                  {
                    "text": "export function createEventsBatchController(",
                    "lineNumber": 303,
                    "isSignature": true
                  },
                  {
                    "text": "  metricsHandler: MetricsHandler,",
                    "lineNumber": 304,
                    "isSignature": true
                  },
                  {
                    "text": "): (",
                    "lineNumber": 305,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 306,
                    "isSignature": true
                  },
                  {
                    "text": "  connection: Connection,",
                    "lineNumber": 307,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 308,
                    "isSignature": true
                  },
                  {
                    "text": "  application: Application,",
                    "lineNumber": 309,
                    "isSignature": true
                  },
                  {
                    "text": "  channels: ChannelManager,",
                    "lineNumber": 310,
                    "isSignature": true
                  },
                  {
                    "text": ") => Promise<Response> {",
                    "lineNumber": 311,
                    "isSignature": true
                  },
                  {
                    "text": "  const controller = new EventsBatchController(metricsHandler);",
                    "lineNumber": 312,
                    "isSignature": false
                  },
                  {
                    "text": "  return (request, _connection, _appId, application, channels) =>",
                    "lineNumber": 313,
                    "isSignature": false
                  },
                  {
                    "text": "    controller.handle(request, _connection, _appId, application, channels);",
                    "lineNumber": 314,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 315,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.1067131981253624
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\nconst ;\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map((item) => {\n      // Dispatch the event\n      const channelConnection = item.socket_id\n        ? (channels.connections()[item.socket_id] ?? null)\n        : null;\n      const excludeConnection = channelConnection\n        ? channelConnection.connection()\n        : null;\n\n      dispatch(\n        application,\n        {\n          event: item.name,\n          channel: item.channel,\n          data: item.data,\n        },\n        channels,\n        excludeConnection,\n      );\n\n      // Return promise for metrics gathering if requested\n      return item.info\n        ? this.metricsHandler.gather(application, \"channel\", {\n            channel: item.channel,\n            info: item.info,\n          })\n        : Promise.resolve({});\n    });\n\n    // Check if any items requested metrics\n    const hasMetrics = batch.some((item) => item.info);\n\n    if (hasMetrics) {\n      // Wait for all metrics to be gathered\n      const results = await Promise.all(items);\n      return new Response({\n        batch: results.map((result) => result || {}),\n      });\n    }\n\n    // No metrics requested, return empty batch object\n    return new Response({ batch: {} });\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    },
                    {
                      "startPosition": {
                        "line": 95,
                        "column": 3
                      },
                      "endPosition": {
                        "line": 102,
                        "column": 5
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "const ;",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map((item) => {",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      // Dispatch the event",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelConnection = item.socket_id",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "        ? (channels.connections()[item.socket_id] ?? null)",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "      const excludeConnection = channelConnection",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "        ? channelConnection.connection()",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      dispatch(",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "        application,",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "          event: item.name,",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "          channel: item.channel,",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "          data: item.data,",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "        excludeConnection,",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "      // Return promise for metrics gathering if requested",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return item.info",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "        ? this.metricsHandler.gather(application, \"channel\", {",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "            channel: item.channel,",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "            info: item.info,",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "          })",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "        : Promise.resolve({});",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if any items requested metrics",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    const hasMetrics = batch.some((item) => item.info);",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    if (hasMetrics) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      // Wait for all metrics to be gathered",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      const results = await Promise.all(items);",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "        batch: results.map((result) => result || {}),",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // No metrics requested, return empty batch object",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ batch: {} });",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09888386726379395
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 53
                  },
                  "endPosition": {
                    "line": 29,
                    "column": 1
                  }
                },
                "contents": "import type { ChannelConnection } from \"./channels/channel-connection\";\n\n/**\n * Metrics collection options for different metric types.\n */\nexport interface MetricsOptions {\n  /** Channel name (for 'channel' and 'channel_users' types) */\n  channel?: string;\n  /** Array of channel names (for 'channels' type) */\n  channels?: string[];\n  /** Info fields to include (comma-separated or array) */\n  info?: string | string[];\n  /** Filter prefix for channel names (for 'channels' type) */\n  filter?: string;\n}\n\n/**\n * Channel information structure.\n */\nexport interface ChannelInfo {\n  /** Whether the channel is occupied (has connections) */\n  occupied?: boolean\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ChannelConnection } from \"./channels/channel-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics collection options for different metric types.",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "export interface MetricsOptions {",
                    "lineNumber": 7,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Channel name (for 'channel' and 'channel_users' types) */",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "  channel?: string;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Array of channel names (for 'channels' type) */",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "  channels?: string[];",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Info fields to include (comma-separated or array) */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string | string[];",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Filter prefix for channel names (for 'channels' type) */",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  filter?: string;",
                    "lineNumber": 15,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 16,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel information structure.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelInfo {",
                    "lineNumber": 21,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Whether the channel is occupied (has connections) */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "  occupied?: boolean",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 30,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09210280328989029
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 24,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "/**\n * EventsBatchController - Handles batch event dispatching\n *\n * Implements POST /apps/:appId/batch_events endpoint for triggering\n * multiple events in a single API call. Supports batches of up to 10 events.\n *\n * Key Features:\n * - Validates batch size (max 10 events)\n * - Dispatches events using EventDispatcher\n * - Optionally gathers channel metrics for each event\n * - Returns batch results with channel info\n *\n * Request Format:\n * ```json\n * {\n *   \"batch\": [\n *     {\n *       \"name\": \"my-event\",\n *       \"channel\": \"my-channel\",\n *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",\n *       \"socket_id\": \"123.456\",\n *       \"info\": \"subscription_count\"\n *     }\n *   ]\n * }\n * ```\n *\n * Response Format:\n * ```json\n * {\n *   \"batch\": [\n *     { \"subscription_count\": 5 },\n *     { \"subscription_count\": 3 }\n *   ]\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Usage with dependency injection\n * const controller = new EventsBatchController(metricsHandler);\n * const response = await controller.handle(request, connection, appId, application, channels);\n * ```\n */\nexport class EventsBatchController {\n  /**\n   * Create a new EventsBatchController instance.\n   *\n   * @param metricsHandler - The metrics handler for gathering channel info\n   */\n  constructor(private readonly metricsHandler: MetricsHandler) {}\n\n  /**\n   * Handle the batch events request.\n   *\n   * This method:\n   * 1. Parses and validates the request body\n   * 2. Dispatches each event to its channel\n   * 3. Gathers metrics for events that request channel info\n   * 4. Returns the batch results\n   *\n   * @param request - The HTTP request object\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from route parameters\n   * @param application - The verified application instance\n   * @param channels - The channel manager scoped to the application\n   * @returns Response object with batch results\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * EventsBatchController - Handles batch event dispatching",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * Implements POST /apps/:appId/batch_events endpoint for triggering",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * multiple events in a single API call. Supports batches of up to 10 events.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Features:",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * - Validates batch size (max 10 events)",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * - Dispatches events using EventDispatcher",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * - Optionally gathers channel metrics for each event",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * - Returns batch results with channel info",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " * Request Format:",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " *     {",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"name\": \"my-event\",",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"channel\": \"my-channel\",",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"socket_id\": \"123.456\",",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"info\": \"subscription_count\"",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " * Response Format:",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 5 },",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 3 }",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * // Usage with dependency injection",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * const controller = new EventsBatchController(metricsHandler);",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * const response = await controller.handle(request, connection, appId, application, channels);",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new EventsBatchController instance.",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param metricsHandler - The metrics handler for gathering channel info",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private readonly metricsHandler: MetricsHandler) {}",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the batch events request.",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Dispatches each event to its channel",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Gathers metrics for events that request channel info",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Returns the batch results",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from route parameters",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The verified application instance",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager scoped to the application",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response object with batch results",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.0920637995004654
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 37,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 57,
                    "column": 1
                  }
                },
                "contents": "/**\n * Connection data structure.\n */\nexport interface ConnectionData {\n  /** User identifier */\n  user_id: string;\n  /** Additional connection metadata */\n  [key: string]: unknown;\n}\n\n/**\n * Channel interface for metrics gathering.\n */\nexport interface Channel {\n  /** Get the channel name */\n  name(): string\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection data structure.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ConnectionData {",
                    "lineNumber": 43,
                    "isSignature": true
                  },
                  {
                    "text": "  /** User identifier */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "  user_id: string;",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Additional connection metadata */",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  [key: string]: unknown;",
                    "lineNumber": 47,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 48,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel interface for metrics gathering.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "export interface Channel {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get the channel name */",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  name(): string",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.08923029899597168
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Request metrics from all subscribers.\n   *\n   * @param application - The application to request metrics for\n   * @param key - Unique key for correlating responses\n   * @param type - The type of metrics to request\n   * @param options - Additional options for the metrics request\n   */\n  protected requestMetricsFromSubscribers(\n    application: Application,\n    key: string,\n    type: string,\n    options: MetricsOptions | null,\n  ): void {\n    if (!this.pubSubProvider) {\n      return;\n    }\n    this.pubSubProvider\n      .publish({\n        type: \"metrics\",\n        key,\n        application: this.serializeApplication(application),\n        payload: { type, options },\n      })\n      .then((total) => {\n        this.subscribers = total;\n      });\n  }\n\n  /**\n   * Merge the given metrics into a single result set.\n   *\n   * @param metrics - Array of metrics from different subscribers\n   * @param type - The type of metrics being merged\n   * @returns Merged metrics\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 332,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 333,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 334,
                    "isSignature": false
                  },
                  {
                    "text": "   * Request metrics from all subscribers.",
                    "lineNumber": 335,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 336,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to request metrics for",
                    "lineNumber": 337,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param key - Unique key for correlating responses",
                    "lineNumber": 338,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to request",
                    "lineNumber": 339,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 340,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 341,
                    "isSignature": false
                  },
                  {
                    "text": "  protected requestMetricsFromSubscribers(",
                    "lineNumber": 342,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 343,
                    "isSignature": false
                  },
                  {
                    "text": "    key: string,",
                    "lineNumber": 344,
                    "isSignature": false
                  },
                  {
                    "text": "    type: string,",
                    "lineNumber": 345,
                    "isSignature": false
                  },
                  {
                    "text": "    options: MetricsOptions | null,",
                    "lineNumber": 346,
                    "isSignature": false
                  },
                  {
                    "text": "  ): void {",
                    "lineNumber": 347,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!this.pubSubProvider) {",
                    "lineNumber": 348,
                    "isSignature": false
                  },
                  {
                    "text": "      return;",
                    "lineNumber": 349,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 350,
                    "isSignature": false
                  },
                  {
                    "text": "    this.pubSubProvider",
                    "lineNumber": 351,
                    "isSignature": false
                  },
                  {
                    "text": "      .publish({",
                    "lineNumber": 352,
                    "isSignature": false
                  },
                  {
                    "text": "        type: \"metrics\",",
                    "lineNumber": 353,
                    "isSignature": false
                  },
                  {
                    "text": "        key,",
                    "lineNumber": 354,
                    "isSignature": false
                  },
                  {
                    "text": "        application: this.serializeApplication(application),",
                    "lineNumber": 355,
                    "isSignature": false
                  },
                  {
                    "text": "        payload: { type, options },",
                    "lineNumber": 356,
                    "isSignature": false
                  },
                  {
                    "text": "      })",
                    "lineNumber": 357,
                    "isSignature": false
                  },
                  {
                    "text": "      .then((total) => {",
                    "lineNumber": 358,
                    "isSignature": false
                  },
                  {
                    "text": "        this.subscribers = total;",
                    "lineNumber": 359,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 360,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 361,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 362,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 363,
                    "isSignature": false
                  },
                  {
                    "text": "   * Merge the given metrics into a single result set.",
                    "lineNumber": 364,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 365,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param metrics - Array of metrics from different subscribers",
                    "lineNumber": 366,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics being merged",
                    "lineNumber": 367,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Merged metrics",
                    "lineNumber": 368,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 369,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.08449749648571014
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\n\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n  protected validate(payload: unknown): ValidationErrors | null {\n    const errors: ValidationErrors = {};\n\n    // Validate batch field exists\n    if (!payload || typeof payload !== \"object\") {\n      errors.batch = [\"The batch field is required.\"];\n      return errors;\n    }\n\n    const payloadObj = payload as Record<string, unknown>;\n\n    if (!payloadObj.batch) {\n      errors.batch = [\"The batch field is required.\"];\n      return errors;\n    }\n\n    // Validate batch is an array\n    if (!Array.isArray(payloadObj.batch)) {\n      errors.batch = [\"The batch field must be an array.\"];\n      return errors;\n    }\n\n    // Validate batch size (max 10 events)\n    if (payloadObj.batch.length > 10) {\n      errors.batch = [\"The batch may not contain more than 10 events.\"];\n      return errors;\n    }\n\n    // Validate each batch item\n    const batch = payloadObj.batch as unknown[];\n    batch.forEach((item: unknown, index: number) => {\n      if\n    }\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "  protected validate(payload: unknown): ValidationErrors | null {",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    const errors: ValidationErrors = {};",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch field exists",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payload || typeof payload !== \"object\") {",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field is required.\"];",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "    const payloadObj = payload as Record<string, unknown>;",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payloadObj.batch) {",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field is required.\"];",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch is an array",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!Array.isArray(payloadObj.batch)) {",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field must be an array.\"];",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch size (max 10 events)",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "    if (payloadObj.batch.length > 10) {",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch may not contain more than 10 events.\"];",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate each batch item",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = payloadObj.batch as unknown[];",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "    batch.forEach((item: unknown, index: number) => {",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "      if",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.084266796708107
            }
          ]
        }
      }
    }

### Assistant

Reviewing the Connection contract and HttpConnection implementation:

### Tool · read (started)

    * **path:** `src/contracts/connection.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/contracts/connection.ts`
    * **status:** success
        * lines: 1-346
    * **content:**

    import type { Application } from "../application";
    import type { FrameOpcode, IWebSocketConnection } from "./websocket-connection";
    
    /**
     * Connection State Machine
     *
     * The Connection class tracks connection state using a timestamp-based state machine:
     *
     * State Transitions:
     * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)
     * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)
     * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)
     *
     * State Determination:
     * - isActive(): time() < lastSeenAt + app.pingInterval()
     * - isInactive(): !isActive()
     * - isStale(): isInactive() && hasBeenPinged
     *
     * Lifecycle:
     * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false
     * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false
     * 3. No activity for pingInterval → isInactive() = true
     * 4. Ping sent → ping() → hasBeenPinged = true
     * 5. Pong received → pong() → hasBeenPinged = false
     * 6. No response after ping → isStale() = true → connection pruned
     *
     * Timestamps:
     * - All timestamps use SECONDS (not milliseconds)
     * - Use Math.floor(Date.now() / 1000) to get current time in seconds
     * - This matches PHP's time() function behavior
     */
    
    /**
     * Connection Abstract Class
     *
     * Application-aware connection wrapper that manages WebSocket connection state,
     * tracking, and lifecycle. Extends raw WebSocketConnection with application context,
     * activity tracking, and state management.
     *
     * Key Responsibilities:
     * - Wrap WebSocketConnection with application context
     * - Track connection activity via lastSeenAt timestamp
     * - Implement state machine (Active/Inactive/Stale)
     * - Manage ping/pong state for connection health
     * - Generate normalized socket IDs
     * - Provide connection lifecycle methods
     *
     * @abstract
     *
     * @example
     * ```typescript
     * class ReverbConnection extends Connection {
     *   identifier(): string {
     *     return String(this.connection.id());
     *   }
     *
     *   id(): string {
     *     if (!this._id) {
     *       this._id = this.generateId();
     *     }
     *     return this._id;
     *   }
     *
     *   send(message: string): void {
     *     this.connection.send(message);
     *     // Dispatch MessageSent event
     *   }
     *
     *   control(type: FrameOpcode = FrameOpcode.PING): void {
     *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });
     *   }
     *
     *   terminate(): void {
     *     this.connection.close();
     *   }
     * }
     * ```
     */
    export abstract class Connection {
      /**
       * The last time the connection was seen (in seconds, not milliseconds).
       *
       * Initialized to current time when connection is created.
       * Updated via touch() when activity is detected.
       * Used to determine connection state (active/inactive/stale).
       *
       * @protected
       */
      protected lastSeenAt: number;
    
      /**
       * Stores the ping state of the connection.
       *
       * Set to true when a ping is sent to the connection.
       * Set to false when a pong is received or activity is detected.
       * Used to determine if connection is stale (inactive + pinged).
       *
       * @protected
       */
      protected hasBeenPinged = false;
    
      /**
       * Indicates if the connection uses control frames for activity tracking.
       *
       * When true, the connection uses PING/PONG frames to track activity.
       * When false, the connection may use other mechanisms for activity tracking.
       *
       * @protected
       */
      protected _usesControlFrames = false;
    
      /**
       * Create a new connection instance.
       *
       * @param connection - The underlying WebSocket connection
       * @param application - The application this connection belongs to
       * @param origin - The origin of the connection (nullable)
       */
      constructor(
        protected readonly connection: IWebSocketConnection,
        protected readonly application: Application,
        protected readonly origin: string | null,
      ) {
        // Initialize lastSeenAt with current time in SECONDS
        this.lastSeenAt = Math.floor(Date.now() / 1000);
      }
    
      /**
       * Get the raw socket connection identifier.
       *
       * Returns the underlying WebSocket connection's identifier.
       * This is typically a raw socket ID or resource identifier.
       *
       * @returns The raw connection identifier as a string
       *
       * @abstract
       */
      abstract identifier(): string;
    
      /**
       * Get the normalized socket ID.
       *
       * Returns a Pusher-compatible socket ID (format: "number.number").
       * This ID is generated once and cached for the connection lifetime.
       *
       * @returns The normalized socket ID (e.g., "123456789.987654321")
       *
       * @abstract
       */
      abstract id(): string;
    
      /**
       * Send a message to the connection.
       *
       * Sends a message over the WebSocket connection.
       * Implementations should dispatch a MessageSent event after sending.
       *
       * @param message - The message to send
       *
       * @abstract
       */
      abstract send(message: string): void;
    
      /**
       * Send a control frame to the connection.
       *
       * Sends a WebSocket control frame (PING, PONG, or CLOSE).
       * Default is PING frame for connection health checks.
       *
       * @param type - The frame opcode (default: PING)
       *
       * @abstract
       */
      abstract control(type?: FrameOpcode): void;
    
      /**
       * Terminate a connection.
       *
       * Closes the underlying WebSocket connection.
       * This is the final operation on a connection.
       *
       * @abstract
       */
      abstract terminate(): void;
    
      /**
       * Get the application the connection belongs to.
       *
       * @returns The Application instance
       */
      app(): Application {
        return this.application;
      }
    
      /**
       * Get the origin of the connection.
       *
       * @returns The connection origin or null
       */
      getOrigin(): string | null {

  … truncated (145 lines omitted)

### Tool · read (started)

    * **path:** `src/servers/reverb/http/connection.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/http/connection.ts`
    * **status:** success
        * lines: 1-129
    * **content:**

    /**
     * HTTP Connection Wrapper
     *
     * Wraps an underlying socket/connection and manages state for HTTP message handling.
     * This class is used by the Reverb server to manage HTTP connections before they're
     * upgraded to WebSocket connections.
     */
    export class Connection {
      private id: number;
      private connected = false;
      private _buffer = "";
    
      /**
       * Create a new HTTP connection instance.
       *
       * @param connection - The underlying socket/connection object
       */
      constructor(
        private readonly connection: {
          stream?: unknown;
          write?: (data: string | Uint8Array) => void;
          end?: () => void;
        },
      ) {
        this.id = Number(connection.stream) || 0;
      }
    
      /**
       * Get the connection ID.
       *
       * @returns The connection ID as a number
       */
      getId(): number {
        return this.id;
      }
    
      /**
       * Mark the connection as connected.
       *
       * @returns This connection instance for method chaining
       */
      connect(): this {
        this.connected = true;
        return this;
      }
    
      /**
       * Determine whether the connection is connected.
       *
       * @returns true if connected, false otherwise
       */
      isConnected(): boolean {
        return this.connected;
      }
    
      /**
       * Get the HTTP message buffer.
       *
       * @returns The current buffer content as a string
       */
      buffer(): string {
        return this._buffer;
      }
    
      /**
       * Determine whether the connection has an HTTP message buffer set.
       *
       * @returns true if buffer contains data, false if empty
       */
      hasBuffer(): boolean {
        return this._buffer !== "";
      }
    
      /**
       * Get the HTTP message buffer length.
       *
       * @returns The buffer length as a number
       */
      bufferLength(): number {
        return this._buffer.length;
      }
    
      /**
       * Append data to the HTTP message buffer.
       *
       * @param message - The data to append to the buffer
       * @returns This connection instance for method chaining
       */
      appendToBuffer(message: string): this {
        this._buffer += message;
        return this;
      }
    
      /**
       * Clear the HTTP message buffer.
       *
       * @returns This connection instance for method chaining
       */
      clearBuffer(): this {
        this._buffer = "";
        return this;
      }
    
      /**
       * Send data to the connection.
       *
       * @param data - The data to send
       * @returns This connection instance for method chaining
       */
      send(data: string | Uint8Array): this {
        if (this.connection.write) {
          this.connection.write(data);
        }
        return this;
      }
    
      /**
       * Close the connection.
       *
       * @returns This connection instance for method chaining
       */
      close(): this {
        if (this.connection.end) {
          this.connection.end();
        }
        return this;
      }
    }

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · grep (started)

    {
      "args": {
        "pattern": "noExplicitAny",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_2f4a87be-6362-45e3-a0c1-efb50c05659"
      }
    }

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1180-1229
    * **content:**

        // Convert Headers to Record<string, string>
        const headers: Record<string, string> = {};
        req.headers.forEach((value, key) => {
          headers[key.toLowerCase()] = value;
        });
    
        return {
          method,
          path: pathWithQuery,
          url: req.url, // Include full URL with query string for controllers to access query params
          httpVersion: "1.1",
          body,
          getMethod(): string {
            return method;
          },
          getPath(): string {
            // Return path without query string for Pusher signature verification
            // Pusher signatures are calculated over the path without the query string
            return pathWithoutQuery;
          },
          getHost(): string {
            return host;
          },
          getHeader(name: string): string | undefined {
            return headers[name.toLowerCase()];
          },
          getHeaders(): Record<string, string> {
            return { ...headers };
          },
          getUri(): { path: string; host: string } {
            return { path: pathWithoutQuery, host };
          },
          getSize(): number {
            return Buffer.byteLength(body, "utf8");
          },
        };
      }
    
      /**
       * Create a mock HTTP connection for controller use
       *
       * @returns HTTP Connection object
       *
       * @private
       */
      private static createHttpConnection(): HttpConnection {
        return new HttpConnection({
          stream: Math.floor(Math.random() * 1000000),
        });
      }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "noExplicitAny",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_2f4a87be-6362-45e3-a0c1-efb50c05659"
      },
      "result": {
        "success": {
          "pattern": "noExplicitAny",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Assistant

Checking what EventsBatchController.handle expects:

### Tool · read (started)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** success
        * lines: 70-99
    * **content:**

     */
    export class EventsBatchController {
      /**
       * Create a new EventsBatchController instance.
       *
       * @param metricsHandler - The metrics handler for gathering channel info
       */
      constructor(private readonly metricsHandler: MetricsHandler) {}
    
      /**
       * Handle the batch events request.
       *
       * This method:
       * 1. Parses and validates the request body
       * 2. Dispatches each event to its channel
       * 3. Gathers metrics for events that request channel info
       * 4. Returns the batch results
       *
       * @param request - The HTTP request object
       * @param connection - The HTTP connection
       * @param appId - The application ID from route parameters
       * @param application - The verified application instance
       * @param channels - The channel manager scoped to the application
       * @returns Response object with batch results
       */
      async handle(
        request: IHttpRequest,
        _connection: Connection,
        _appId: string,
        application: Application,

### Tool · grep (started)

    {
      "args": {
        "pattern": ": any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_00fe8959-2352-43c0-b007-789d3b271af"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": ": any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_00fe8959-2352-43c0-b007-789d3b271af"
      },
      "result": {
        "success": {
          "pattern": ": any",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1-50
    * **content:**

    /**
     * Factory for creating Reverb WebSocket servers
     *
     * Creates and configures HTTP servers with WebSocket support for the Pusher protocol.
     * Handles routing, TLS/SSL configuration, and protocol selection.
     *
     * @module Servers/Reverb/Factory
     */
    
    import type { ServeOptions, ServerWebSocket, WebSocket } from "bun";
    import type { Application } from "../../application";
    import { ApplicationManager } from "../../application-manager";
    import { Certificate } from "../../certificate";
    import type { ReverbConfig } from "../../config/types";
    import { Connection as ReverbConnection } from "../../connection";
    import type { IApplicationProvider } from "../../contracts/application-provider";
    import { ServerProvider } from "../../contracts/server-provider";
    import { FrameOpcode } from "../../contracts/websocket-connection";
    import { CliLogger } from "../../loggers/cli-logger";
    import { Log } from "../../loggers/log";
    import type { NullLogger } from "../../loggers/null-logger";
    import { ClientEvent } from "../../protocols/pusher/client-event";
    import { EventHandler } from "../../protocols/pusher/event-handler";
    import { ChannelController } from "../../protocols/pusher/http/controllers/channel-controller";
    import { channelUsersController } from "../../protocols/pusher/http/controllers/channel-users-controller";
    import { ChannelsController } from "../../protocols/pusher/http/controllers/channels-controller";
    import { connectionsController } from "../../protocols/pusher/http/controllers/connections-controller";
    import { EventsBatchController } from "../../protocols/pusher/http/controllers/events-batch-controller";
    import { EventsController } from "../../protocols/pusher/http/controllers/events-controller";
    import { UsersTerminateController } from "../../protocols/pusher/http/controllers/users-terminate-controller";
    import { ArrayChannelConnectionManager } from "../../protocols/pusher/managers/array-channel-connection-manager";
    import { ArrayChannelManager } from "../../protocols/pusher/managers/array-channel-manager";
    import { MetricsHandler } from "../../protocols/pusher/metrics-handler";
    import { Server as PusherServer } from "../../protocols/pusher/server";
    import { Connection as WebSocketConnection } from "./connection";
    import { Connection as HttpConnection } from "./http/connection";
    import { Response as HttpResponse } from "./http/response";
    import type { IHttpRequest } from "./http/router";
    
    /**
     * WebSocket connection data stored in Bun's ws.data
     */
    interface WebSocketData {
      app?: Application;
      origin?: string | null;
      connection?: ReverbConnection;
      onMessage?: (message: string | Buffer) => void;
      onOpen?: () => void;
      onClose?: () => void;
      onPing?: () => void;

### Assistant

Checking the PHP implementation to understand the expected connection type:

### Tool · read (started)

    * **path:** `reverb/src/Http/Controllers/EventsBatchController.php`
    * **status:** pending

### Tool · read (completed)

    * **path:** `reverb/src/Http/Controllers/EventsBatchController.php`
    * **status:** error
    * **details:**

    {
      "errorMessage": "File not found"
    }

### Tool · grep (started)

    {
      "args": {
        "pattern": "any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": true,
        "multiline": false,
        "toolCallId": "tool_ade0ca03-b7fe-4be2-a912-1f1f42d3c2c"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": true,
        "multiline": false,
        "toolCallId": "tool_ade0ca03-b7fe-4be2-a912-1f1f42d3c2c"
      },
      "result": {
        "success": {
          "pattern": "any",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "tests/feature/health-check-controller.test.ts",
                    "matches": [
                      {
                        "lineNumber": 48,
                        "content": "    // Health check endpoint should work without any authentication",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "tests/unit/jobs/ping-inactive-connections.test.ts",
                    "matches": [
                      {
                        "lineNumber": 185,
                        "content": "    // Should not log any \"Connection Pinged\" messages",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  }
                ],
                "totalLines": 2,
                "totalMatchedLines": 2,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (started)

    * **path:** `src/servers/reverb/http/router.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/http/router.ts`
    * **status:** success
        * lines: 490-549
    * **content:**

     * HTTP Request interface
     *
     * Represents an HTTP request object with methods to access headers, method, path, etc.
     */
    export interface IHttpRequest {
      /**
       * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access
       */
      method: string;
    
      /**
       * Request path with query string - property for direct access
       */
      path: string;
    
      /**
       * Request body content - property for direct access
       */
      body: string;
    
      /**
       * Get the HTTP method (GET, POST, PUT, DELETE, etc.)
       */
      getMethod(): string;
    
      /**
       * Get the request path
       */
      getPath(): string;
    
      /**
       * Get the request host
       */
      getHost(): string;
    
      /**
       * Get a specific header value
       */
      getHeader(name: string): string | undefined;
    
      /**
       * Get all headers
       */
      getHeaders(): Record<string, string>;
    
      /**
       * Get the request URI
       */
      getUri(): {
        path: string;
        host: string;
      };
    }
    
    /**
     * Route matcher interface
     *
     * Handles route matching and context management
     */
    export interface IRouteMatcher {

### Assistant

Running lint to identify the exact issues:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | head -100`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | head -100`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | head -100`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    $ biome check .
    Checked 110 files in 33ms. No fixes applied.

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | head -100`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    $ tsc --noEmit

### Assistant

Checking the specific files mentioned in the review:

### Tool · read (started)

    * **path:** `tests/e2e/websocket-connection.test.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/e2e/websocket-connection.test.ts`
    * **status:** success
        * lines: 90-104
    * **content:**

        ws.close();
      });
    
      it("should receive connection_established message", async () => {
        const ws = new WebSocket(`ws://127.0.0.1:${testPort}/app/${testAppKey}`);
    
        const message = await new Promise<unknown>((resolve, reject) => {
          const timeout = setTimeout(() => {
            ws.close();
            reject(new Error("Message timeout"));
          }, 5000);
    
          ws.onmessage = (event) => {
            clearTimeout(timeout);
            try {

### Tool · read (started)

    * **path:** `tests/feature/health-check-controller.test.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/feature/health-check-controller.test.ts`
    * **status:** success
        * lines: 1-15
    * **content:**

    import { afterAll, beforeAll, describe, expect, it } from "bun:test";
    import type { Server } from "bun";
    import { Factory } from "../../src/servers/reverb/factory";
    
    describe("Health Check Controller", () => {
      let server: Server;
      const port = 8082; // Use different port to avoid conflicts
    
      beforeAll(() => {
        // Set up test environment
        process.env.REVERB_APP_KEY = "test-key";
        process.env.REVERB_APP_SECRET = "test-secret";
        process.env.REVERB_APP_ID = "test-id";
    
        // Initialize factory

### Tool · read (started)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** success
        * lines: 20-69
    * **content:**

    }
    
    // Mock channel connection factory
    function createMockChannelConnection(
      connection: Connection,
      data: Map<string, unknown> = new Map(),
    ): ChannelConnection {
      return {
        connection: () => connection,
        data: () => data,
      } as ChannelConnection;
    }
    
    describe("Channel", () => {
      let channel: Channel;
      let mockConnectionManager: ChannelConnectionManager;
      let mockChannelManager: ChannelManager;
      let mockLogger: ILogger;
      let connection1: Connection;
      let connection2: Connection;
      let connection3: Connection;
    
      beforeEach(() => {
        // Create mock connections
        connection1 = createMockConnection("111.111");
        connection2 = createMockConnection("222.222");
        connection3 = createMockConnection("333.333");
    
        // Create mock logger
        mockLogger = {
          info: mock(() => {}),
          error: mock(() => {}),
          message: mock(() => {}),
        } as unknown as ILogger;
    
        // Create shared connections map for the channel
        const connections = new Map<string, ChannelConnection>();
    
        // Create mock connection manager with proper state management
        mockConnectionManager = {
          for: mock((_channelName: string) => mockConnectionManager),
          add: (conn: Connection, data: Map<string, unknown>) => {
            connections.set(conn.id(), createMockChannelConnection(conn, data));
          },
          remove: (conn: Connection) => {
            connections.delete(conn.id());
          },
          find: (conn: Connection) => {
            return connections.get(conn.id()) || null;
          },

### Tool · read (started)

    * **path:** `tests/unit/events/event-dispatcher.test.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `biome.json`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/unit/events/event-dispatcher.test.ts`
    * **status:** success
        * lines: 15-324
    * **content:**

          });
    
          EventDispatcher.emit("test:event", {});
          expect(called).toBe(true);
        });
    
        it("should pass event data to listener", () => {
          let receivedData: unknown = null;
          EventDispatcher.on("test:data", (data) => {
            receivedData = data;
          });
    
          const testData = { foo: "bar", num: 42 };
          EventDispatcher.emit("test:data", testData);
          expect(receivedData).toEqual(testData);
        });
    
        it("should call multiple listeners for same event", () => {
          let count = 0;
          EventDispatcher.on("test:multi", () => count++);
          EventDispatcher.on("test:multi", () => count++);
          EventDispatcher.on("test:multi", () => count++);
    
          EventDispatcher.emit("test:multi", {});
          expect(count).toBe(3);
        });
    
        it("should return unsubscribe function", () => {
          let called = false;
          const unsubscribe = EventDispatcher.on("test:unsub", () => {
            called = true;
          });
    
          // Call once - should work
          EventDispatcher.emit("test:unsub", {});
          expect(called).toBe(true);
    
          // Unsubscribe
          called = false;
          unsubscribe();
    
          // Call again - should not work
          EventDispatcher.emit("test:unsub", {});
          expect(called).toBe(false);
        });
      });
    
      describe("once()", () => {
        it("should call listener only once", () => {
          let count = 0;
          EventDispatcher.once("test:once", () => count++);
    
          EventDispatcher.emit("test:once", {});
          EventDispatcher.emit("test:once", {});
          EventDispatcher.emit("test:once", {});
    
          expect(count).toBe(1);
        });
    
        it("should pass event data to listener", () => {
          let receivedData: unknown = null;
          EventDispatcher.once("test:once:data", (data) => {
            receivedData = data;
          });
    
          const testData = { value: 123 };
          EventDispatcher.emit("test:once:data", testData);
          expect(receivedData).toEqual(testData);
        });
    
        it("should return unsubscribe function", () => {
          let called = false;
          const unsubscribe = EventDispatcher.once("test:once:unsub", () => {
            called = true;
          });
    
          // Unsubscribe before calling
          unsubscribe();
    
          // Try to call - should not work
          EventDispatcher.emit("test:once:unsub", {});
          expect(called).toBe(false);
        });
      });
    
      describe("off()", () => {
        it("should remove specific listener", () => {
          let count1 = 0;
          let count2 = 0;
    
          const listener1 = () => count1++;
          const listener2 = () => count2++;
    
          EventDispatcher.on("test:off", listener1);
          EventDispatcher.on("test:off", listener2);
    
          // Both should be called
          EventDispatcher.emit("test:off", {});
          expect(count1).toBe(1);
          expect(count2).toBe(1);
    
          // Remove first listener
          EventDispatcher.off("test:off", listener1);
    
          // Only second should be called
          EventDispatcher.emit("test:off", {});
          expect(count1).toBe(1);
          expect(count2).toBe(2);
        });
    
        it("should not error when removing non-existent listener", () => {
          const listener = () => {};
          expect(() => {
            EventDispatcher.off("test:nonexistent", listener);
          }).not.toThrow();
        });
      });
    
      describe("emit()", () => {
        it("should not error when emitting to event with no listeners", () => {
          expect(() => {
            EventDispatcher.emit("test:noop", {});
          }).not.toThrow();
        });
    
        it("should handle listener errors gracefully", () => {
          let listener2Called = false;
    
          EventDispatcher.on("test:error", () => {
            throw new Error("Test error");
          });
    
          EventDispatcher.on("test:error", () => {
            listener2Called = true;
          });
    
          // Should not throw, second listener should still be called
          expect(() => {
            EventDispatcher.emit("test:error", {});
          }).not.toThrow();
    
          expect(listener2Called).toBe(true);
        });
      });
    
      describe("emitAsync()", () => {
        it("should handle async listeners", async () => {
          let called = false;
    
          EventDispatcher.on("test:async", async () => {
            await new Promise((resolve) => setTimeout(resolve, 10));
            called = true;
          });
    
          await EventDispatcher.emitAsync("test:async", {});
          expect(called).toBe(true);
        });
    
        it("should wait for all async listeners", async () => {
          const results: number[] = [];
    
          EventDispatcher.on("test:async:multi", async () => {
            await new Promise((resolve) => setTimeout(resolve, 20));
            results.push(1);
          });
    
          EventDispatcher.on("test:async:multi", async () => {
            await new Promise((resolve) => setTimeout(resolve, 10));
            results.push(2);
          });
    
          await EventDispatcher.emitAsync("test:async:multi", {});
    
          // Both should have been called
          expect(results).toHaveLength(2);
          expect(results).toContain(1);
          expect(results).toContain(2);
        });
    
        it("should handle async errors gracefully", async () => {
          let listener2Called = false;
    
          EventDispatcher.on("test:async:error", async () => {
            throw new Error("Async test error");
          });
    
          EventDispatcher.on("test:async:error", async () => {
            listener2Called = true;
          });
    
          // Should not throw, second listener should still be called
          await expect(
            EventDispatcher.emitAsync("test:async:error", {}),
          ).resolves.toBeUndefined();
          expect(listener2Called).toBe(true);
        });
      });
    
      describe("removeAllListeners()", () => {
        it("should remove all listeners for specific event", () => {

  … truncated (110 lines omitted)

### Tool · read (completed)

    * **path:** `biome.json`
    * **status:** success
        * lines: 1-48
    * **content:**

    {
      "$schema": "https://biomejs.dev/schemas/2.3.5/schema.json",
      "vcs": {
        "enabled": true,
        "clientKind": "git",
        "useIgnoreFile": true
      },
      "files": {
        "includes": ["example/**", "scripts/**", "src/**", "tests/**", "!!**/dist"]
      },
      "formatter": {
        "enabled": true,
        "indentStyle": "space"
      },
      "css": {
        "parser": {
          "tailwindDirectives": true
        }
      },
      "linter": {
        "enabled": true,
        "rules": {
          "recommended": true,
          "suspicious": {
            "noExplicitAny": "error",
            "noImplicitAnyLet": "error"
          },
          "style": {
            "useConst": "error"
          }
        }
      },
      "javascript": {
        "formatter": {
          "quoteStyle": "double"
        },
        "globals": ["Bun"]
      },
      "assist": {
        "enabled": true,
        "actions": {
          "source": {
            "organizeImports": "on"
          }
        }
      }
    }

### Assistant

Searching for explicit any types:

### Tool · grep (started)

    {
      "args": {
        "pattern": "\\bany\\b",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_5e4c0f2d-2a0e-461e-a764-15f07f0c0c7"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "\\bany\\b",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_5e4c0f2d-2a0e-461e-a764-15f07f0c0c7"
      },
      "result": {
        "success": {
          "pattern": "\\bany\\b",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "tests/feature/health-check-controller.test.ts",
                    "matches": [
                      {
                        "lineNumber": 48,
                        "content": "    // Health check endpoint should work without any authentication",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "tests/unit/jobs/ping-inactive-connections.test.ts",
                    "matches": [
                      {
                        "lineNumber": 185,
                        "content": "    // Should not log any \"Connection Pinged\" messages",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  }
                ],
                "totalLines": 2,
                "totalMatchedLines": 2,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (started)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** pending

### Tool · sem Search (started)

    {
      "args": {
        "query": "What does EventsBatchController handle method expect for the connection parameter?",
        "targetDirectories": [],
        "explanation": ""
      }
    }

### Tool · read (completed)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** success
        * lines: 55-64
    * **content:**

        // Create shared connections map for the channel
        const connections = new Map<string, ChannelConnection>();
    
        // Create mock connection manager with proper state management
        mockConnectionManager = {
          for: mock((_channelName: string) => mockConnectionManager),
          add: (conn: Connection, data: Map<string, unknown>) => {
            connections.set(conn.id(), createMockChannelConnection(conn, data));
          },
          remove: (conn: Connection) => {

### Tool · sem Search (completed)

    {
      "args": {
        "query": "What does EventsBatchController handle method expect for the connection parameter?",
        "targetDirectories": [],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" startLine=\"27\" endLine=\"281\">\n    27|/**\n    28| * EventsBatchController - Handles batch event dispatching\n    29| *\n    30| * Implements POST /apps/:appId/batch_events endpoint for triggering\n    31| * multiple events in a single API call. Supports batches of up to 10 events.\n    32| *\n    33| * Key Features:\n    34| * - Validates batch size (max 10 events)\n    35| * - Dispatches events using EventDispatcher\n    36| * - Optionally gathers channel metrics for each event\n    37| * - Returns batch results with channel info\n    38| *\n    39| * Request Format:\n    40| * ```json\n    41| * {\n    42| *   \"batch\": [\n    43| *     {\n    44| *       \"name\": \"my-event\",\n    45| *       \"channel\": \"my-channel\",\n    46| *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",\n    47| *       \"socket_id\": \"123.456\",\n    48| *       \"info\": \"subscription_count\"\n    49| *     }\n    50| *   ]\n    51| * }\n    52| * ```\n    53| *\n    54| * Response Format:\n    55| * ```json\n    56| * {\n    57| *   \"batch\": [\n    58| *     { \"subscription_count\": 5 },\n    59| *     { \"subscription_count\": 3 }\n    60| *   ]\n    61| * }\n    62| * ```\n    63| *\n    64| * @example\n    65| * ```typescript\n    66| * // Usage with dependency injection\n    67| * const controller = new EventsBatchController(metricsHandler);\n    68| * const response = await controller.handle(request, connection, appId, application, channels);\n    69| * ```\n    70| */\n    71|export class EventsBatchController {\n    72|  /**\n    73|   * Create a new EventsBatchController instance.\n    74|   *\n    75|   * @param metricsHandler - The metrics handler for gathering channel info\n    76|   */\n    77|  constructor(private readonly metricsHandler: MetricsHandler) {}\n    78|\n    79|  /**\n    80|   * Handle the batch events request.\n    81|   *\n    82|   * This method:\n    83|   * 1. Parses and validates the request body\n    84|   * 2. Dispatches each event to its channel\n    85|   * 3. Gathers metrics for events that request channel info\n    86|   * 4. Returns the batch results\n    87|   *\n    88|   * @param request - The HTTP request object\n    89|   * @param connection - The HTTP connection\n    90|   * @param appId - The application ID from route parameters\n    91|   * @param application - The verified application instance\n    92|   * @param channels - The channel manager scoped to the application\n    93|   * @returns Response object with batch results\n    94|   */\n    95|async handle(\n    96|    request: IHttpRequest,\n    97|    _connection: Connection,\n    98|    _appId: string,\n    99|    application: Application,\n   100|    channels: ChannelManager,\n   101|  ): Promise<Response> {\n   ...\n   127|const ;\n   128|    const batch = typedPayload.batch;\n   129|\n   130|    // Process each batch item\n   131|    const items = batch.map((item) => {\n   132|      // Dispatch the event\n   133|      const channelConnection = item.socket_id\n   134|        ? (channels.connections()[item.socket_id] ?? null)\n   135|        : null;\n   136|      const excludeConnection = channelConnection\n   137|        ? channelConnection.connection()\n   138|        : null;\n   139|\n   140|      dispatch(\n   141|        application,\n   142|        {\n   143|          event: item.name,\n   144|          channel: item.channel,\n   145|          data: item.data,\n   146|        },\n   147|        channels,\n   148|        excludeConnection,\n   149|      );\n   150|\n   151|      // Return promise for metrics gathering if requested\n   152|      return item.info\n   153|        ? this.metricsHandler.gather(application, \"channel\", {\n   154|            channel: item.channel,\n   155|            info: item.info,\n   156|          })\n   157|        : Promise.resolve({});\n   158|    });\n   159|\n   160|    // Check if any items requested metrics\n   161|    const hasMetrics = batch.some((item) => item.info);\n   162|\n   163|    if (hasMetrics) {\n   164|      // Wait for all metrics to be gathered\n   165|      const results = await Promise.all(items);\n   166|      return new Response({\n   167|        batch: results.map((result) => result || {}),\n   168|      });\n   169|    }\n   170|\n   171|    // No metrics requested, return empty batch object\n   172|    return new Response({ batch: {} });\n   173|  }\n   174|\n   175|  /**\n   176|   * Validate the request payload.\n   177|   *\n   178|   * Validates:\n   179|   * - batch is required and must be an array\n   180|   * - batch must contain at most 10 items\n   181|   * - Each item must have required fields (name, data, channel)\n   182|   * - Each item's fields must be strings\n   183|   *\n   184|   * @param payload - The parsed request body\n   185|   * @returns Validation errors object or null if valid\n   186|   */\n   ...\n   281|}\n</search_result>\n<search_result path=\"src/servers/reverb/factory.ts\" startLine=\"190\" endLine=\"1273\">\n   190|export class Factory {\n   ...\n   768|private static async handleEvents(\n   769|    req: Request,\n   770|    params: Record<string, string>,\n   771|  ): Promise<Response> {\n   ...\n   803|\n   804|      return new Response(\n   805|        JSON.stringify({\n   806|          error:\n   807|            error instanceof Error ? error.message : \"Internal server error\",\n   808|        }),\n   809|        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n   810|      );\n   811|    }\n   812|  }\n   813|\n   814|  /**\n   815|   * Handle batch event triggering\n   816|   *\n   817|   * @param req - The incoming request\n   818|   * @param params - Route parameters including appId\n   819|   * @returns JSON response with result\n   820|   *\n   821|   * @private\n   822|   */\n   823|  private static async handleBatchEvents(\n   824|    req: Request,\n   825|    params: Record<string, string>,\n   826|  ): Promise<Response> {\n   827|    if (\n   828|      !Factory.eventsBatchController ||\n   829|      !Factory.channelManager ||\n   830|      !Factory.appManager\n   831|    ) {\n   832|      return new Response(\"Server not initialized\", { status: 500 });\n   833|    }\n   834|\n   835|    if (!params.appId) {\n   836|      return new Response(\"Missing appId parameter\", { status: 400 });\n   837|    }\n   838|\n   839|    try {\n   840|      const httpRequest = await Factory.convertToHttpRequest(req);\n   841|      const httpConnection = Factory.createHttpConnection();\n   842|      const app = Factory.appManager.driver().findById(params.appId);\n   843|      const channelManager = Factory.channelManager.for(app);\n   844|\n   845|      const response = await Factory.eventsBatchController.handle(\n   846|        httpRequest,\n   847|        httpConnection,\n   848|        params.appId,\n   849|        app,\n   850|        channelManager,\n   851|      );\n   852|\n   853|      return Factory.convertToResponse(response);\n   854|    } catch (error) {\n   855|      console.error(\"Error handling batch events:\", error);\n   856|      return new Response(\n   857|        JSON.stringify({\n   858|          error:\n   859|            error instanceof Error ? error.message :\n   860|\n   ...\n   864|  }\n   ...\n  1273|}\n</search_result>\n<search_result path=\"reverb/src/Protocols/Pusher/Http/Controllers/EventsBatchController.php\" startLine=\"1\" endLine=\"88\">\n     1|<?php\n     2|\n     3|namespace Laravel\\Reverb\\Protocols\\Pusher\\Http\\Controllers;\n     4|\n     5|use Illuminate\\Contracts\\Validation\\Validator;\n     6|use Illuminate\\Support\\Facades\\Validator as ValidatorFacade;\n     7|use Laravel\\Reverb\\Protocols\\Pusher\\Concerns\\InteractsWithChannelInformation;\n     8|use Laravel\\Reverb\\Protocols\\Pusher\\EventDispatcher;\n     9|use Laravel\\Reverb\\Protocols\\Pusher\\MetricsHandler;\n    10|use Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection;\n    11|use Laravel\\Reverb\\Servers\\Reverb\\Http\\Response;\n    12|use Psr\\Http\\Message\\RequestInterface;\n    13|use React\\Promise\\PromiseInterface;\n    14|\n    15|use function React\\Promise\\all;\n    16|\n    17|class EventsBatchController extends Controller\n    18|{\n    19|    use InteractsWithChannelInformation;\n    20|\n    21|    /**\n    22|     * Handle the request.\n    23|     */\n    24|    public function __invoke(RequestInterface $request, Connection $connection, string $appId): Response|PromiseInterface\n    25|    {\n    26|        $this->verify($request, $connection, $appId);\n    27|\n    28|        $payload = json_decode($this->body, associative: true, flags: JSON_THROW_ON_ERROR);\n    29|\n    30|        $validator = $this->validator($payload);\n    31|\n    32|        if ($validator->fails()) {\n    33|            return new Response($validator->errors(), 422);\n    34|        }\n    35|\n    36|        $items = collect($payload['batch']);\n    37|\n    38|        $items = $items->map(function ($item) {\n    39|            EventDispatcher::dispatch(\n    40|                $this->application,\n    41|                [\n    42|                    'event' => $item['name'],\n    43|                    'channel' => $item['channel'],\n    44|                    'data' => $item['data'],\n    45|                ],\n    46|                isset($item['socket_id']) ? ($this->channels->connections()[$item['socket_id']] ?? null) : null\n    47|            );\n    48|\n    49|            return isset($item['info']) ? app(MetricsHandler::class)->gather(\n    50|                $this->application,\n    51|                'channel',\n    52|                ['channel' => $item['channel'], 'info' => $item['info']]\n    53|            ) : [];\n    54|        });\n    55|\n    56|        if ($items->contains(fn ($item) => ! empty($item))) {\n    57|            return all($items)->then(function ($items) {\n    58|                return new Response(['batch' => array_map(fn ($item) => (object) $item, $items)]);\n    59|            });\n    60|        }\n    61|\n    62|        return new Response(['batch' => (object) []]);\n    63|    }\n    64|\n    65|    /**\n    66|     * Get the info for the given channels.\n    67|     *\n    68|     * @return array<string, array<string, int>>\n    69|     */\n    70|    protected function getInfo(string $channel, string $info): array\n    71|    {\n    72|        $info = explode(',', $info);\n    73|        $count = count($this->channels->find($channel)->connections());\n    74|        $info = [\n    75|            'user_count' => in_array('user_count', $info) ? $count : null,\n    76|            'subscription_count' => in_array('subscription_count', $info) ? $count : null,\n    77|        ];\n    78|\n    79|        return array_filter($info, fn ($item) => $item !== null);\n    80|    }\n    81|\n    82|    /**\n    83|     * Create a validator for the incoming request payload.\n    84|     */\n    85|    protected function validator(array $payload): Validator\n    86|    {\n    87|        return ValidatorFacade::make($payload, [\n    88|            \n</search_result>\n\n<search_result path=\"src/protocols/pusher/http/controllers/events-controller.ts\" showSignaturesOnly=\"true\" startLine=\"52\" endLine=\"260\">\n   53|export class EventsController extends Controller {\n</search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Factory.php\" startLine=\"94\" endLine=\"141\"></search_result>\n<search_result path=\"reverb/src/Protocols/Pusher/Http/Controllers/EventsController.php\" startLine=\"23\" endLine=\"73\"></search_result>\n<search_result path=\"notes/2025-11-13-1300-review-fixes.md\" endLine=\"37\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" startLine=\"37\" endLine=\"57\"></search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" showSignaturesOnly=\"true\" startLine=\"132\" endLine=\"737\">\n  133|export class MetricsHandler {\n</search_result>\n<search_result path=\"src/protocols/pusher/metrics-handler.ts\" endLine=\"29\"></search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\nconst ;\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map((item) => {\n      // Dispatch the event\n      const channelConnection = item.socket_id\n        ? (channels.connections()[item.socket_id] ?? null)\n        : null;\n      const excludeConnection = channelConnection\n        ? channelConnection.connection()\n        : null;\n\n      dispatch(\n        application,\n        {\n          event: item.name,\n          channel: item.channel,\n          data: item.data,\n        },\n        channels,\n        excludeConnection,\n      );\n\n      // Return promise for metrics gathering if requested\n      return item.info\n        ? this.metricsHandler.gather(application, \"channel\", {\n            channel: item.channel,\n            info: item.info,\n          })\n        : Promise.resolve({});\n    });\n\n    // Check if any items requested metrics\n    const hasMetrics = batch.some((item) => item.info);\n\n    if (hasMetrics) {\n      // Wait for all metrics to be gathered\n      const results = await Promise.all(items);\n      return new Response({\n        batch: results.map((result) => result || {}),\n      });\n    }\n\n    // No metrics requested, return empty batch object\n    return new Response({ batch: {} });\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    },
                    {
                      "startPosition": {
                        "line": 95,
                        "column": 3
                      },
                      "endPosition": {
                        "line": 102,
                        "column": 5
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "const ;",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map((item) => {",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      // Dispatch the event",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelConnection = item.socket_id",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "        ? (channels.connections()[item.socket_id] ?? null)",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "      const excludeConnection = channelConnection",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "        ? channelConnection.connection()",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      dispatch(",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "        application,",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "          event: item.name,",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "          channel: item.channel,",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "          data: item.data,",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "        excludeConnection,",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "      // Return promise for metrics gathering if requested",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return item.info",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "        ? this.metricsHandler.gather(application, \"channel\", {",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "            channel: item.channel,",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "            info: item.info,",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "          })",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "        : Promise.resolve({});",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if any items requested metrics",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    const hasMetrics = batch.some((item) => item.info);",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    if (hasMetrics) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      // Wait for all metrics to be gathered",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      const results = await Promise.all(items);",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "        batch: results.map((result) => result || {}),",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // No metrics requested, return empty batch object",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ batch: {} });",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4578014612197876
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\n\n\n  /**\n   * Handle the batch events request.\n   *\n   * This method:\n   * 1. Parses and validates the request body\n   * 2. Dispatches each event to its channel\n   * 3. Gathers metrics for events that request channel info\n   * 4. Returns the batch results\n   *\n   * @param request - The HTTP request object\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from route parameters\n   * @param application - The verified application instance\n   * @param channels - The channel manager scoped to the application\n   * @returns Response object with batch results\n   */\n  async handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\n    // Parse request body\n    const body = this.getBody(request);\n    let payload: unknown;\n\n    try {\n      payload = JSON.parse(body) as { batch?: BatchItem[] };\n    } catch (_error) {\n      return new Response(\n        {\n          message: \"Invalid JSON in request body\",\n          errors: { body: [\"The body must be valid JSON\"] },\n        },\n        422,\n      );\n    }\n\n    // Validate payload\n    const validationErrors = this.validate(payload);\n    if (validationErrors) {\n      return new Response(\n        { message: \"Validation failed\", errors: validationErrors },\n        422,\n      );\n    }\n\n    const typedPayload = payload as { batch: BatchItem[] };\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map\n;\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the batch events request.",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Dispatches each event to its channel",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Gathers metrics for events that request channel info",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Returns the batch results",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from route parameters",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The verified application instance",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager scoped to the application",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response object with batch results",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse request body",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = this.getBody(request);",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "    let payload: unknown;",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "      payload = JSON.parse(body) as { batch?: BatchItem[] };",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (_error) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "          message: \"Invalid JSON in request body\",",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "          errors: { body: [\"The body must be valid JSON\"] },",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate payload",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "    const validationErrors = this.validate(payload);",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    if (validationErrors) {",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "        { message: \"Validation failed\", errors: validationErrors },",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "        422,",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    const typedPayload = payload as { batch: BatchItem[] };",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4493454694747925
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 189,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1272,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\nprivate static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle batch event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleBatchEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsBatchController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      const response = await Factory.eventsBatchController.handle(\n        httpRequest,\n        httpConnection,\n        params.appId,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling batch events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message :\n\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 184,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 185,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 190,
                    "isSignature": true
                  },
                  {
                    "text": "private static async handleEvents(",
                    "lineNumber": 768,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 769,
                    "isSignature": false
                  },
                  {
                    "text": "    params: Record<string, string>,",
                    "lineNumber": 770,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 771,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 803,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 804,
                    "isSignature": false
                  },
                  {
                    "text": "        JSON.stringify({",
                    "lineNumber": 805,
                    "isSignature": false
                  },
                  {
                    "text": "          error:",
                    "lineNumber": 806,
                    "isSignature": false
                  },
                  {
                    "text": "            error instanceof Error ? error.message : \"Internal server error\",",
                    "lineNumber": 807,
                    "isSignature": false
                  },
                  {
                    "text": "        }),",
                    "lineNumber": 808,
                    "isSignature": false
                  },
                  {
                    "text": "        { status: 500, headers: { \"Content-Type\": \"application/json\" } },",
                    "lineNumber": 809,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 810,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 811,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 812,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 813,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 814,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle batch event triggering",
                    "lineNumber": 815,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 816,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The incoming request",
                    "lineNumber": 817,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param params - Route parameters including appId",
                    "lineNumber": 818,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns JSON response with result",
                    "lineNumber": 819,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 820,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 821,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 822,
                    "isSignature": false
                  },
                  {
                    "text": "  private static async handleBatchEvents(",
                    "lineNumber": 823,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 824,
                    "isSignature": false
                  },
                  {
                    "text": "    params: Record<string, string>,",
                    "lineNumber": 825,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 826,
                    "isSignature": false
                  },
                  {
                    "text": "    if (",
                    "lineNumber": 827,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.eventsBatchController ||",
                    "lineNumber": 828,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.channelManager ||",
                    "lineNumber": 829,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.appManager",
                    "lineNumber": 830,
                    "isSignature": false
                  },
                  {
                    "text": "    ) {",
                    "lineNumber": 831,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(\"Server not initialized\", { status: 500 });",
                    "lineNumber": 832,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 833,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 834,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!params.appId) {",
                    "lineNumber": 835,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(\"Missing appId parameter\", { status: 400 });",
                    "lineNumber": 836,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 837,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 838,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 839,
                    "isSignature": false
                  },
                  {
                    "text": "      const httpRequest = await Factory.convertToHttpRequest(req);",
                    "lineNumber": 840,
                    "isSignature": false
                  },
                  {
                    "text": "      const httpConnection = Factory.createHttpConnection();",
                    "lineNumber": 841,
                    "isSignature": false
                  },
                  {
                    "text": "      const app = Factory.appManager.driver().findById(params.appId);",
                    "lineNumber": 842,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelManager = Factory.channelManager.for(app);",
                    "lineNumber": 843,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 844,
                    "isSignature": false
                  },
                  {
                    "text": "      const response = await Factory.eventsBatchController.handle(",
                    "lineNumber": 845,
                    "isSignature": false
                  },
                  {
                    "text": "        httpRequest,",
                    "lineNumber": 846,
                    "isSignature": false
                  },
                  {
                    "text": "        httpConnection,",
                    "lineNumber": 847,
                    "isSignature": false
                  },
                  {
                    "text": "        params.appId,",
                    "lineNumber": 848,
                    "isSignature": false
                  },
                  {
                    "text": "        app,",
                    "lineNumber": 849,
                    "isSignature": false
                  },
                  {
                    "text": "        channelManager,",
                    "lineNumber": 850,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 851,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 852,
                    "isSignature": false
                  },
                  {
                    "text": "      return Factory.convertToResponse(response);",
                    "lineNumber": 853,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 854,
                    "isSignature": false
                  },
                  {
                    "text": "      console.error(\"Error handling batch events:\", error);",
                    "lineNumber": 855,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 856,
                    "isSignature": false
                  },
                  {
                    "text": "        JSON.stringify({",
                    "lineNumber": 857,
                    "isSignature": false
                  },
                  {
                    "text": "          error:",
                    "lineNumber": 858,
                    "isSignature": false
                  },
                  {
                    "text": "            error instanceof Error ? error.message :",
                    "lineNumber": 859,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 860,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 864,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1273,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.428256630897522
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Protocols/Pusher/Http/Controllers/EventsBatchController.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 27,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Protocols\\Pusher\\Http\\Controllers;\n\nuse Illuminate\\Contracts\\Validation\\Validator;\nuse Illuminate\\Support\\Facades\\Validator as ValidatorFacade;\nuse Laravel\\Reverb\\Protocols\\Pusher\\Concerns\\InteractsWithChannelInformation;\nuse Laravel\\Reverb\\Protocols\\Pusher\\EventDispatcher;\nuse Laravel\\Reverb\\Protocols\\Pusher\\MetricsHandler;\nuse Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection;\nuse Laravel\\Reverb\\Servers\\Reverb\\Http\\Response;\nuse Psr\\Http\\Message\\RequestInterface;\nuse React\\Promise\\PromiseInterface;\n\nuse function React\\Promise\\all;\n\nclass EventsBatchController extends Controller\n{\n    use InteractsWithChannelInformation;\n\n    /**\n     * Handle the request.\n     */\n    public function __invoke(RequestInterface $request, Connection $connection, string $appId): Response|PromiseInterface\n    {\n        $this->verify($request, $connection, $appId);",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Protocols\\Pusher\\Http\\Controllers;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Illuminate\\Contracts\\Validation\\Validator;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Illuminate\\Support\\Facades\\Validator as ValidatorFacade;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Protocols\\Pusher\\Concerns\\InteractsWithChannelInformation;",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Protocols\\Pusher\\EventDispatcher;",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Protocols\\Pusher\\MetricsHandler;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Servers\\Reverb\\Http\\Response;",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "use Psr\\Http\\Message\\RequestInterface;",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\Promise\\PromiseInterface;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "use function React\\Promise\\all;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "class EventsBatchController extends Controller",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "    use InteractsWithChannelInformation;",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     * Handle the request.",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __invoke(RequestInterface $request, Connection $connection, string $appId): Response|PromiseInterface",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->verify($request, $connection, $appId);",
                    "lineNumber": 26,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.42435193061828613
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Protocols/Pusher/Http/Controllers/EventsBatchController.php",
                "range": {
                  "startPosition": {
                    "line": 24,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 87,
                    "column": 12
                  }
                },
                "contents": "    {\n        $this->verify($request, $connection, $appId);\n\n        $payload = json_decode($this->body, associative: true, flags: JSON_THROW_ON_ERROR);\n\n        $validator = $this->validator($payload);\n\n        if ($validator->fails()) {\n            return new Response($validator->errors(), 422);\n        }\n\n        $items = collect($payload['batch']);\n\n        $items = $items->map(function ($item) {\n            EventDispatcher::dispatch(\n                $this->application,\n                [\n                    'event' => $item['name'],\n                    'channel' => $item['channel'],\n                    'data' => $item['data'],\n                ],\n                isset($item['socket_id']) ? ($this->channels->connections()[$item['socket_id']] ?? null) : null\n            );\n\n            return isset($item['info']) ? app(MetricsHandler::class)->gather(\n                $this->application,\n                'channel',\n                ['channel' => $item['channel'], 'info' => $item['info']]\n            ) : [];\n        });\n\n        if ($items->contains(fn ($item) => ! empty($item))) {\n            return all($items)->then(function ($items) {\n                return new Response(['batch' => array_map(fn ($item) => (object) $item, $items)]);\n            });\n        }\n\n        return new Response(['batch' => (object) []]);\n    }\n\n    /**\n     * Get the info for the given channels.\n     *\n     * @return array<string, array<string, int>>\n     */\n    protected function getInfo(string $channel, string $info): array\n    {\n        $info = explode(',', $info);\n        $count = count($this->channels->find($channel)->connections());\n        $info = [\n            'user_count' => in_array('user_count', $info) ? $count : null,\n            'subscription_count' => in_array('subscription_count', $info) ? $count : null,\n        ];\n\n        return array_filter($info, fn ($item) => $item !== null);\n    }\n\n    /**\n     * Create a validator for the incoming request payload.\n     */\n    protected function validator(array $payload): Validator\n    {\n        return ValidatorFacade::make($payload, [\n            ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    {",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->verify($request, $connection, $appId);",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "        $payload = json_decode($this->body, associative: true, flags: JSON_THROW_ON_ERROR);",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $validator = $this->validator($payload);",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "        if ($validator->fails()) {",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "            return new Response($validator->errors(), 422);",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "        $items = collect($payload['batch']);",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "        $items = $items->map(function ($item) {",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "            EventDispatcher::dispatch(",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "                $this->application,",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "                [",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "                    'event' => $item['name'],",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "                    'channel' => $item['channel'],",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "                    'data' => $item['data'],",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "                ],",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "                isset($item['socket_id']) ? ($this->channels->connections()[$item['socket_id']] ?? null) : null",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "            );",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "            return isset($item['info']) ? app(MetricsHandler::class)->gather(",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "                $this->application,",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "                'channel',",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "                ['channel' => $item['channel'], 'info' => $item['info']]",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "            ) : [];",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "        });",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "        if ($items->contains(fn ($item) => ! empty($item))) {",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "            return all($items)->then(function ($items) {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "                return new Response(['batch' => array_map(fn ($item) => (object) $item, $items)]);",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "            });",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "        return new Response(['batch' => (object) []]);",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the info for the given channels.",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "     * @return array<string, array<string, int>>",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "    protected function getInfo(string $channel, string $info): array",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "        $info = explode(',', $info);",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "        $count = count($this->channels->find($channel)->connections());",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "        $info = [",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "            'user_count' => in_array('user_count', $info) ? $count : null,",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "            'subscription_count' => in_array('subscription_count', $info) ? $count : null,",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "        ];",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "        return array_filter($info, fn ($item) => $item !== null);",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a validator for the incoming request payload.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    protected function validator(array $payload): Validator",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "        return ValidatorFacade::make($payload, [",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "            ",
                    "lineNumber": 88,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4188739061355591
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 24,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "/**\n * EventsBatchController - Handles batch event dispatching\n *\n * Implements POST /apps/:appId/batch_events endpoint for triggering\n * multiple events in a single API call. Supports batches of up to 10 events.\n *\n * Key Features:\n * - Validates batch size (max 10 events)\n * - Dispatches events using EventDispatcher\n * - Optionally gathers channel metrics for each event\n * - Returns batch results with channel info\n *\n * Request Format:\n * ```json\n * {\n *   \"batch\": [\n *     {\n *       \"name\": \"my-event\",\n *       \"channel\": \"my-channel\",\n *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",\n *       \"socket_id\": \"123.456\",\n *       \"info\": \"subscription_count\"\n *     }\n *   ]\n * }\n * ```\n *\n * Response Format:\n * ```json\n * {\n *   \"batch\": [\n *     { \"subscription_count\": 5 },\n *     { \"subscription_count\": 3 }\n *   ]\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Usage with dependency injection\n * const controller = new EventsBatchController(metricsHandler);\n * const response = await controller.handle(request, connection, appId, application, channels);\n * ```\n */\nexport class EventsBatchController {\n  /**\n   * Create a new EventsBatchController instance.\n   *\n   * @param metricsHandler - The metrics handler for gathering channel info\n   */\n  constructor(private readonly metricsHandler: MetricsHandler) {}\n\n  /**\n   * Handle the batch events request.\n   *\n   * This method:\n   * 1. Parses and validates the request body\n   * 2. Dispatches each event to its channel\n   * 3. Gathers metrics for events that request channel info\n   * 4. Returns the batch results\n   *\n   * @param request - The HTTP request object\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from route parameters\n   * @param application - The verified application instance\n   * @param channels - The channel manager scoped to the application\n   * @returns Response object with batch results\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * EventsBatchController - Handles batch event dispatching",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * Implements POST /apps/:appId/batch_events endpoint for triggering",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * multiple events in a single API call. Supports batches of up to 10 events.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Features:",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * - Validates batch size (max 10 events)",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * - Dispatches events using EventDispatcher",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * - Optionally gathers channel metrics for each event",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * - Returns batch results with channel info",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " * Request Format:",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " *     {",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"name\": \"my-event\",",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"channel\": \"my-channel\",",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"socket_id\": \"123.456\",",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"info\": \"subscription_count\"",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " * Response Format:",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 5 },",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 3 }",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * // Usage with dependency injection",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * const controller = new EventsBatchController(metricsHandler);",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * const response = await controller.handle(request, connection, appId, application, channels);",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new EventsBatchController instance.",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param metricsHandler - The metrics handler for gathering channel info",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private readonly metricsHandler: MetricsHandler) {}",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the batch events request.",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Dispatches each event to its channel",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Gathers metrics for events that request channel info",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Returns the batch results",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from route parameters",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The verified application instance",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - The channel manager scoped to the application",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response object with batch results",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.40330269932746887
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 314,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nprotected getBody(request: IHttpRequest): string {\n\n  }\n}\n\n/**\n * Factory function to create a controller handler.\n *\n * This function creates a controller callback that can be used with the router.\n * It handles dependency injection and wires up the controller with its dependencies.\n *\n * Usage Notes:\n * - This assumes that request verification (authentication) happens at the router level\n * - The application and channels parameters must be provided by the route handler\n * - This follows the pattern where controllers receive pre-verified context\n *\n * @param metricsHandler - The metrics handler instance\n * @returns Controller callback function\n *\n * @example\n * ```typescript\n * const handler = createEventsBatchController(metricsHandler);\n * router.post('/apps/:appId/batch_events', handler);\n * ```\n */\nexport function createEventsBatchController(\n  metricsHandler: MetricsHandler,\n): (\n  request: IHttpRequest,\n  connection: Connection,\n  appId: string,\n  application: Application,\n  channels: ChannelManager,\n) => Promise<Response> {\n  const controller = new EventsBatchController(metricsHandler);\n  return (request, _connection, _appId, application, channels) =>\n    controller.handle(request, _connection, _appId, application, channels);\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "protected getBody(request: IHttpRequest): string {",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory function to create a controller handler.",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": " * This function creates a controller callback that can be used with the router.",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": " * It handles dependency injection and wires up the controller with its dependencies.",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": " * Usage Notes:",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": " * - This assumes that request verification (authentication) happens at the router level",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": " * - The application and channels parameters must be provided by the route handler",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": " * - This follows the pattern where controllers receive pre-verified context",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": " * @param metricsHandler - The metrics handler instance",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Controller callback function",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": " * const handler = createEventsBatchController(metricsHandler);",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": " * router.post('/apps/:appId/batch_events', handler);",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 302,
                    "isSignature": false
                  },
                  {
                    "text": "export function createEventsBatchController(",
                    "lineNumber": 303,
                    "isSignature": true
                  },
                  {
                    "text": "  metricsHandler: MetricsHandler,",
                    "lineNumber": 304,
                    "isSignature": true
                  },
                  {
                    "text": "): (",
                    "lineNumber": 305,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 306,
                    "isSignature": true
                  },
                  {
                    "text": "  connection: Connection,",
                    "lineNumber": 307,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 308,
                    "isSignature": true
                  },
                  {
                    "text": "  application: Application,",
                    "lineNumber": 309,
                    "isSignature": true
                  },
                  {
                    "text": "  channels: ChannelManager,",
                    "lineNumber": 310,
                    "isSignature": true
                  },
                  {
                    "text": ") => Promise<Response> {",
                    "lineNumber": 311,
                    "isSignature": true
                  },
                  {
                    "text": "  const controller = new EventsBatchController(metricsHandler);",
                    "lineNumber": 312,
                    "isSignature": false
                  },
                  {
                    "text": "  return (request, _connection, _appId, application, channels) =>",
                    "lineNumber": 313,
                    "isSignature": false
                  },
                  {
                    "text": "    controller.handle(request, _connection, _appId, application, channels);",
                    "lineNumber": 314,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 315,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.39241886138916016
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 52,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 260,
                    "column": 1
                  }
                },
                "contents": "export class EventsController extends Controller {\nconstructor(\n    protected override readonly channelManager: ChannelManager,\n    protected readonly metricsHandler: MetricsHandler,\n  ) {\n\n  }\n\n  /**\n   * Handle the request to trigger events.\n   *\n   * Processes the incoming event trigger request:\n   * 1. Parses and validates the request body\n   * 2. Validates required fields (name, data, channels/channel)\n   * 3. Dispatches the event to specified channels\n   * 4. Optionally gathers and returns channel metrics\n   *\n   * @param request - The HTTP request object\n   * @param connection - The connection object\n   * @param application - The application context\n   * @param channelManager - The channel manager scoped to the application\n   * @returns Response with empty object or channel metrics\n   */\n  async __invoke(\n    request: IHttpRequest,\n    _connection: Connection,\n    application: Application,\n    channelManager: ChannelManager,\n  ): Promise<Response> {\n    // Parse the request body\n    const body = this.getBody(request);\n    let payload: EventsPayload;\n\n    try {\n      payload = JSON.parse(body);\n    } catch (_error) {\n      return new Response({ message: \"Invalid JSON payload\" }, 422);\n    }\n\n    // Validate the payload\n    const validator = this.validator(payload);\n\n    if (Object.keys(validator).length > 0) {\n      return new Response(validator, 422);\n    }\n\n    // At this point, validator ensures name and data exist\n    if (!payload.name || !payload.data) {\n      return new Response({ message: \"Invalid payload\" }, 422);\n    }\n\n    // Normalize channels to array\n    const channels = this.normalizeChannels(payload);\n\n    // Get the connection to exclude from broadcast (if socket_id provided)\n    let except: ChannelConnection | null = null;\n    if (payload.socket_id) {\n      const connections = channelManager.connections();\n      except = connections[payload.socket_id] ?? null;\n    }\n\n    // Dispatch the event to all specified channels\n    dispatch(\n      application,\n      {\n        event: payload.name,\n        channels,\n        data: payload.data,\n      },\n      channelManager,\n      except?.connection() ?? null,\n    );\n\n    // If info parameter is provided, gather and return channel metrics\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 53,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 53,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 53,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 54,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsController extends Controller {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "constructor(",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    protected override readonly channelManager: ChannelManager,",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly metricsHandler: MetricsHandler,",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the request to trigger events.",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   * Processes the incoming event trigger request:",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Validates required fields (name, data, channels/channel)",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Dispatches the event to specified channels",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Optionally gathers and returns channel metrics",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection object",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application context",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channelManager - The channel manager scoped to the application",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response with empty object or channel metrics",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "  async __invoke(",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    channelManager: ChannelManager,",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse the request body",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = this.getBody(request);",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "    let payload: EventsPayload;",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "      payload = JSON.parse(body);",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (_error) {",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({ message: \"Invalid JSON payload\" }, 422);",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate the payload",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    const validator = this.validator(payload);",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    if (Object.keys(validator).length > 0) {",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(validator, 422);",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "    // At this point, validator ensures name and data exist",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payload.name || !payload.data) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({ message: \"Invalid payload\" }, 422);",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "    // Normalize channels to array",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "    const channels = this.normalizeChannels(payload);",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get the connection to exclude from broadcast (if socket_id provided)",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "    let except: ChannelConnection | null = null;",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "    if (payload.socket_id) {",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "      const connections = channelManager.connections();",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "      except = connections[payload.socket_id] ?? null;",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "    // Dispatch the event to all specified channels",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "    dispatch(",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      application,",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "        event: payload.name,",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "        data: payload.data,",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "      channelManager,",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "      except?.connection() ?? null,",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    // If info parameter is provided, gather and return channel metrics",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 261,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3902796506881714
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 189,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1272,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\nprivate static makePusherRouter(path: string): Router {\n {\n        router.get(route.path, route.handler);\n      } else if (route.method === \"POST\") {\n        router.post(route.path, route.handler);\n      }\n    }\n\n    return router;\n  }\n\n  /**\n   * Generate the routes required to handle Pusher protocol requests\n   *\n   * Defines all HTTP API endpoints for:\n   * - WebSocket connections\n   * - Event triggering\n   * - Connection management\n   * - Channel information\n   * - Health checks\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Array of route definitions\n   *\n   * @private\n   */\n  private static pusherRoutes(path: string): RouteDefinition[] {\n    const basePath = path || \"\";\n    const prefix = (route: string) => `${basePath}${route}`;\n\n    return [\n      {\n        method: \"GET\",\n        path: prefix(\"/app/{appKey}\"),\n        handler: Factory.handleWebSocketConnection.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/events\"),\n        handler: Factory.handleEvents.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/batch_events\"),\n        handler: Factory.handleBatchEvents.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/connections\"),\n        handler: Factory.handleConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels\"),\n        handler: Factory.handleChannels.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}\"),\n        handler: Factory.handleChannelInfo.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),\n        handler: Factory.handleChannelUsers.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),\n        handler: Factory.handleTerminateConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/up\"),\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 184,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 185,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 190,
                    "isSignature": true
                  },
                  {
                    "text": "private static makePusherRouter(path: string): Router {",
                    "lineNumber": 601,
                    "isSignature": false
                  },
                  {
                    "text": " {",
                    "lineNumber": 608,
                    "isSignature": false
                  },
                  {
                    "text": "        router.get(route.path, route.handler);",
                    "lineNumber": 609,
                    "isSignature": false
                  },
                  {
                    "text": "      } else if (route.method === \"POST\") {",
                    "lineNumber": 610,
                    "isSignature": false
                  },
                  {
                    "text": "        router.post(route.path, route.handler);",
                    "lineNumber": 611,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 612,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 613,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 614,
                    "isSignature": false
                  },
                  {
                    "text": "    return router;",
                    "lineNumber": 615,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 616,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 617,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 618,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate the routes required to handle Pusher protocol requests",
                    "lineNumber": 619,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 620,
                    "isSignature": false
                  },
                  {
                    "text": "   * Defines all HTTP API endpoints for:",
                    "lineNumber": 621,
                    "isSignature": false
                  },
                  {
                    "text": "   * - WebSocket connections",
                    "lineNumber": 622,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Event triggering",
                    "lineNumber": 623,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Connection management",
                    "lineNumber": 624,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Channel information",
                    "lineNumber": 625,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Health checks",
                    "lineNumber": 626,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 627,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param path - URL path prefix for all routes",
                    "lineNumber": 628,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Array of route definitions",
                    "lineNumber": 629,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 630,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 631,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 632,
                    "isSignature": false
                  },
                  {
                    "text": "  private static pusherRoutes(path: string): RouteDefinition[] {",
                    "lineNumber": 633,
                    "isSignature": false
                  },
                  {
                    "text": "    const basePath = path || \"\";",
                    "lineNumber": 634,
                    "isSignature": false
                  },
                  {
                    "text": "    const prefix = (route: string) => `${basePath}${route}`;",
                    "lineNumber": 635,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 636,
                    "isSignature": false
                  },
                  {
                    "text": "    return [",
                    "lineNumber": 637,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 638,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 639,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/app/{appKey}\"),",
                    "lineNumber": 640,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleWebSocketConnection.bind(Factory),",
                    "lineNumber": 641,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 642,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 643,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"POST\",",
                    "lineNumber": 644,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/events\"),",
                    "lineNumber": 645,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleEvents.bind(Factory),",
                    "lineNumber": 646,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 647,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 648,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"POST\",",
                    "lineNumber": 649,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/batch_events\"),",
                    "lineNumber": 650,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleBatchEvents.bind(Factory),",
                    "lineNumber": 651,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 652,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 653,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 654,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/connections\"),",
                    "lineNumber": 655,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleConnections.bind(Factory),",
                    "lineNumber": 656,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 657,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 658,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 659,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/channels\"),",
                    "lineNumber": 660,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleChannels.bind(Factory),",
                    "lineNumber": 661,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 662,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 663,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 664,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/channels/{channel}\"),",
                    "lineNumber": 665,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleChannelInfo.bind(Factory),",
                    "lineNumber": 666,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 667,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 668,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 669,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),",
                    "lineNumber": 670,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleChannelUsers.bind(Factory),",
                    "lineNumber": 671,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 672,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 673,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"POST\",",
                    "lineNumber": 674,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),",
                    "lineNumber": 675,
                    "isSignature": false
                  },
                  {
                    "text": "        handler: Factory.handleTerminateConnections.bind(Factory),",
                    "lineNumber": 676,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 677,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 678,
                    "isSignature": false
                  },
                  {
                    "text": "        method: \"GET\",",
                    "lineNumber": 679,
                    "isSignature": false
                  },
                  {
                    "text": "        path: prefix(\"/up\"),",
                    "lineNumber": 680,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 684,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1273,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.37829700112342834
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 189,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1272,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\nprivate static handleWebSocketConnection(\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ): Response | undefined {\n\n\n    if (!upgraded) {\n      return new Response(\"WebSocket upgrade failed\", { status: 500 });\n    }\n\n    // Return undefined to indicate successful upgrade (Bun requirement)\n    // The actual connection handling will happen in the websocket.open handler\n    return undefined;\n  }\n\n  /**\n   * Handle event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      // Convert Bun Request to IHttpRequest\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n\n      // Get the application\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      // Call the controller\n      const response = await Factory.eventsController.__invoke(\n        httpRequest,\n        httpConnection,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message :\n\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 184,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 185,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 190,
                    "isSignature": true
                  },
                  {
                    "text": "private static handleWebSocketConnection(",
                    "lineNumber": 696,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 697,
                    "isSignature": false
                  },
                  {
                    "text": "    params: Record<string, string>,",
                    "lineNumber": 698,
                    "isSignature": false
                  },
                  {
                    "text": "    server?: ReturnType<typeof Bun.serve>,",
                    "lineNumber": 699,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Response | undefined {",
                    "lineNumber": 700,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 748,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 749,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!upgraded) {",
                    "lineNumber": 750,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(\"WebSocket upgrade failed\", { status: 500 });",
                    "lineNumber": 751,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 752,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 753,
                    "isSignature": false
                  },
                  {
                    "text": "    // Return undefined to indicate successful upgrade (Bun requirement)",
                    "lineNumber": 754,
                    "isSignature": false
                  },
                  {
                    "text": "    // The actual connection handling will happen in the websocket.open handler",
                    "lineNumber": 755,
                    "isSignature": false
                  },
                  {
                    "text": "    return undefined;",
                    "lineNumber": 756,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 757,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 758,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 759,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle event triggering",
                    "lineNumber": 760,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 761,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param req - The incoming request",
                    "lineNumber": 762,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param params - Route parameters including appId",
                    "lineNumber": 763,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns JSON response with result",
                    "lineNumber": 764,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 765,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 766,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 767,
                    "isSignature": false
                  },
                  {
                    "text": "  private static async handleEvents(",
                    "lineNumber": 768,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 769,
                    "isSignature": false
                  },
                  {
                    "text": "    params: Record<string, string>,",
                    "lineNumber": 770,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 771,
                    "isSignature": false
                  },
                  {
                    "text": "    if (",
                    "lineNumber": 772,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.eventsController ||",
                    "lineNumber": 773,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.channelManager ||",
                    "lineNumber": 774,
                    "isSignature": false
                  },
                  {
                    "text": "      !Factory.appManager",
                    "lineNumber": 775,
                    "isSignature": false
                  },
                  {
                    "text": "    ) {",
                    "lineNumber": 776,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(\"Server not initialized\", { status: 500 });",
                    "lineNumber": 777,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 778,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 779,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!params.appId) {",
                    "lineNumber": 780,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(\"Missing appId parameter\", { status: 400 });",
                    "lineNumber": 781,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 782,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 783,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 784,
                    "isSignature": false
                  },
                  {
                    "text": "      // Convert Bun Request to IHttpRequest",
                    "lineNumber": 785,
                    "isSignature": false
                  },
                  {
                    "text": "      const httpRequest = await Factory.convertToHttpRequest(req);",
                    "lineNumber": 786,
                    "isSignature": false
                  },
                  {
                    "text": "      const httpConnection = Factory.createHttpConnection();",
                    "lineNumber": 787,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 788,
                    "isSignature": false
                  },
                  {
                    "text": "      // Get the application",
                    "lineNumber": 789,
                    "isSignature": false
                  },
                  {
                    "text": "      const app = Factory.appManager.driver().findById(params.appId);",
                    "lineNumber": 790,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelManager = Factory.channelManager.for(app);",
                    "lineNumber": 791,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 792,
                    "isSignature": false
                  },
                  {
                    "text": "      // Call the controller",
                    "lineNumber": 793,
                    "isSignature": false
                  },
                  {
                    "text": "      const response = await Factory.eventsController.__invoke(",
                    "lineNumber": 794,
                    "isSignature": false
                  },
                  {
                    "text": "        httpRequest,",
                    "lineNumber": 795,
                    "isSignature": false
                  },
                  {
                    "text": "        httpConnection,",
                    "lineNumber": 796,
                    "isSignature": false
                  },
                  {
                    "text": "        app,",
                    "lineNumber": 797,
                    "isSignature": false
                  },
                  {
                    "text": "        channelManager,",
                    "lineNumber": 798,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 799,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 800,
                    "isSignature": false
                  },
                  {
                    "text": "      return Factory.convertToResponse(response);",
                    "lineNumber": 801,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (error) {",
                    "lineNumber": 802,
                    "isSignature": false
                  },
                  {
                    "text": "      console.error(\"Error handling events:\", error);",
                    "lineNumber": 803,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(",
                    "lineNumber": 804,
                    "isSignature": false
                  },
                  {
                    "text": "        JSON.stringify({",
                    "lineNumber": 805,
                    "isSignature": false
                  },
                  {
                    "text": "          error:",
                    "lineNumber": 806,
                    "isSignature": false
                  },
                  {
                    "text": "            error instanceof Error ? error.message :",
                    "lineNumber": 807,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 808,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 812,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1273,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3709805905818939
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Factory.php",
                "range": {
                  "startPosition": {
                    "line": 94,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 141,
                    "column": 0
                  }
                },
                "contents": "    {\n        $routes = new RouteCollection;\n\n        $routes->add('sockets', Route::get('/app/{appKey}', new PusherController(app(PusherServer::class), app(ApplicationProvider::class))));\n        $routes->add('events', Route::post('/apps/{appId}/events', new EventsController));\n        $routes->add('events_batch', Route::post('/apps/{appId}/batch_events', new EventsBatchController));\n        $routes->add('connections', Route::get('/apps/{appId}/connections', new ConnectionsController));\n        $routes->add('channels', Route::get('/apps/{appId}/channels', new ChannelsController));\n        $routes->add('channel', Route::get('/apps/{appId}/channels/{channel}', new ChannelController));\n        $routes->add('channel_users', Route::get('/apps/{appId}/channels/{channel}/users', new ChannelUsersController));\n        $routes->add('users_terminate', Route::post('/apps/{appId}/users/{userId}/terminate_connections', new UsersTerminateController));\n        $routes->add('health_check', Route::get('/up', new HealthCheckController));\n\n        $routes->addPrefix($path);\n\n        return $routes;\n    }\n\n    /**\n     * Configure the TLS context for the server.\n     *\n     * @param  array  $context<string,  mixed>\n     * @return array<string, mixed>\n     */\n    protected static function configureTls(array $context, ?string $hostname): array\n    {\n        $context = array_filter($context, fn ($value) => $value !== null);\n\n        if (! static::usesTls($context) && $hostname && Certificate::exists($hostname)) {\n            [$certificate, $key] = Certificate::resolve($hostname);\n\n            $context['local_cert'] = $certificate;\n            $context['local_pk'] = $key;\n            $context['verify_peer'] = app()->environment() === 'production';\n        }\n\n        return $context;\n    }\n\n    /**\n     * Determine whether the server uses TLS.\n     *\n     * @param  array  $context<string,  mixed>\n     */\n    protected static function usesTls(array $context): bool\n    {\n        return ($context['local_cert'] ?? false) || ($context['local_pk'] ?? false);",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    {",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes = new RouteCollection;",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('sockets', Route::get('/app/{appKey}', new PusherController(app(PusherServer::class), app(ApplicationProvider::class))));",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('events', Route::post('/apps/{appId}/events', new EventsController));",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('events_batch', Route::post('/apps/{appId}/batch_events', new EventsBatchController));",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('connections', Route::get('/apps/{appId}/connections', new ConnectionsController));",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('channels', Route::get('/apps/{appId}/channels', new ChannelsController));",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('channel', Route::get('/apps/{appId}/channels/{channel}', new ChannelController));",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('channel_users', Route::get('/apps/{appId}/channels/{channel}/users', new ChannelUsersController));",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('users_terminate', Route::post('/apps/{appId}/users/{userId}/terminate_connections', new UsersTerminateController));",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->add('health_check', Route::get('/up', new HealthCheckController));",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "        $routes->addPrefix($path);",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "        return $routes;",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "     * Configure the TLS context for the server.",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "     * @param  array  $context<string,  mixed>",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "     * @return array<string, mixed>",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "    protected static function configureTls(array $context, ?string $hostname): array",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "        $context = array_filter($context, fn ($value) => $value !== null);",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "        if (! static::usesTls($context) && $hostname && Certificate::exists($hostname)) {",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "            [$certificate, $key] = Certificate::resolve($hostname);",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "            $context['local_cert'] = $certificate;",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "            $context['local_pk'] = $key;",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "            $context['verify_peer'] = app()->environment() === 'production';",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "        return $context;",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "     * Determine whether the server uses TLS.",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "     * @param  array  $context<string,  mixed>",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "    protected static function usesTls(array $context): bool",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "        return ($context['local_cert'] ?? false) || ($context['local_pk'] ?? false);",
                    "lineNumber": 141,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.34319159388542175
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 24,
                    "column": 1
                  }
                },
                "contents": "import type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport { dispatch } from \"../../event-dispatcher\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * Batch item structure\n */\ninterface BatchItem {\n  name: string;\n  channel: string;\n  data: string;\n  socket_id?: string;\n  info?: string;\n}\n\n/**\n * Validation error structure\n */\ninterface ValidationErrors {\n  [key: string]: string[];\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import { dispatch } from \"../../event-dispatcher\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Batch item structure",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "interface BatchItem {",
                    "lineNumber": 12,
                    "isSignature": true
                  },
                  {
                    "text": "  name: string;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  channel: string;",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  data: string;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "  socket_id?: string;",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string;",
                    "lineNumber": 17,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 18,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * Validation error structure",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "interface ValidationErrors {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  [key: string]: string[];",
                    "lineNumber": 24,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 25,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.34297069907188416
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Protocols/Pusher/Http/Controllers/EventsController.php",
                "range": {
                  "startPosition": {
                    "line": 23,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 73,
                    "column": 0
                  }
                },
                "contents": "    {\n        $this->verify($request, $connection, $appId);\n\n        $payload = json_decode($this->body, associative: true, flags: JSON_THROW_ON_ERROR);\n\n        $validator = $this->validator($payload);\n\n        if ($validator->fails()) {\n            return new Response($validator->errors(), 422);\n        }\n\n        $channels = Arr::wrap($payload['channels'] ?? $payload['channel'] ?? []);\n        if ($except = $payload['socket_id'] ?? null) {\n            $except = $this->channels->connections()[$except] ?? null;\n        }\n\n        EventDispatcher::dispatch(\n            $this->application,\n            [\n                'event' => $payload['name'],\n                'channels' => $channels,\n                'data' => $payload['data'],\n            ],\n            $except ? $except->connection() : null\n        );\n\n        if (isset($payload['info'])) {\n            return app(MetricsHandler::class)\n                ->gather($this->application, 'channels', ['info' => $payload['info'], 'channels' => $channels])\n                ->then(fn ($channels) => new Response(['channels' => array_map(fn ($channel) => (object) $channel, $channels)]));\n        }\n\n        return new Response((object) []);\n    }\n\n    /**\n     * Create a validator for the incoming request payload.\n     */\n    protected function validator(array $payload): Validator\n    {\n        return ValidatorFacade::make($payload, [\n            'name' => ['required', 'string'],\n            'data' => ['required', 'string'],\n            'channels' => ['required_without:channel', 'array'],\n            'channel' => ['required_without:channels', 'string'],\n            'socket_id' => ['string'],\n            'info' => ['string'],\n        ]);\n    }\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->verify($request, $connection, $appId);",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "        $payload = json_decode($this->body, associative: true, flags: JSON_THROW_ON_ERROR);",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "        $validator = $this->validator($payload);",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "        if ($validator->fails()) {",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "            return new Response($validator->errors(), 422);",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "        $channels = Arr::wrap($payload['channels'] ?? $payload['channel'] ?? []);",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "        if ($except = $payload['socket_id'] ?? null) {",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "            $except = $this->channels->connections()[$except] ?? null;",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "        EventDispatcher::dispatch(",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->application,",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "            [",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "                'event' => $payload['name'],",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "                'channels' => $channels,",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "                'data' => $payload['data'],",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "            ],",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "            $except ? $except->connection() : null",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "        if (isset($payload['info'])) {",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "            return app(MetricsHandler::class)",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "                ->gather($this->application, 'channels', ['info' => $payload['info'], 'channels' => $channels])",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "                ->then(fn ($channels) => new Response(['channels' => array_map(fn ($channel) => (object) $channel, $channels)]));",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "        return new Response((object) []);",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a validator for the incoming request payload.",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    protected function validator(array $payload): Validator",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "        return ValidatorFacade::make($payload, [",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "            'name' => ['required', 'string'],",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "            'data' => ['required', 'string'],",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "            'channels' => ['required_without:channel', 'array'],",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "            'channel' => ['required_without:channels', 'string'],",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "            'socket_id' => ['string'],",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "            'info' => ['string'],",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "        ]);",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 73,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.33482056856155396
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\n\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n  protected validate(payload: unknown): ValidationErrors | null {\n    const errors: ValidationErrors = {};\n\n    // Validate batch field exists\n    if (!payload || typeof payload !== \"object\") {\n      errors.batch = [\"The batch field is required.\"];\n      return errors;\n    }\n\n    const payloadObj = payload as Record<string, unknown>;\n\n    if (!payloadObj.batch) {\n      errors.batch = [\"The batch field is required.\"];\n      return errors;\n    }\n\n    // Validate batch is an array\n    if (!Array.isArray(payloadObj.batch)) {\n      errors.batch = [\"The batch field must be an array.\"];\n      return errors;\n    }\n\n    // Validate batch size (max 10 events)\n    if (payloadObj.batch.length > 10) {\n      errors.batch = [\"The batch may not contain more than 10 events.\"];\n      return errors;\n    }\n\n    // Validate each batch item\n    const batch = payloadObj.batch as unknown[];\n    batch.forEach((item: unknown, index: number) => {\n      if\n    }\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "  protected validate(payload: unknown): ValidationErrors | null {",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    const errors: ValidationErrors = {};",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch field exists",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payload || typeof payload !== \"object\") {",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field is required.\"];",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "    const payloadObj = payload as Record<string, unknown>;",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payloadObj.batch) {",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field is required.\"];",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch is an array",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!Array.isArray(payloadObj.batch)) {",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch field must be an array.\"];",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate batch size (max 10 events)",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "    if (payloadObj.batch.length > 10) {",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "      errors.batch = [\"The batch may not contain more than 10 events.\"];",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "      return errors;",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate each batch item",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = payloadObj.batch as unknown[];",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "    batch.forEach((item: unknown, index: number) => {",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "      if",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3040885925292969
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 301,
                    "column": 3
                  }
                },
                "contents": "export class EventsBatchController {\n\n\n  /**\n   * Get the request body content.\n   *\n   * Extracts the body string from the HTTP request object.\n   * The body should contain the JSON-encoded batch payload.\n   *\n   * @param request - The HTTP request object\n   * @returns The request body as a string\n   */\n  protected getBody(request: IHttpRequest): string {\n    // Access body from the request object\n    // IHttpRequest has a body property directly\n    return request.body || \"\";\n  }\n}\n\n/**\n * Factory function to create a controller handler.\n *\n * This function creates a controller callback that can be used with the router.\n * It handles dependency injection and wires up the controller with its dependencies.\n *\n * Usage Notes:\n * - This assumes that request verification (authentication) happens at the router level\n * - The application and channels parameters must be provided by the route handler\n * - This follows the pattern where controllers receive pre-verified context\n *\n * @param metricsHandler - The metrics handler instance\n * @returns Controller callback function\n *\n * @example\n * ```typescript\n * const handler = createEventsBatchController(metricsHandler);\n * router.post('/apps/:appId/batch_events', handler);\n * ```\n */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request body content.",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": "   * Extracts the body string from the HTTP request object.",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": "   * The body should contain the JSON-encoded batch payload.",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 272,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 273,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The request body as a string",
                    "lineNumber": 274,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 275,
                    "isSignature": false
                  },
                  {
                    "text": "  protected getBody(request: IHttpRequest): string {",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "    // Access body from the request object",
                    "lineNumber": 277,
                    "isSignature": false
                  },
                  {
                    "text": "    // IHttpRequest has a body property directly",
                    "lineNumber": 278,
                    "isSignature": false
                  },
                  {
                    "text": "    return request.body || \"\";",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": " * Factory function to create a controller handler.",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": " * This function creates a controller callback that can be used with the router.",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": " * It handles dependency injection and wires up the controller with its dependencies.",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": " * Usage Notes:",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": " * - This assumes that request verification (authentication) happens at the router level",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": " * - The application and channels parameters must be provided by the route handler",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": " * - This follows the pattern where controllers receive pre-verified context",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": " * @param metricsHandler - The metrics handler instance",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Controller callback function",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": " * const handler = createEventsBatchController(metricsHandler);",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": " * router.post('/apps/:appId/batch_events', handler);",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 302,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2918072044849396
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nprotected validate(payload: unknown): ValidationErrors | null {\n\n    batch.forEach((item: unknown, index: number) => {\n      if (typeof item !== \"object\" || item === null) {\n        errors[`batch.${index}`] = [\"The batch item must be an object.\"];\n        return;\n      }\n\n      const itemObj = item as Record<string, unknown>;\n\n      // Validate name\n      if (!itemObj.name) {\n        errors[`batch.${index}.name`] = [\"The name field is required.\"];\n      } else if (typeof itemObj.name !== \"string\") {\n        errors[`batch.${index}.name`] = [\"The name field must be a string.\"];\n      }\n\n      // Validate data\n      if (!itemObj.data) {\n        errors[`batch.${index}.data`] = [\"The data field is required.\"];\n      } else if (typeof itemObj.data !== \"string\") {\n        errors[`batch.${index}.data`] = [\"The data field must be a string.\"];\n      }\n\n      // Validate channel (required_without channels, but in batch mode it's just required)\n      if (!itemObj.channel) {\n        errors[`batch.${index}.channel`] = [\"The channel field is required.\"];\n      } else if (typeof itemObj.channel !== \"string\") {\n        errors[`batch.${index}.channel`] = [\n          \"The channel field must be a string.\",\n        ];\n      }\n\n      // Validate optional socket_id field\n      if (\n        itemObj.socket_id !== undefined &&\n        typeof itemObj.socket_id !== \"string\"\n      ) {\n        errors[`batch.${index}.socket_id`] = [\n          \"The socket_id field must be a string.\",\n        ];\n      }\n\n      // Validate optional info field\n      if (itemObj.info !== undefined && typeof itemObj.info !== \"string\") {\n        errors[`batch.${index}.info`] = [\"The info field must be a string.\"];\n      }\n    });\n\n    return Object.keys(errors).length > 0 ? errors : null;\n  }\n\n  /**\n   * Get the request body content.\n   *\n   * Extracts the body string from the HTTP request object.\n   * The body should contain the JSON-encoded batch payload.\n   *\n   * @param request - The HTTP request object\n   * @returns The request body as a string\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    },
                    {
                      "startPosition": {
                        "line": 187,
                        "column": 3
                      },
                      "endPosition": {
                        "line": 188,
                        "column": 5
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "protected validate(payload: unknown): ValidationErrors | null {",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "    batch.forEach((item: unknown, index: number) => {",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "      if (typeof item !== \"object\" || item === null) {",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}`] = [\"The batch item must be an object.\"];",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": "        return;",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 221,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": "      const itemObj = item as Record<string, unknown>;",
                    "lineNumber": 223,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 224,
                    "isSignature": false
                  },
                  {
                    "text": "      // Validate name",
                    "lineNumber": 225,
                    "isSignature": false
                  },
                  {
                    "text": "      if (!itemObj.name) {",
                    "lineNumber": 226,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.name`] = [\"The name field is required.\"];",
                    "lineNumber": 227,
                    "isSignature": false
                  },
                  {
                    "text": "      } else if (typeof itemObj.name !== \"string\") {",
                    "lineNumber": 228,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.name`] = [\"The name field must be a string.\"];",
                    "lineNumber": 229,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 230,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 231,
                    "isSignature": false
                  },
                  {
                    "text": "      // Validate data",
                    "lineNumber": 232,
                    "isSignature": false
                  },
                  {
                    "text": "      if (!itemObj.data) {",
                    "lineNumber": 233,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.data`] = [\"The data field is required.\"];",
                    "lineNumber": 234,
                    "isSignature": false
                  },
                  {
                    "text": "      } else if (typeof itemObj.data !== \"string\") {",
                    "lineNumber": 235,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.data`] = [\"The data field must be a string.\"];",
                    "lineNumber": 236,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 237,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 238,
                    "isSignature": false
                  },
                  {
                    "text": "      // Validate channel (required_without channels, but in batch mode it's just required)",
                    "lineNumber": 239,
                    "isSignature": false
                  },
                  {
                    "text": "      if (!itemObj.channel) {",
                    "lineNumber": 240,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.channel`] = [\"The channel field is required.\"];",
                    "lineNumber": 241,
                    "isSignature": false
                  },
                  {
                    "text": "      } else if (typeof itemObj.channel !== \"string\") {",
                    "lineNumber": 242,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.channel`] = [",
                    "lineNumber": 243,
                    "isSignature": false
                  },
                  {
                    "text": "          \"The channel field must be a string.\",",
                    "lineNumber": 244,
                    "isSignature": false
                  },
                  {
                    "text": "        ];",
                    "lineNumber": 245,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 246,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 247,
                    "isSignature": false
                  },
                  {
                    "text": "      // Validate optional socket_id field",
                    "lineNumber": 248,
                    "isSignature": false
                  },
                  {
                    "text": "      if (",
                    "lineNumber": 249,
                    "isSignature": false
                  },
                  {
                    "text": "        itemObj.socket_id !== undefined &&",
                    "lineNumber": 250,
                    "isSignature": false
                  },
                  {
                    "text": "        typeof itemObj.socket_id !== \"string\"",
                    "lineNumber": 251,
                    "isSignature": false
                  },
                  {
                    "text": "      ) {",
                    "lineNumber": 252,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.socket_id`] = [",
                    "lineNumber": 253,
                    "isSignature": false
                  },
                  {
                    "text": "          \"The socket_id field must be a string.\",",
                    "lineNumber": 254,
                    "isSignature": false
                  },
                  {
                    "text": "        ];",
                    "lineNumber": 255,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 256,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 257,
                    "isSignature": false
                  },
                  {
                    "text": "      // Validate optional info field",
                    "lineNumber": 258,
                    "isSignature": false
                  },
                  {
                    "text": "      if (itemObj.info !== undefined && typeof itemObj.info !== \"string\") {",
                    "lineNumber": 259,
                    "isSignature": false
                  },
                  {
                    "text": "        errors[`batch.${index}.info`] = [\"The info field must be a string.\"];",
                    "lineNumber": 260,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 261,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 263,
                    "isSignature": false
                  },
                  {
                    "text": "    return Object.keys(errors).length > 0 ? errors : null;",
                    "lineNumber": 264,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the request body content.",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": "   * Extracts the body string from the HTTP request object.",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": "   * The body should contain the JSON-encoded batch payload.",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 272,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 273,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The request body as a string",
                    "lineNumber": 274,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 275,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2857101857662201
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "notes/2025-11-13-1300-review-fixes.md",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 37,
                    "column": 0
                  }
                },
                "contents": "# Review Fixes - 2025-11-13\n\n## Status: ✅ All Issues Resolved\n\nFixed all review feedback from `specs/review.md`:\n\n### 1. Fixed Factory.createHttpConnection() Type Issues\n- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface\n- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 2. Fixed Factory.convertToHttpRequest() Headers Property\n- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)\n- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 3. Fixed EventsBatchController Connection Type\n- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)\n- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers\n- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`\n\n### 4. Fixed All `any` Type Violations in Tests\n- **Problem**: 9 `noExplicitAny` lint violations across test suite\n- **Solution**: Replaced all `any` types with proper types:\n  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)\n  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`\n  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)\n  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)\n- **Files**: \n  - `tests/unit/channels/channel.test.ts`\n  - `tests/e2e/websocket-connection.test.ts`\n  - `tests/feature/health-check-controller.test.ts`\n  - `tests/unit/events/event-dispatcher.test.ts`\n\n## Verification\n- ✅ `bun run typecheck` - Passes\n- ✅ `bun run lint` - No violations",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "# Review Fixes - 2025-11-13",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "## Status: ✅ All Issues Resolved",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "Fixed all review feedback from `specs/review.md`:",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "### 1. Fixed Factory.createHttpConnection() Type Issues",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "### 2. Fixed Factory.convertToHttpRequest() Headers Property",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "### 3. Fixed EventsBatchController Connection Type",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "### 4. Fixed All `any` Type Violations in Tests",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: 9 `noExplicitAny` lint violations across test suite",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Replaced all `any` types with proper types:",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: ",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/channels/channel.test.ts`",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/e2e/websocket-connection.test.ts`",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/feature/health-check-controller.test.ts`",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/events/event-dispatcher.test.ts`",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "## Verification",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run typecheck` - Passes",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run lint` - No violations",
                    "lineNumber": 37,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2581658959388733
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 37,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 57,
                    "column": 1
                  }
                },
                "contents": "/**\n * Connection data structure.\n */\nexport interface ConnectionData {\n  /** User identifier */\n  user_id: string;\n  /** Additional connection metadata */\n  [key: string]: unknown;\n}\n\n/**\n * Channel interface for metrics gathering.\n */\nexport interface Channel {\n  /** Get the channel name */\n  name(): string\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection data structure.",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ConnectionData {",
                    "lineNumber": 43,
                    "isSignature": true
                  },
                  {
                    "text": "  /** User identifier */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "  user_id: string;",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Additional connection metadata */",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  [key: string]: unknown;",
                    "lineNumber": 47,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 48,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel interface for metrics gathering.",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "export interface Channel {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Get the channel name */",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  name(): string",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 57,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 58,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.1617487072944641
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Get the channel users for the given application.\n   *\n   * @param application - The application\n   * @param options - Options including channel name\n   * @returns Array of channel users\n   */\n  protected channelUsers(\n    application: Application,\n    options: MetricsOptions,\n  ): ChannelUser[] {\n    if (!options.channel) {\n      return [];\n    }\n    const channel = this.channels.for(application).find(options.channel);\n\n    if (!channel) {\n      return [];\n    }\n\n    // Get unique users by user_id\n    // channel.connections() returns Record<string, ChannelConnection>, convert to array\n    const connections = Object.values(channel.connections());\n    const seenUserIds = new Set<string>();\n    const users: ChannelUser[] = [];\n\n    for (const channelConnection of connections) {\n      // channelConnection.data() returns Map<string, unknown>, get user_id from Map\n      const connectionData = channelConnection.data();\n      const userId = connectionData.get(\"user_id\") as string | undefined;\n      if (userId && !seenUserIds.has(userId)) {\n        seenUserIds.add(userId);\n        users.push({ id: userId });\n      }\n    }\n\n    return users;\n  }\n\n  /**\n   * Get the connections for the given application.\n   *\n   * @param application - The application\n   * @returns Connection information\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 252,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 253,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 254,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the channel users for the given application.",
                    "lineNumber": 255,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 256,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application",
                    "lineNumber": 257,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Options including channel name",
                    "lineNumber": 258,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Array of channel users",
                    "lineNumber": 259,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 260,
                    "isSignature": false
                  },
                  {
                    "text": "  protected channelUsers(",
                    "lineNumber": 261,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 262,
                    "isSignature": false
                  },
                  {
                    "text": "    options: MetricsOptions,",
                    "lineNumber": 263,
                    "isSignature": false
                  },
                  {
                    "text": "  ): ChannelUser[] {",
                    "lineNumber": 264,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!options.channel) {",
                    "lineNumber": 265,
                    "isSignature": false
                  },
                  {
                    "text": "      return [];",
                    "lineNumber": 266,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 267,
                    "isSignature": false
                  },
                  {
                    "text": "    const channel = this.channels.for(application).find(options.channel);",
                    "lineNumber": 268,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 269,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!channel) {",
                    "lineNumber": 270,
                    "isSignature": false
                  },
                  {
                    "text": "      return [];",
                    "lineNumber": 271,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 272,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 273,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get unique users by user_id",
                    "lineNumber": 274,
                    "isSignature": false
                  },
                  {
                    "text": "    // channel.connections() returns Record<string, ChannelConnection>, convert to array",
                    "lineNumber": 275,
                    "isSignature": false
                  },
                  {
                    "text": "    const connections = Object.values(channel.connections());",
                    "lineNumber": 276,
                    "isSignature": false
                  },
                  {
                    "text": "    const seenUserIds = new Set<string>();",
                    "lineNumber": 277,
                    "isSignature": false
                  },
                  {
                    "text": "    const users: ChannelUser[] = [];",
                    "lineNumber": 278,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 279,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const channelConnection of connections) {",
                    "lineNumber": 280,
                    "isSignature": false
                  },
                  {
                    "text": "      // channelConnection.data() returns Map<string, unknown>, get user_id from Map",
                    "lineNumber": 281,
                    "isSignature": false
                  },
                  {
                    "text": "      const connectionData = channelConnection.data();",
                    "lineNumber": 282,
                    "isSignature": false
                  },
                  {
                    "text": "      const userId = connectionData.get(\"user_id\") as string | undefined;",
                    "lineNumber": 283,
                    "isSignature": false
                  },
                  {
                    "text": "      if (userId && !seenUserIds.has(userId)) {",
                    "lineNumber": 284,
                    "isSignature": false
                  },
                  {
                    "text": "        seenUserIds.add(userId);",
                    "lineNumber": 285,
                    "isSignature": false
                  },
                  {
                    "text": "        users.push({ id: userId });",
                    "lineNumber": 286,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 287,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 288,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 289,
                    "isSignature": false
                  },
                  {
                    "text": "    return users;",
                    "lineNumber": 290,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the connections for the given application.",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Connection information",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.15082573890686035
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 17,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 69,
                    "column": 3
                  }
                },
                "contents": "/**\n * Validation error structure\n */\ninterface ValidationErrors {\n  [key: string]: string[];\n}\n\n/**\n * EventsBatchController - Handles batch event dispatching\n *\n * Implements POST /apps/:appId/batch_events endpoint for triggering\n * multiple events in a single API call. Supports batches of up to 10 events.\n *\n * Key Features:\n * - Validates batch size (max 10 events)\n * - Dispatches events using EventDispatcher\n * - Optionally gathers channel metrics for each event\n * - Returns batch results with channel info\n *\n * Request Format:\n * ```json\n * {\n *   \"batch\": [\n *     {\n *       \"name\": \"my-event\",\n *       \"channel\": \"my-channel\",\n *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",\n *       \"socket_id\": \"123.456\",\n *       \"info\": \"subscription_count\"\n *     }\n *   ]\n * }\n * ```\n *\n * Response Format:\n * ```json\n * {\n *   \"batch\": [\n *     { \"subscription_count\": 5 },\n *     { \"subscription_count\": 3 }\n *   ]\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Usage with dependency injection\n * const controller = new EventsBatchController(metricsHandler);\n * const response = await controller.handle(request, connection, appId, application, channels);\n * ```\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * Validation error structure",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "interface ValidationErrors {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  [key: string]: string[];",
                    "lineNumber": 24,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 25,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * EventsBatchController - Handles batch event dispatching",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * Implements POST /apps/:appId/batch_events endpoint for triggering",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * multiple events in a single API call. Supports batches of up to 10 events.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Features:",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * - Validates batch size (max 10 events)",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * - Dispatches events using EventDispatcher",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * - Optionally gathers channel metrics for each event",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * - Returns batch results with channel info",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " * Request Format:",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " *     {",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"name\": \"my-event\",",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"channel\": \"my-channel\",",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"data\": \"{\\\"message\\\":\\\"hello\\\"}\",",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"socket_id\": \"123.456\",",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " *       \"info\": \"subscription_count\"",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " * Response Format:",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " * ```json",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"batch\": [",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 5 },",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"subscription_count\": 3 }",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * // Usage with dependency injection",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * const controller = new EventsBatchController(metricsHandler);",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * const response = await controller.handle(request, connection, appId, application, channels);",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 70,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.14523035287857056
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Get the metrics for the given type.\n   *\n   * @param application - The application to get metrics for\n   * @param type - The type of metrics to get\n   * @param options - Additional options for the metrics request\n   * @returns The metrics data\n   */\n  get(\n    application: Application,\n    type: string,\n    options: MetricsOptions,\n  ): unknown {\n    switch (type) {\n      case \"channel\":\n        return this.channel(application, options);\n      case \"channels\":\n        return this.channels_(application, options);\n      case \"channel_users\":\n        return this.channelUsers(application, options);\n      case \"connections\":\n        return this.connections(application);\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Get the channel information for the given application.\n   *\n   * @param application - The application\n   * @param options - Options including channel name and info fields\n   * @returns Channel information\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the metrics for the given type.",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to get metrics for",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to get",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The metrics data",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "  get(",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "    type: string,",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "    options: MetricsOptions,",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "  ): unknown {",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "    switch (type) {",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "      case \"channel\":",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "        return this.channel(application, options);",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "      case \"channels\":",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "        return this.channels_(application, options);",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "      case \"channel_users\":",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "        return this.channelUsers(application, options);",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "      case \"connections\":",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "        return this.connections(application);",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "      default:",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "        return [];",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the channel information for the given application.",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Options including channel name and info fields",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Channel information",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.142985001206398
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 53
                  },
                  "endPosition": {
                    "line": 29,
                    "column": 1
                  }
                },
                "contents": "import type { ChannelConnection } from \"./channels/channel-connection\";\n\n/**\n * Metrics collection options for different metric types.\n */\nexport interface MetricsOptions {\n  /** Channel name (for 'channel' and 'channel_users' types) */\n  channel?: string;\n  /** Array of channel names (for 'channels' type) */\n  channels?: string[];\n  /** Info fields to include (comma-separated or array) */\n  info?: string | string[];\n  /** Filter prefix for channel names (for 'channels' type) */\n  filter?: string;\n}\n\n/**\n * Channel information structure.\n */\nexport interface ChannelInfo {\n  /** Whether the channel is occupied (has connections) */\n  occupied?: boolean\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { ChannelConnection } from \"./channels/channel-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Metrics collection options for different metric types.",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "export interface MetricsOptions {",
                    "lineNumber": 7,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Channel name (for 'channel' and 'channel_users' types) */",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "  channel?: string;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Array of channel names (for 'channels' type) */",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "  channels?: string[];",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Info fields to include (comma-separated or array) */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "  info?: string | string[];",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "  /** Filter prefix for channel names (for 'channels' type) */",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "  filter?: string;",
                    "lineNumber": 15,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 16,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel information structure.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "export interface ChannelInfo {",
                    "lineNumber": 21,
                    "isSignature": true
                  },
                  {
                    "text": "  /** Whether the channel is occupied (has connections) */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "  occupied?: boolean",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 29,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 30,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.13134253025054932
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Get the connections for the given application.\n   *\n   * @param application - The application\n   * @returns Connection information\n   */\n  protected connections(application: Application): Record<string, unknown> {\n    return this.channels.for(application).connections();\n  }\n\n  /**\n   * Gather metrics from all subscribers for the given type.\n   *\n   * @param application - The application to gather metrics for\n   * @param type - The type of metrics to gather\n   * @param options - Additional options for the metrics request\n   * @returns Promise resolving to the aggregated metrics\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 291,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 292,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 293,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the connections for the given application.",
                    "lineNumber": 294,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 295,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application",
                    "lineNumber": 296,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Connection information",
                    "lineNumber": 297,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 298,
                    "isSignature": false
                  },
                  {
                    "text": "  protected connections(application: Application): Record<string, unknown> {",
                    "lineNumber": 299,
                    "isSignature": false
                  },
                  {
                    "text": "    return this.channels.for(application).connections();",
                    "lineNumber": 300,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 301,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 302,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 303,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gather metrics from all subscribers for the given type.",
                    "lineNumber": 304,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 305,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to gather metrics for",
                    "lineNumber": 306,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to gather",
                    "lineNumber": 307,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 308,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the aggregated metrics",
                    "lineNumber": 309,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 310,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.12714670598506927
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\nprotected getCachedPayload(channel: Channel): Record<string, unknown> | null {\n\n  }\n\n  /**\n   * Get the number of unique users subscribed to the presence channel.\n   *\n   * @param channel - The presence channel\n   * @returns Number of unique users\n   */\n  protected userCount(channel: Channel): number {\n    const seenUserIds = new Set<string>();\n\n    // channel.connections() returns Record<string, ChannelConnection>, convert to array\n    const connections = Object.values(channel.connections());\n    for (const channelConnection of connections) {\n      // channelConnection.data() returns Map<string, unknown>, get user_id from Map\n      const connectionData = channelConnection.data();\n      const userId = connectionData.get(\"user_id\") as string | undefined;\n      if (userId) {\n        seenUserIds.add(userId);\n      }\n    }\n\n    return seenUserIds.size;\n  }\n\n  /**\n   * Generate a random alphanumeric key.\n   *\n   * @param length - Length of the key to generate\n   * @returns Random key string\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "protected getCachedPayload(channel: Channel): Record<string, unknown> | null {",
                    "lineNumber": 652,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 659,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 660,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 661,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 662,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the number of unique users subscribed to the presence channel.",
                    "lineNumber": 663,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 664,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channel - The presence channel",
                    "lineNumber": 665,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Number of unique users",
                    "lineNumber": 666,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 667,
                    "isSignature": false
                  },
                  {
                    "text": "  protected userCount(channel: Channel): number {",
                    "lineNumber": 668,
                    "isSignature": false
                  },
                  {
                    "text": "    const seenUserIds = new Set<string>();",
                    "lineNumber": 669,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 670,
                    "isSignature": false
                  },
                  {
                    "text": "    // channel.connections() returns Record<string, ChannelConnection>, convert to array",
                    "lineNumber": 671,
                    "isSignature": false
                  },
                  {
                    "text": "    const connections = Object.values(channel.connections());",
                    "lineNumber": 672,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const channelConnection of connections) {",
                    "lineNumber": 673,
                    "isSignature": false
                  },
                  {
                    "text": "      // channelConnection.data() returns Map<string, unknown>, get user_id from Map",
                    "lineNumber": 674,
                    "isSignature": false
                  },
                  {
                    "text": "      const connectionData = channelConnection.data();",
                    "lineNumber": 675,
                    "isSignature": false
                  },
                  {
                    "text": "      const userId = connectionData.get(\"user_id\") as string | undefined;",
                    "lineNumber": 676,
                    "isSignature": false
                  },
                  {
                    "text": "      if (userId) {",
                    "lineNumber": 677,
                    "isSignature": false
                  },
                  {
                    "text": "        seenUserIds.add(userId);",
                    "lineNumber": 678,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 679,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 680,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 681,
                    "isSignature": false
                  },
                  {
                    "text": "    return seenUserIds.size;",
                    "lineNumber": 682,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 683,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 684,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 685,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate a random alphanumeric key.",
                    "lineNumber": 686,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 687,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param length - Length of the key to generate",
                    "lineNumber": 688,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Random key string",
                    "lineNumber": 689,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 690,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.10269709676504135
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/metrics-handler.ts",
                "range": {
                  "startPosition": {
                    "line": 132,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 737,
                    "column": 1
                  }
                },
                "contents": "export class MetricsHandler {\n\n\n  /**\n   * Gather the metrics for the given type.\n   *\n   * @param application - The application to gather metrics for\n   * @param type - The type of metrics to gather\n   * @param options - Additional options for the metrics request\n   * @returns Promise resolving to the metrics data\n   */\n  async gather(\n    application: Application,\n    type: string,\n    options: MetricsOptions = {},\n  ): Promise<unknown> {\n    return this.serverProviderManager.subscribesToEvents()\n      ? this.gatherMetricsFromSubscribers(application, type, options)\n      : this.get(application, type, options);\n  }\n\n  /**\n   * Get the metrics for the given type.\n   *\n   * @param application - The application to get metrics for\n   * @param type - The type of metrics to get\n   * @param options - Additional options for the metrics request\n   * @returns The metrics data\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 133,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 133,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 134,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class MetricsHandler {",
                    "lineNumber": 133,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "   * Gather the metrics for the given type.",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to gather metrics for",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to gather",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the metrics data",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "  async gather(",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    type: string,",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "    options: MetricsOptions = {},",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<unknown> {",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "    return this.serverProviderManager.subscribesToEvents()",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "      ? this.gatherMetricsFromSubscribers(application, type, options)",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "      : this.get(application, type, options);",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the metrics for the given type.",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application to get metrics for",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param type - The type of metrics to get",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param options - Additional options for the metrics request",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The metrics data",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 738,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.09981189668178558
            }
          ]
        }
      }
    }

### Assistant

Checking the Connection import in EventsBatchController:

### Tool · read (started)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** success
        * lines: 1-30
    * **content:**

    import type { Application } from "../../../../application";
    import type { Connection } from "../../../../servers/reverb/http/connection";
    import { Response } from "../../../../servers/reverb/http/response";
    import type { IHttpRequest } from "../../../../servers/reverb/http/router";
    import type { ChannelManager } from "../../contracts/channel-manager";
    import { dispatch } from "../../event-dispatcher";
    import type { MetricsHandler } from "../../metrics-handler";
    
    /**
     * Batch item structure
     */
    interface BatchItem {
      name: string;
      channel: string;
      data: string;
      socket_id?: string;
      info?: string;
    }
    
    /**
     * Validation error structure
     */
    interface ValidationErrors {
      [key: string]: string[];
    }
    
    /**
     * EventsBatchController - Handles batch event dispatching
     *
     * Implements POST /apps/:appId/batch_events endpoint for triggering

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1186-1220
    * **content:**

        return {
          method,
          path: pathWithQuery,
          url: req.url, // Include full URL with query string for controllers to access query params
          httpVersion: "1.1",
          body,
          getMethod(): string {
            return method;
          },
          getPath(): string {
            // Return path without query string for Pusher signature verification
            // Pusher signatures are calculated over the path without the query string
            return pathWithoutQuery;
          },
          getHost(): string {
            return host;
          },
          getHeader(name: string): string | undefined {
            return headers[name.toLowerCase()];
          },
          getHeaders(): Record<string, string> {
            return { ...headers };
          },
          getUri(): { path: string; host: string } {
            return { path: pathWithoutQuery, host };
          },
          getSize(): number {
            return Buffer.byteLength(body, "utf8");
          },
        };
      }
    
      /**
       * Create a mock HTTP connection for controller use
       *

### Assistant

Creating a todo list and starting fixes:

### Tool · update Todos (started)

    {
      "args": {
        "todos": [
          {
            "id": "1",
            "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
            "status": "TODO_STATUS_IN_PROGRESS",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "2",
            "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "3",
            "content": "Fix lint errors - replace any types with concrete types in test files",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "5",
            "content": "Commit and push changes",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          }
        ],
        "merge": false
      }
    }

### Tool · update Todos (completed)

    {
      "args": {
        "todos": [
          {
            "id": "1",
            "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
            "status": "TODO_STATUS_IN_PROGRESS",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "2",
            "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "3",
            "content": "Fix lint errors - replace any types with concrete types in test files",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          },
          {
            "id": "5",
            "content": "Commit and push changes",
            "status": "TODO_STATUS_PENDING",
            "createdAt": "1763064925830",
            "updatedAt": "1763064925830",
            "dependencies": []
          }
        ],
        "merge": false
      },
      "result": {
        "success": {
          "todos": [
            {
              "id": "1",
              "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
              "status": "TODO_STATUS_IN_PROGRESS",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "2",
              "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "3",
              "content": "Fix lint errors - replace any types with concrete types in test files",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "4",
              "content": "Run typecheck and lint to verify fixes",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "5",
              "content": "Commit and push changes",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            }
          ],
          "totalCount": 5
        }
      }
    }

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1140-1219
    * **content:**

        }
    
        return filtered;
      }
    
      /**
       * Determine whether the server uses TLS
       *
       * Checks if TLS context has both certificate and key configured.
       *
       * @param context - TLS context to check
       * @returns True if TLS is configured, false otherwise
       *
       * @private
       */
      private static usesTls(context: TlsContext): boolean {
        return !!(context.local_cert || context.local_pk);
      }
    
      /**
       * Convert Bun Request to IHttpRequest
       *
       * @param req - The Bun Request object
       * @returns IHttpRequest interface
       *
       * @private
       */
      private static async convertToHttpRequest(
        req: Request,
      ): Promise<
        IHttpRequest & { url: string; httpVersion: string; getSize(): number }
      > {
        const url = new URL(req.url);
        const body = req.method !== "GET" ? await req.text() : "";
        const method = req.method;
        // Store pathname + search for full path, but pathname only for signature verification
        const pathWithQuery = url.pathname + url.search;
        const pathWithoutQuery = url.pathname;
        const host = url.host;
    
        // Convert Headers to Record<string, string>
        const headers: Record<string, string> = {};
        req.headers.forEach((value, key) => {
          headers[key.toLowerCase()] = value;
        });
    
        return {
          method,
          path: pathWithQuery,
          url: req.url, // Include full URL with query string for controllers to access query params
          httpVersion: "1.1",
          body,
          getMethod(): string {
            return method;
          },
          getPath(): string {
            // Return path without query string for Pusher signature verification
            // Pusher signatures are calculated over the path without the query string
            return pathWithoutQuery;
          },
          getHost(): string {
            return host;
          },
          getHeader(name: string): string | undefined {
            return headers[name.toLowerCase()];
          },
          getHeaders(): Record<string, string> {
            return { ...headers };
          },
          getUri(): { path: string; host: string } {
            return { path: pathWithoutQuery, host };
          },
          getSize(): number {
            return Buffer.byteLength(body, "utf8");
          },
        };
      }
    
      /**
       * Create a mock HTTP connection for controller use

### Assistant

Fixing the issues. Starting with convertToHttpRequest(): ensuring the return type matches IHttpRequest without excess properties.

### Tool · edit (started)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts"
      }
    }

### Tool · edit (completed)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts"
      },
      "result": {
        "success": {
          "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts",
          "resultForModel": "",
          "linesAdded": 3,
          "linesRemoved": 1,
          "diffString": "      });\n  \n-     return {\n+     const request: IHttpRequest & { url: string; httpVersion: string; getSize(): number } = {\n        method,\n        path: pathWithQuery,\n...\n        },\n      };\n+ \n+     return request;\n    }\n  ",
          "beforeFullFileContent": "/**\n * Factory for creating Reverb WebSocket servers\n *\n * Creates and configures HTTP servers with WebSocket support for the Pusher protocol.\n * Handles routing, TLS/SSL configuration, and protocol selection.\n *\n * @module Servers/Reverb/Factory\n */\n\nimport type { ServeOptions, ServerWebSocket, WebSocket } from \"bun\";\nimport type { Application } from \"../../application\";\nimport { ApplicationManager } from \"../../application-manager\";\nimport { Certificate } from \"../../certificate\";\nimport type { ReverbConfig } from \"../../config/types\";\nimport { Connection as ReverbConnection } from \"../../connection\";\nimport type { IApplicationProvider } from \"../../contracts/application-provider\";\nimport { ServerProvider } from \"../../contracts/server-provider\";\nimport { FrameOpcode } from \"../../contracts/websocket-connection\";\nimport { CliLogger } from \"../../loggers/cli-logger\";\nimport { Log } from \"../../loggers/log\";\nimport type { NullLogger } from \"../../loggers/null-logger\";\nimport { ClientEvent } from \"../../protocols/pusher/client-event\";\nimport { EventHandler } from \"../../protocols/pusher/event-handler\";\nimport { ChannelController } from \"../../protocols/pusher/http/controllers/channel-controller\";\nimport { channelUsersController } from \"../../protocols/pusher/http/controllers/channel-users-controller\";\nimport { ChannelsController } from \"../../protocols/pusher/http/controllers/channels-controller\";\nimport { connectionsController } from \"../../protocols/pusher/http/controllers/connections-controller\";\nimport { EventsBatchController } from \"../../protocols/pusher/http/controllers/events-batch-controller\";\nimport { EventsController } from \"../../protocols/pusher/http/controllers/events-controller\";\nimport { UsersTerminateController } from \"../../protocols/pusher/http/controllers/users-terminate-controller\";\nimport { ArrayChannelConnectionManager } from \"../../protocols/pusher/managers/array-channel-connection-manager\";\nimport { ArrayChannelManager } from \"../../protocols/pusher/managers/array-channel-manager\";\nimport { MetricsHandler } from \"../../protocols/pusher/metrics-handler\";\nimport { Server as PusherServer } from \"../../protocols/pusher/server\";\nimport { Connection as WebSocketConnection } from \"./connection\";\nimport { Connection as HttpConnection } from \"./http/connection\";\nimport { Response as HttpResponse } from \"./http/response\";\nimport type { IHttpRequest } from \"./http/router\";\n\n/**\n * WebSocket connection data stored in Bun's ws.data\n */\ninterface WebSocketData {\n  app?: Application;\n  origin?: string | null;\n  connection?: ReverbConnection;\n  onMessage?: (message: string | Buffer) => void;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onPing?: () => void;\n  onPong?: () => void;\n}\n\n/**\n * Route definition for HTTP handlers\n */\ninterface RouteDefinition {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  path: string;\n  handler: (\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ) => Response | Promise<Response> | undefined;\n}\n\n/**\n * Router for handling HTTP requests with pattern matching\n */\nclass Router {\n  private routes: RouteDefinition[] = [];\n\n  /**\n   * Add a GET route\n   */\n  public get(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"GET\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a POST route\n   */\n  public post(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"POST\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a route\n   */\n  public add(\n    method: \"GET\" | \"POST\",\n    path: string,\n    handler: RouteDefinition[\"handler\"],\n  ): this {\n    this.routes.push({ method, path, handler });\n    return this;\n  }\n\n  /**\n   * Match a request to a route and extract parameters\n   */\n  public match(\n    method: string,\n    pathname: string,\n  ): {\n    handler: RouteDefinition[\"handler\"];\n    params: Record<string, string>;\n  } | null {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n\n      const params = this.matchPath(route.path, pathname);\n      if (params !== null) {\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Match a path pattern to a URL pathname\n   * Converts /apps/{appId}/events to regex and extracts parameters\n   */\n  private matchPath(\n    pattern: string,\n    pathname: string,\n  ): Record<string, string> | null {\n    // Convert pattern to regex: /apps/{appId}/events => /apps\\/([^/]+)\\/events/\n    const regexPattern = pattern\n      .replace(/\\//g, \"\\\\/\")\n      .replace(/\\{([^}]+)\\}/g, \"([^/]+)\");\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = pathname.match(regex);\n\n    if (!match) return null;\n\n    // Extract parameter names from pattern\n    const paramNames: string[] = [];\n    const paramRegex = /\\{([^}]+)\\}/g;\n    let match_params: RegExpExecArray | null = null;\n    match_params = paramRegex.exec(pattern);\n    while (match_params !== null) {\n      if (match_params[1]) {\n        paramNames.push(match_params[1]);\n      }\n      match_params = paramRegex.exec(pattern);\n    }\n\n    // Build params object from matched groups\n    const params: Record<string, string> = {};\n    paramNames.forEach((name, index) => {\n      params[name] = match[index + 1] || \"\";\n    });\n\n    return params;\n  }\n}\n\n/**\n * TLS/SSL configuration context\n */\ninterface TlsContext {\n  local_cert?: string;\n  local_pk?: string;\n  verify_peer?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * HTTP Server options for Bun\n */\ninterface HttpServerOptions {\n  tls?: TlsContext;\n  [key: string]: unknown;\n}\n\n/**\n * Factory for creating Reverb WebSocket servers with Pusher protocol support\n *\n * @class Factory\n * @example\n * ```typescript\n * const server = Factory.make('0.0.0.0', '8080', '', 'localhost');\n * ```\n */\n// biome-ignore lint/complexity/noStaticOnlyClass: Factory pattern requires static methods for singleton-like behavior\nexport class Factory {\n  /**\n   * Application manager for app lookup and validation\n   */\n  private static appManager: ApplicationManager | null = null;\n\n  /**\n   * Channel manager for managing Pusher channels\n   */\n  private static channelManager: ArrayChannelManager | null = null;\n\n  /**\n   * Pusher protocol server instance\n   */\n  private static pusherServer: PusherServer | null = null;\n\n  /**\n   * Logger instance\n   */\n  private static logger: CliLogger | NullLogger | null = null;\n\n  /**\n   * Metrics handler instance\n   */\n  private static metricsHandler: MetricsHandler | null = null;\n\n  /**\n   * Controller instances\n   */\n  private static eventsController: EventsController | null = null;\n  private static eventsBatchController: EventsBatchController | null = null;\n  private static channelsController: ChannelsController | null = null;\n  private static channelController: ChannelController | null = null;\n  private static usersTerminateController: UsersTerminateController | null =\n    null;\n\n  /**\n   * Application provider instance (used by controllers)\n   */\n  private static applicationProvider: IApplicationProvider | null = null;\n\n  /**\n   * Server provider instance (used by controllers)\n   */\n  private static serverProvider: ServerProvider | null = null;\n\n  /**\n   * Initialize the factory with configuration\n   *\n   * @param config - The Reverb configuration\n   */\n  public static initialize(config: ReverbConfig): void {\n    Factory.logger = new CliLogger();\n    // Set the logger in the Log facade so it's available globally\n    Log.setLogger(Factory.logger);\n    Factory.appManager = new ApplicationManager(config);\n\n    // Create application provider and channel connection manager\n    Factory.applicationProvider = Factory.appManager.driver();\n    const channelConnectionManager = new ArrayChannelConnectionManager();\n\n    Factory.channelManager = new ArrayChannelManager(\n      Factory.applicationProvider,\n      channelConnectionManager,\n      Factory.logger,\n    );\n\n    const eventHandler = new EventHandler(Factory.channelManager);\n    const clientEvent = new ClientEvent(Factory.channelManager);\n\n    Factory.pusherServer = new PusherServer(\n      Factory.channelManager,\n      eventHandler,\n      clientEvent,\n      Factory.logger,\n    );\n\n    // Create a minimal server provider\n    // By default, server does not subscribe to events (standalone mode)\n    Factory.serverProvider = new (class extends ServerProvider {\n      override subscribesToEvents(): boolean {\n        return false;\n      }\n    })();\n\n    // Initialize metrics handler with all required dependencies\n    Factory.metricsHandler = new MetricsHandler(\n      Factory.serverProvider,\n      Factory.channelManager,\n      null,\n    );\n\n    // Initialize class-based controllers with proper dependencies\n    Factory.eventsController = new EventsController(\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.eventsBatchController = new EventsBatchController(\n      Factory.metricsHandler,\n    );\n    Factory.channelsController = new ChannelsController(\n      Factory.metricsHandler,\n      Factory.applicationProvider,\n      Factory.channelManager,\n    );\n    Factory.channelController = new ChannelController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.usersTerminateController = new UsersTerminateController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.serverProvider,\n      undefined,\n    );\n  }\n\n  /**\n   * Get the channel manager instance\n   *\n   * @returns The channel manager instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getChannelManager(): ArrayChannelManager {\n    if (!Factory.channelManager) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.channelManager;\n  }\n\n  /**\n   * Get the application provider instance\n   *\n   * @returns The application provider instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getApplicationProvider(): IApplicationProvider {\n    if (!Factory.applicationProvider) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.applicationProvider;\n  }\n\n  /**\n   * Get the logger instance\n   *\n   * @returns The logger instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getLogger(): CliLogger | NullLogger {\n    if (!Factory.logger) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.logger;\n  }\n\n  /**\n   * Get the metrics handler instance\n   *\n   * @returns The metrics handler instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getMetricsHandler(): MetricsHandler {\n    if (!Factory.metricsHandler) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.metricsHandler;\n  }\n\n  /**\n   * Create a new WebSocket server instance\n   *\n   * Creates and configures an HTTP server with WebSocket support using Bun.\n   * Handles TLS/SSL configuration and protocol routing.\n   *\n   * @param host - Server host address (default: '0.0.0.0')\n   * @param port - Server port (default: '8080')\n   * @param path - URL path prefix for all routes (default: '')\n   * @param hostname - Hostname for TLS certificate resolution (optional)\n   * @param maxRequestSize - Maximum request size in bytes (default: 10000)\n   * @param options - Additional server options (default: {})\n   * @param protocol - Protocol to use ('pusher' only for now) (default: 'pusher')\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                      Used to determine TLS peer verification settings\n   * @returns The configured Bun server instance\n   *\n   * @throws {Error} If protocol is unsupported\n   *\n   * @example\n   * ```typescript\n   * const server = Factory.make('127.0.0.1', '8080', '', 'myapp.test', 10000, {}, 'pusher', 'production');\n   * console.log('Server running on port 8080');\n   * ```\n   */\n  public static make(\n    host = \"0.0.0.0\",\n    port = \"8080\",\n    path = \"\",\n    hostname?: string,\n    maxRequestSize = 10000,\n    options: HttpServerOptions = {},\n    protocol = \"pusher\",\n    environment: string = process.env.NODE_ENV || \"development\",\n  ) {\n    if (protocol !== \"pusher\") {\n      throw new Error(`Unsupported protocol [${protocol}].`);\n    }\n\n    const router = Factory.makePusherRouter(path);\n    const tlsContext = Factory.configureTls(\n      options.tls ?? {},\n      hostname,\n      environment,\n    );\n    const portNum = Number.parseInt(port, 10);\n\n    // Build Bun server options\n    const serveOptions: ServeOptions & { maxRequestBodySize?: number } = {\n      hostname: host,\n      port: portNum,\n      maxRequestBodySize: maxRequestSize,\n      fetch: async (req: Request, server: ReturnType<typeof Bun.serve>) =>\n        Factory.handleRequest(req, router, server),\n      websocket: {\n        open: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket open handler - create connection and notify Pusher server\n          const data = ws.data as WebSocketData | undefined;\n          if (!data || !data.app) {\n            console.error(\"WebSocket opened without app data\");\n            ws.close();\n            return;\n          }\n\n          try {\n            // Create WebSocket connection wrapper\n            const wsConnection = new WebSocketConnection(\n              ws as unknown as WebSocket,\n            );\n\n            // Create Reverb connection with app and origin\n            const connection = new ReverbConnection(\n              wsConnection,\n              data.app,\n              data.origin || null,\n            );\n\n            // Store connection in ws.data for later use\n            data.connection = connection;\n\n            // Notify Pusher server of new connection\n            if (Factory.pusherServer) {\n              Factory.pusherServer.open(connection);\n            }\n          } catch (error) {\n            console.error(\"Error opening WebSocket connection:\", error);\n            ws.close();\n          }\n        },\n        message: (ws: ServerWebSocket<unknown>, message: string | Buffer) => {\n          // WebSocket message handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            console.error(\"WebSocket message received without connection\");\n            return;\n          }\n\n          try {\n            const messageStr =\n              typeof message === \"string\" ? message : message.toString(\"utf-8\");\n\n            // Pass message to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.message(data.connection, messageStr);\n            }\n          } catch (error) {\n            console.error(\"Error handling WebSocket message:\", error);\n          }\n        },\n        close: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket close handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Notify Pusher server of connection close\n            if (Factory.pusherServer) {\n              Factory.pusherServer.close(data.connection);\n            }\n          } catch (error) {\n            console.error(\"Error closing WebSocket connection:\", error);\n          }\n        },\n        ping: (ws: ServerWebSocket<unknown>) => {\n          // Ping handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PING frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PING,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling ping:\", error);\n          }\n        },\n        pong: (ws: ServerWebSocket<unknown>) => {\n          // Pong handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PONG frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PONG,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling pong:\", error);\n          }\n        },\n      },\n    };\n\n    // Add TLS configuration if present\n    if (\n      Factory.usesTls(tlsContext) &&\n      tlsContext.local_cert &&\n      tlsContext.local_pk\n    ) {\n      serveOptions.tls = {\n        cert: Bun.file(tlsContext.local_cert),\n        key: Bun.file(tlsContext.local_pk),\n      };\n    }\n\n    return Bun.serve(serveOptions);\n  }\n\n  /**\n   * Handle incoming HTTP requests and route them appropriately\n   *\n   * @param req - The incoming request\n   * @param router - The router instance\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response to send back to client\n   *\n   * @private\n   */\n  private static async handleRequest(\n    req: Request,\n    router: Router,\n    server: ReturnType<typeof Bun.serve>,\n  ): Promise<Response | undefined> {\n    const url = new URL(req.url);\n    const pathname = url.pathname;\n    const method = req.method;\n\n    const match = router.match(method, pathname);\n    if (!match) {\n      return new Response(JSON.stringify({ error: \"Not Found\" }), {\n        status: 404,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    try {\n      // Pass server to handler for WebSocket upgrade support\n      return await Promise.resolve(match.handler(req, match.params, server));\n    } catch (error) {\n      console.error(\"Route handler error:\", error);\n      return new Response(JSON.stringify({ error: \"Internal Server Error\" }), {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n  }\n\n  /**\n   * Create a new router for the Pusher protocol\n   *\n   * Sets up all routes required for Pusher protocol support.\n   * This includes WebSocket connections and HTTP API endpoints.\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Router - Configured router instance\n   *\n   * @private\n   */\n  private static makePusherRouter(path: string): Router {\n    const router = new Router();\n\n    // Set up Pusher routes with optional path prefix\n    const routes = Factory.pusherRoutes(path);\n\n    for (const route of routes) {\n      if (route.method === \"GET\") {\n        router.get(route.path, route.handler);\n      } else if (route.method === \"POST\") {\n        router.post(route.path, route.handler);\n      }\n    }\n\n    return router;\n  }\n\n  /**\n   * Generate the routes required to handle Pusher protocol requests\n   *\n   * Defines all HTTP API endpoints for:\n   * - WebSocket connections\n   * - Event triggering\n   * - Connection management\n   * - Channel information\n   * - Health checks\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Array of route definitions\n   *\n   * @private\n   */\n  private static pusherRoutes(path: string): RouteDefinition[] {\n    const basePath = path || \"\";\n    const prefix = (route: string) => `${basePath}${route}`;\n\n    return [\n      {\n        method: \"GET\",\n        path: prefix(\"/app/{appKey}\"),\n        handler: Factory.handleWebSocketConnection.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/events\"),\n        handler: Factory.handleEvents.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/batch_events\"),\n        handler: Factory.handleBatchEvents.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/connections\"),\n        handler: Factory.handleConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels\"),\n        handler: Factory.handleChannels.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}\"),\n        handler: Factory.handleChannelInfo.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),\n        handler: Factory.handleChannelUsers.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),\n        handler: Factory.handleTerminateConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/up\"),\n        handler: Factory.handleHealthCheck.bind(Factory),\n      },\n    ];\n  }\n\n  /**\n   * Handle WebSocket connection requests\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appKey\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response with WebSocket upgrade or error, or undefined for successful upgrade\n   *\n   * @private\n   */\n  private static handleWebSocketConnection(\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ): Response | undefined {\n    // Check if this is a WebSocket upgrade request\n    if (req.headers.get(\"upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket upgrade\", { status: 400 });\n    }\n\n    if (!server) {\n      return new Response(\"Server instance not available\", { status: 500 });\n    }\n\n    if (!Factory.appManager || !Factory.pusherServer) {\n      return new Response(\n        \"Server not initialized. Call Factory.initialize() first.\",\n        { status: 500 },\n      );\n    }\n\n    const appKey = params.appKey;\n    if (!appKey) {\n      return new Response(\"Missing app key\", { status: 400 });\n    }\n\n    // Find application by key\n    let app: Application | null = null;\n    try {\n      const provider = Factory.appManager.driver();\n      app = provider.findByKey(appKey);\n    } catch (error) {\n      console.error(\"Error finding application:\", error);\n      return new Response(\"Invalid application\", { status: 404 });\n    }\n\n    if (!app) {\n      return new Response(\"Application not found\", { status: 404 });\n    }\n\n    // Get origin from request\n    const origin = req.headers.get(\"origin\");\n\n    // Set up WebSocket data with app and origin for use in handlers\n    const wsData: WebSocketData = {\n      app,\n      origin,\n    };\n\n    // Upgrade the connection to WebSocket\n    const upgraded = server.upgrade(req, {\n      data: wsData,\n    });\n\n    if (!upgraded) {\n      return new Response(\"WebSocket upgrade failed\", { status: 500 });\n    }\n\n    // Return undefined to indicate successful upgrade (Bun requirement)\n    // The actual connection handling will happen in the websocket.open handler\n    return undefined;\n  }\n\n  /**\n   * Handle event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      // Convert Bun Request to IHttpRequest\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n\n      // Get the application\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      // Call the controller\n      const response = await Factory.eventsController.__invoke(\n        httpRequest,\n        httpConnection,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle batch event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleBatchEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsBatchController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      const response = await Factory.eventsBatchController.handle(\n        httpRequest,\n        httpConnection,\n        params.appId,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling batch events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle connection listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of connections\n   *\n   * @private\n   */\n  private static async handleConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await connectionsController(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of channels\n   *\n   * @private\n   */\n  private static async handleChannels(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelsController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await Factory.channelsController.__invoke(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channels:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel information request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with channel info\n   *\n   * @private\n   */\n  private static async handleChannelInfo(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const response = await Factory.channelController.handle(\n        req,\n        params.appId,\n        params.channel,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel info:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel users listing (presence)\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with list of users in channel\n   *\n   * @private\n   */\n  private static async handleChannelUsers(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await channelUsersController(\n        httpRequest,\n        httpConnection,\n        params.channel,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel users:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle user connection termination\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and userId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleTerminateConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.usersTerminateController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.userId) {\n      return new Response(\"Missing appId or userId parameter\", { status: 400 });\n    }\n\n    try {\n      const response = await Factory.usersTerminateController.handle(\n        req,\n        params.appId,\n        params.userId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling terminate connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle health check request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters (none for this endpoint)\n   * @returns Response indicating server health\n   *\n   * @private\n   */\n  private static handleHealthCheck(\n    _req: Request,\n    _params: Record<string, string>,\n  ): Response {\n    return Response.json({ health: \"OK\" }, { status: 200 });\n  }\n\n  /**\n   * Configure TLS context for the server\n   *\n   * Filters out null values and attempts to auto-detect certificates\n   * for the given hostname if not explicitly provided.\n   * Sets verify_peer to true in production environments for better security.\n   *\n   * @param context - Initial TLS context (may contain null values)\n   * @param hostname - Hostname for certificate auto-detection\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                     Used to determine TLS peer verification settings\n   * @returns Configured TLS context\n   *\n   * @private\n   */\n  private static configureTls(\n    context: TlsContext,\n    hostname?: string,\n    environment: string = process.env.NODE_ENV || \"development\",\n  ): TlsContext {\n    // Filter out null/undefined values\n    const filtered: TlsContext = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (value !== null && value !== undefined) {\n        filtered[key] = value;\n      }\n    }\n\n    // Try to auto-detect certificates if not provided and hostname is given\n    if (\n      !Factory.usesTls(filtered) &&\n      hostname &&\n      Certificate.exists(hostname)\n    ) {\n      const certs = Certificate.resolve(hostname);\n      if (certs) {\n        const [certPath, keyPath] = certs;\n        filtered.local_cert = certPath;\n        filtered.local_pk = keyPath;\n        // Enable peer verification in production for better security\n        filtered.verify_peer = environment === \"production\";\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Determine whether the server uses TLS\n   *\n   * Checks if TLS context has both certificate and key configured.\n   *\n   * @param context - TLS context to check\n   * @returns True if TLS is configured, false otherwise\n   *\n   * @private\n   */\n  private static usesTls(context: TlsContext): boolean {\n    return !!(context.local_cert || context.local_pk);\n  }\n\n  /**\n   * Convert Bun Request to IHttpRequest\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\n    const url = new URL(req.url);\n    const body = req.method !== \"GET\" ? await req.text() : \"\";\n    const method = req.method;\n    // Store pathname + search for full path, but pathname only for signature verification\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    return {\n      method,\n      path: pathWithQuery,\n      url: req.url, // Include full URL with query string for controllers to access query params\n      httpVersion: \"1.1\",\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        // Return path without query string for Pusher signature verification\n        // Pusher signatures are calculated over the path without the query string\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n      getSize(): number {\n        return Buffer.byteLength(body, \"utf8\");\n      },\n    };\n  }\n\n  /**\n   * Create a mock HTTP connection for controller use\n   *\n   * @returns HTTP Connection object\n   *\n   * @private\n   */\n  private static createHttpConnection(): HttpConnection {\n    return new HttpConnection({\n      stream: Math.floor(Math.random() * 1000000),\n    });\n  }\n\n  /**\n   * Convert controller Response to Bun Response\n   *\n   * @param controllerResponse - The response from the controller\n   * @returns Bun Response object\n   *\n   * @private\n   */\n  private static convertToResponse(\n    controllerResponse:\n      | HttpResponse\n      | { status?: number; content?: string | Record<string, unknown> },\n  ): Response {\n    // Check if it's our custom HttpResponse class\n    if (controllerResponse instanceof HttpResponse) {\n      const status = controllerResponse.getStatusCode();\n      const body = controllerResponse.getContent();\n      const headers = controllerResponse.getHeaders();\n\n      return new Response(body, {\n        status,\n        headers,\n      });\n    }\n\n    // Fallback for other response types\n    const status = controllerResponse.status || 200;\n    const body =\n      typeof controllerResponse.content === \"string\"\n        ? controllerResponse.content\n        : JSON.stringify(controllerResponse.content);\n\n    return new Response(body, {\n      status,\n      headers: {\n        \"Content-Type\":\n          typeof controllerResponse.content === \"string\"\n            ? \"text/plain\"\n            : \"application/json\",\n      },\n    });\n  }\n}\n",
          "afterFullFileContent": "/**\n * Factory for creating Reverb WebSocket servers\n *\n * Creates and configures HTTP servers with WebSocket support for the Pusher protocol.\n * Handles routing, TLS/SSL configuration, and protocol selection.\n *\n * @module Servers/Reverb/Factory\n */\n\nimport type { ServeOptions, ServerWebSocket, WebSocket } from \"bun\";\nimport type { Application } from \"../../application\";\nimport { ApplicationManager } from \"../../application-manager\";\nimport { Certificate } from \"../../certificate\";\nimport type { ReverbConfig } from \"../../config/types\";\nimport { Connection as ReverbConnection } from \"../../connection\";\nimport type { IApplicationProvider } from \"../../contracts/application-provider\";\nimport { ServerProvider } from \"../../contracts/server-provider\";\nimport { FrameOpcode } from \"../../contracts/websocket-connection\";\nimport { CliLogger } from \"../../loggers/cli-logger\";\nimport { Log } from \"../../loggers/log\";\nimport type { NullLogger } from \"../../loggers/null-logger\";\nimport { ClientEvent } from \"../../protocols/pusher/client-event\";\nimport { EventHandler } from \"../../protocols/pusher/event-handler\";\nimport { ChannelController } from \"../../protocols/pusher/http/controllers/channel-controller\";\nimport { channelUsersController } from \"../../protocols/pusher/http/controllers/channel-users-controller\";\nimport { ChannelsController } from \"../../protocols/pusher/http/controllers/channels-controller\";\nimport { connectionsController } from \"../../protocols/pusher/http/controllers/connections-controller\";\nimport { EventsBatchController } from \"../../protocols/pusher/http/controllers/events-batch-controller\";\nimport { EventsController } from \"../../protocols/pusher/http/controllers/events-controller\";\nimport { UsersTerminateController } from \"../../protocols/pusher/http/controllers/users-terminate-controller\";\nimport { ArrayChannelConnectionManager } from \"../../protocols/pusher/managers/array-channel-connection-manager\";\nimport { ArrayChannelManager } from \"../../protocols/pusher/managers/array-channel-manager\";\nimport { MetricsHandler } from \"../../protocols/pusher/metrics-handler\";\nimport { Server as PusherServer } from \"../../protocols/pusher/server\";\nimport { Connection as WebSocketConnection } from \"./connection\";\nimport { Connection as HttpConnection } from \"./http/connection\";\nimport { Response as HttpResponse } from \"./http/response\";\nimport type { IHttpRequest } from \"./http/router\";\n\n/**\n * WebSocket connection data stored in Bun's ws.data\n */\ninterface WebSocketData {\n  app?: Application;\n  origin?: string | null;\n  connection?: ReverbConnection;\n  onMessage?: (message: string | Buffer) => void;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onPing?: () => void;\n  onPong?: () => void;\n}\n\n/**\n * Route definition for HTTP handlers\n */\ninterface RouteDefinition {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  path: string;\n  handler: (\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ) => Response | Promise<Response> | undefined;\n}\n\n/**\n * Router for handling HTTP requests with pattern matching\n */\nclass Router {\n  private routes: RouteDefinition[] = [];\n\n  /**\n   * Add a GET route\n   */\n  public get(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"GET\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a POST route\n   */\n  public post(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"POST\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a route\n   */\n  public add(\n    method: \"GET\" | \"POST\",\n    path: string,\n    handler: RouteDefinition[\"handler\"],\n  ): this {\n    this.routes.push({ method, path, handler });\n    return this;\n  }\n\n  /**\n   * Match a request to a route and extract parameters\n   */\n  public match(\n    method: string,\n    pathname: string,\n  ): {\n    handler: RouteDefinition[\"handler\"];\n    params: Record<string, string>;\n  } | null {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n\n      const params = this.matchPath(route.path, pathname);\n      if (params !== null) {\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Match a path pattern to a URL pathname\n   * Converts /apps/{appId}/events to regex and extracts parameters\n   */\n  private matchPath(\n    pattern: string,\n    pathname: string,\n  ): Record<string, string> | null {\n    // Convert pattern to regex: /apps/{appId}/events => /apps\\/([^/]+)\\/events/\n    const regexPattern = pattern\n      .replace(/\\//g, \"\\\\/\")\n      .replace(/\\{([^}]+)\\}/g, \"([^/]+)\");\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = pathname.match(regex);\n\n    if (!match) return null;\n\n    // Extract parameter names from pattern\n    const paramNames: string[] = [];\n    const paramRegex = /\\{([^}]+)\\}/g;\n    let match_params: RegExpExecArray | null = null;\n    match_params = paramRegex.exec(pattern);\n    while (match_params !== null) {\n      if (match_params[1]) {\n        paramNames.push(match_params[1]);\n      }\n      match_params = paramRegex.exec(pattern);\n    }\n\n    // Build params object from matched groups\n    const params: Record<string, string> = {};\n    paramNames.forEach((name, index) => {\n      params[name] = match[index + 1] || \"\";\n    });\n\n    return params;\n  }\n}\n\n/**\n * TLS/SSL configuration context\n */\ninterface TlsContext {\n  local_cert?: string;\n  local_pk?: string;\n  verify_peer?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * HTTP Server options for Bun\n */\ninterface HttpServerOptions {\n  tls?: TlsContext;\n  [key: string]: unknown;\n}\n\n/**\n * Factory for creating Reverb WebSocket servers with Pusher protocol support\n *\n * @class Factory\n * @example\n * ```typescript\n * const server = Factory.make('0.0.0.0', '8080', '', 'localhost');\n * ```\n */\n// biome-ignore lint/complexity/noStaticOnlyClass: Factory pattern requires static methods for singleton-like behavior\nexport class Factory {\n  /**\n   * Application manager for app lookup and validation\n   */\n  private static appManager: ApplicationManager | null = null;\n\n  /**\n   * Channel manager for managing Pusher channels\n   */\n  private static channelManager: ArrayChannelManager | null = null;\n\n  /**\n   * Pusher protocol server instance\n   */\n  private static pusherServer: PusherServer | null = null;\n\n  /**\n   * Logger instance\n   */\n  private static logger: CliLogger | NullLogger | null = null;\n\n  /**\n   * Metrics handler instance\n   */\n  private static metricsHandler: MetricsHandler | null = null;\n\n  /**\n   * Controller instances\n   */\n  private static eventsController: EventsController | null = null;\n  private static eventsBatchController: EventsBatchController | null = null;\n  private static channelsController: ChannelsController | null = null;\n  private static channelController: ChannelController | null = null;\n  private static usersTerminateController: UsersTerminateController | null =\n    null;\n\n  /**\n   * Application provider instance (used by controllers)\n   */\n  private static applicationProvider: IApplicationProvider | null = null;\n\n  /**\n   * Server provider instance (used by controllers)\n   */\n  private static serverProvider: ServerProvider | null = null;\n\n  /**\n   * Initialize the factory with configuration\n   *\n   * @param config - The Reverb configuration\n   */\n  public static initialize(config: ReverbConfig): void {\n    Factory.logger = new CliLogger();\n    // Set the logger in the Log facade so it's available globally\n    Log.setLogger(Factory.logger);\n    Factory.appManager = new ApplicationManager(config);\n\n    // Create application provider and channel connection manager\n    Factory.applicationProvider = Factory.appManager.driver();\n    const channelConnectionManager = new ArrayChannelConnectionManager();\n\n    Factory.channelManager = new ArrayChannelManager(\n      Factory.applicationProvider,\n      channelConnectionManager,\n      Factory.logger,\n    );\n\n    const eventHandler = new EventHandler(Factory.channelManager);\n    const clientEvent = new ClientEvent(Factory.channelManager);\n\n    Factory.pusherServer = new PusherServer(\n      Factory.channelManager,\n      eventHandler,\n      clientEvent,\n      Factory.logger,\n    );\n\n    // Create a minimal server provider\n    // By default, server does not subscribe to events (standalone mode)\n    Factory.serverProvider = new (class extends ServerProvider {\n      override subscribesToEvents(): boolean {\n        return false;\n      }\n    })();\n\n    // Initialize metrics handler with all required dependencies\n    Factory.metricsHandler = new MetricsHandler(\n      Factory.serverProvider,\n      Factory.channelManager,\n      null,\n    );\n\n    // Initialize class-based controllers with proper dependencies\n    Factory.eventsController = new EventsController(\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.eventsBatchController = new EventsBatchController(\n      Factory.metricsHandler,\n    );\n    Factory.channelsController = new ChannelsController(\n      Factory.metricsHandler,\n      Factory.applicationProvider,\n      Factory.channelManager,\n    );\n    Factory.channelController = new ChannelController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.usersTerminateController = new UsersTerminateController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.serverProvider,\n      undefined,\n    );\n  }\n\n  /**\n   * Get the channel manager instance\n   *\n   * @returns The channel manager instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getChannelManager(): ArrayChannelManager {\n    if (!Factory.channelManager) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.channelManager;\n  }\n\n  /**\n   * Get the application provider instance\n   *\n   * @returns The application provider instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getApplicationProvider(): IApplicationProvider {\n    if (!Factory.applicationProvider) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.applicationProvider;\n  }\n\n  /**\n   * Get the logger instance\n   *\n   * @returns The logger instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getLogger(): CliLogger | NullLogger {\n    if (!Factory.logger) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.logger;\n  }\n\n  /**\n   * Get the metrics handler instance\n   *\n   * @returns The metrics handler instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getMetricsHandler(): MetricsHandler {\n    if (!Factory.metricsHandler) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.metricsHandler;\n  }\n\n  /**\n   * Create a new WebSocket server instance\n   *\n   * Creates and configures an HTTP server with WebSocket support using Bun.\n   * Handles TLS/SSL configuration and protocol routing.\n   *\n   * @param host - Server host address (default: '0.0.0.0')\n   * @param port - Server port (default: '8080')\n   * @param path - URL path prefix for all routes (default: '')\n   * @param hostname - Hostname for TLS certificate resolution (optional)\n   * @param maxRequestSize - Maximum request size in bytes (default: 10000)\n   * @param options - Additional server options (default: {})\n   * @param protocol - Protocol to use ('pusher' only for now) (default: 'pusher')\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                      Used to determine TLS peer verification settings\n   * @returns The configured Bun server instance\n   *\n   * @throws {Error} If protocol is unsupported\n   *\n   * @example\n   * ```typescript\n   * const server = Factory.make('127.0.0.1', '8080', '', 'myapp.test', 10000, {}, 'pusher', 'production');\n   * console.log('Server running on port 8080');\n   * ```\n   */\n  public static make(\n    host = \"0.0.0.0\",\n    port = \"8080\",\n    path = \"\",\n    hostname?: string,\n    maxRequestSize = 10000,\n    options: HttpServerOptions = {},\n    protocol = \"pusher\",\n    environment: string = process.env.NODE_ENV || \"development\",\n  ) {\n    if (protocol !== \"pusher\") {\n      throw new Error(`Unsupported protocol [${protocol}].`);\n    }\n\n    const router = Factory.makePusherRouter(path);\n    const tlsContext = Factory.configureTls(\n      options.tls ?? {},\n      hostname,\n      environment,\n    );\n    const portNum = Number.parseInt(port, 10);\n\n    // Build Bun server options\n    const serveOptions: ServeOptions & { maxRequestBodySize?: number } = {\n      hostname: host,\n      port: portNum,\n      maxRequestBodySize: maxRequestSize,\n      fetch: async (req: Request, server: ReturnType<typeof Bun.serve>) =>\n        Factory.handleRequest(req, router, server),\n      websocket: {\n        open: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket open handler - create connection and notify Pusher server\n          const data = ws.data as WebSocketData | undefined;\n          if (!data || !data.app) {\n            console.error(\"WebSocket opened without app data\");\n            ws.close();\n            return;\n          }\n\n          try {\n            // Create WebSocket connection wrapper\n            const wsConnection = new WebSocketConnection(\n              ws as unknown as WebSocket,\n            );\n\n            // Create Reverb connection with app and origin\n            const connection = new ReverbConnection(\n              wsConnection,\n              data.app,\n              data.origin || null,\n            );\n\n            // Store connection in ws.data for later use\n            data.connection = connection;\n\n            // Notify Pusher server of new connection\n            if (Factory.pusherServer) {\n              Factory.pusherServer.open(connection);\n            }\n          } catch (error) {\n            console.error(\"Error opening WebSocket connection:\", error);\n            ws.close();\n          }\n        },\n        message: (ws: ServerWebSocket<unknown>, message: string | Buffer) => {\n          // WebSocket message handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            console.error(\"WebSocket message received without connection\");\n            return;\n          }\n\n          try {\n            const messageStr =\n              typeof message === \"string\" ? message : message.toString(\"utf-8\");\n\n            // Pass message to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.message(data.connection, messageStr);\n            }\n          } catch (error) {\n            console.error(\"Error handling WebSocket message:\", error);\n          }\n        },\n        close: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket close handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Notify Pusher server of connection close\n            if (Factory.pusherServer) {\n              Factory.pusherServer.close(data.connection);\n            }\n          } catch (error) {\n            console.error(\"Error closing WebSocket connection:\", error);\n          }\n        },\n        ping: (ws: ServerWebSocket<unknown>) => {\n          // Ping handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PING frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PING,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling ping:\", error);\n          }\n        },\n        pong: (ws: ServerWebSocket<unknown>) => {\n          // Pong handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PONG frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PONG,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling pong:\", error);\n          }\n        },\n      },\n    };\n\n    // Add TLS configuration if present\n    if (\n      Factory.usesTls(tlsContext) &&\n      tlsContext.local_cert &&\n      tlsContext.local_pk\n    ) {\n      serveOptions.tls = {\n        cert: Bun.file(tlsContext.local_cert),\n        key: Bun.file(tlsContext.local_pk),\n      };\n    }\n\n    return Bun.serve(serveOptions);\n  }\n\n  /**\n   * Handle incoming HTTP requests and route them appropriately\n   *\n   * @param req - The incoming request\n   * @param router - The router instance\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response to send back to client\n   *\n   * @private\n   */\n  private static async handleRequest(\n    req: Request,\n    router: Router,\n    server: ReturnType<typeof Bun.serve>,\n  ): Promise<Response | undefined> {\n    const url = new URL(req.url);\n    const pathname = url.pathname;\n    const method = req.method;\n\n    const match = router.match(method, pathname);\n    if (!match) {\n      return new Response(JSON.stringify({ error: \"Not Found\" }), {\n        status: 404,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    try {\n      // Pass server to handler for WebSocket upgrade support\n      return await Promise.resolve(match.handler(req, match.params, server));\n    } catch (error) {\n      console.error(\"Route handler error:\", error);\n      return new Response(JSON.stringify({ error: \"Internal Server Error\" }), {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n  }\n\n  /**\n   * Create a new router for the Pusher protocol\n   *\n   * Sets up all routes required for Pusher protocol support.\n   * This includes WebSocket connections and HTTP API endpoints.\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Router - Configured router instance\n   *\n   * @private\n   */\n  private static makePusherRouter(path: string): Router {\n    const router = new Router();\n\n    // Set up Pusher routes with optional path prefix\n    const routes = Factory.pusherRoutes(path);\n\n    for (const route of routes) {\n      if (route.method === \"GET\") {\n        router.get(route.path, route.handler);\n      } else if (route.method === \"POST\") {\n        router.post(route.path, route.handler);\n      }\n    }\n\n    return router;\n  }\n\n  /**\n   * Generate the routes required to handle Pusher protocol requests\n   *\n   * Defines all HTTP API endpoints for:\n   * - WebSocket connections\n   * - Event triggering\n   * - Connection management\n   * - Channel information\n   * - Health checks\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Array of route definitions\n   *\n   * @private\n   */\n  private static pusherRoutes(path: string): RouteDefinition[] {\n    const basePath = path || \"\";\n    const prefix = (route: string) => `${basePath}${route}`;\n\n    return [\n      {\n        method: \"GET\",\n        path: prefix(\"/app/{appKey}\"),\n        handler: Factory.handleWebSocketConnection.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/events\"),\n        handler: Factory.handleEvents.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/batch_events\"),\n        handler: Factory.handleBatchEvents.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/connections\"),\n        handler: Factory.handleConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels\"),\n        handler: Factory.handleChannels.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}\"),\n        handler: Factory.handleChannelInfo.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),\n        handler: Factory.handleChannelUsers.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),\n        handler: Factory.handleTerminateConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/up\"),\n        handler: Factory.handleHealthCheck.bind(Factory),\n      },\n    ];\n  }\n\n  /**\n   * Handle WebSocket connection requests\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appKey\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response with WebSocket upgrade or error, or undefined for successful upgrade\n   *\n   * @private\n   */\n  private static handleWebSocketConnection(\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ): Response | undefined {\n    // Check if this is a WebSocket upgrade request\n    if (req.headers.get(\"upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket upgrade\", { status: 400 });\n    }\n\n    if (!server) {\n      return new Response(\"Server instance not available\", { status: 500 });\n    }\n\n    if (!Factory.appManager || !Factory.pusherServer) {\n      return new Response(\n        \"Server not initialized. Call Factory.initialize() first.\",\n        { status: 500 },\n      );\n    }\n\n    const appKey = params.appKey;\n    if (!appKey) {\n      return new Response(\"Missing app key\", { status: 400 });\n    }\n\n    // Find application by key\n    let app: Application | null = null;\n    try {\n      const provider = Factory.appManager.driver();\n      app = provider.findByKey(appKey);\n    } catch (error) {\n      console.error(\"Error finding application:\", error);\n      return new Response(\"Invalid application\", { status: 404 });\n    }\n\n    if (!app) {\n      return new Response(\"Application not found\", { status: 404 });\n    }\n\n    // Get origin from request\n    const origin = req.headers.get(\"origin\");\n\n    // Set up WebSocket data with app and origin for use in handlers\n    const wsData: WebSocketData = {\n      app,\n      origin,\n    };\n\n    // Upgrade the connection to WebSocket\n    const upgraded = server.upgrade(req, {\n      data: wsData,\n    });\n\n    if (!upgraded) {\n      return new Response(\"WebSocket upgrade failed\", { status: 500 });\n    }\n\n    // Return undefined to indicate successful upgrade (Bun requirement)\n    // The actual connection handling will happen in the websocket.open handler\n    return undefined;\n  }\n\n  /**\n   * Handle event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      // Convert Bun Request to IHttpRequest\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n\n      // Get the application\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      // Call the controller\n      const response = await Factory.eventsController.__invoke(\n        httpRequest,\n        httpConnection,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle batch event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleBatchEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsBatchController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      const response = await Factory.eventsBatchController.handle(\n        httpRequest,\n        httpConnection,\n        params.appId,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling batch events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle connection listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of connections\n   *\n   * @private\n   */\n  private static async handleConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await connectionsController(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of channels\n   *\n   * @private\n   */\n  private static async handleChannels(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelsController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await Factory.channelsController.__invoke(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channels:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel information request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with channel info\n   *\n   * @private\n   */\n  private static async handleChannelInfo(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const response = await Factory.channelController.handle(\n        req,\n        params.appId,\n        params.channel,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel info:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel users listing (presence)\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with list of users in channel\n   *\n   * @private\n   */\n  private static async handleChannelUsers(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await channelUsersController(\n        httpRequest,\n        httpConnection,\n        params.channel,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel users:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle user connection termination\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and userId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleTerminateConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.usersTerminateController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.userId) {\n      return new Response(\"Missing appId or userId parameter\", { status: 400 });\n    }\n\n    try {\n      const response = await Factory.usersTerminateController.handle(\n        req,\n        params.appId,\n        params.userId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling terminate connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle health check request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters (none for this endpoint)\n   * @returns Response indicating server health\n   *\n   * @private\n   */\n  private static handleHealthCheck(\n    _req: Request,\n    _params: Record<string, string>,\n  ): Response {\n    return Response.json({ health: \"OK\" }, { status: 200 });\n  }\n\n  /**\n   * Configure TLS context for the server\n   *\n   * Filters out null values and attempts to auto-detect certificates\n   * for the given hostname if not explicitly provided.\n   * Sets verify_peer to true in production environments for better security.\n   *\n   * @param context - Initial TLS context (may contain null values)\n   * @param hostname - Hostname for certificate auto-detection\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                     Used to determine TLS peer verification settings\n   * @returns Configured TLS context\n   *\n   * @private\n   */\n  private static configureTls(\n    context: TlsContext,\n    hostname?: string,\n    environment: string = process.env.NODE_ENV || \"development\",\n  ): TlsContext {\n    // Filter out null/undefined values\n    const filtered: TlsContext = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (value !== null && value !== undefined) {\n        filtered[key] = value;\n      }\n    }\n\n    // Try to auto-detect certificates if not provided and hostname is given\n    if (\n      !Factory.usesTls(filtered) &&\n      hostname &&\n      Certificate.exists(hostname)\n    ) {\n      const certs = Certificate.resolve(hostname);\n      if (certs) {\n        const [certPath, keyPath] = certs;\n        filtered.local_cert = certPath;\n        filtered.local_pk = keyPath;\n        // Enable peer verification in production for better security\n        filtered.verify_peer = environment === \"production\";\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Determine whether the server uses TLS\n   *\n   * Checks if TLS context has both certificate and key configured.\n   *\n   * @param context - TLS context to check\n   * @returns True if TLS is configured, false otherwise\n   *\n   * @private\n   */\n  private static usesTls(context: TlsContext): boolean {\n    return !!(context.local_cert || context.local_pk);\n  }\n\n  /**\n   * Convert Bun Request to IHttpRequest\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\n    const url = new URL(req.url);\n    const body = req.method !== \"GET\" ? await req.text() : \"\";\n    const method = req.method;\n    // Store pathname + search for full path, but pathname only for signature verification\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    const request: IHttpRequest & { url: string; httpVersion: string; getSize(): number } = {\n      method,\n      path: pathWithQuery,\n      url: req.url, // Include full URL with query string for controllers to access query params\n      httpVersion: \"1.1\",\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        // Return path without query string for Pusher signature verification\n        // Pusher signatures are calculated over the path without the query string\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n      getSize(): number {\n        return Buffer.byteLength(body, \"utf8\");\n      },\n    };\n\n    return request;\n  }\n\n  /**\n   * Create a mock HTTP connection for controller use\n   *\n   * @returns HTTP Connection object\n   *\n   * @private\n   */\n  private static createHttpConnection(): HttpConnection {\n    return new HttpConnection({\n      stream: Math.floor(Math.random() * 1000000),\n    });\n  }\n\n  /**\n   * Convert controller Response to Bun Response\n   *\n   * @param controllerResponse - The response from the controller\n   * @returns Bun Response object\n   *\n   * @private\n   */\n  private static convertToResponse(\n    controllerResponse:\n      | HttpResponse\n      | { status?: number; content?: string | Record<string, unknown> },\n  ): Response {\n    // Check if it's our custom HttpResponse class\n    if (controllerResponse instanceof HttpResponse) {\n      const status = controllerResponse.getStatusCode();\n      const body = controllerResponse.getContent();\n      const headers = controllerResponse.getHeaders();\n\n      return new Response(body, {\n        status,\n        headers,\n      });\n    }\n\n    // Fallback for other response types\n    const status = controllerResponse.status || 200;\n    const body =\n      typeof controllerResponse.content === \"string\"\n        ? controllerResponse.content\n        : JSON.stringify(controllerResponse.content);\n\n    return new Response(body, {\n      status,\n      headers: {\n        \"Content-Type\":\n          typeof controllerResponse.content === \"string\"\n            ? \"text/plain\"\n            : \"application/json\",\n      },\n    });\n  }\n}\n"
        }
      }
    }

### Assistant

Checking the Connection type issue. Reviewing how HttpConnection is used and what the controller expects:

### Tool · grep (started)

    {
      "args": {
        "pattern": "import.*Connection",
        "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_73362e6b-3134-44f6-8c98-5582d27c58a"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "import.*Connection",
        "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_73362e6b-3134-44f6-8c98-5582d27c58a"
      },
      "result": {
        "success": {
          "pattern": "import.*Connection",
          "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [
                  {
                    "file": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 2,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/events-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 2,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 5,
                        "content": "import type { ChannelConnection } from \"../../channels/channel-connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/connections-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 4,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/channels-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 4,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/controller.ts",
                    "matches": [
                      {
                        "lineNumber": 3,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/channel-users-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 4,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/pusher-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 1,
                        "content": "import { Connection as ReverbConnection } from \"../../../../connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      },
                      {
                        "lineNumber": 4,
                        "content": "import type { Connection } from \"../../../../servers/reverb/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  },
                  {
                    "file": "src/protocols/pusher/http/controllers/health-check-controller.ts",
                    "matches": [
                      {
                        "lineNumber": 1,
                        "content": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                        "contentTruncated": false,
                        "isContextLine": false
                      }
                    ]
                  }
                ],
                "totalLines": 10,
                "totalMatchedLines": 10,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (started)

    * **path:** `src/protocols/pusher/http/controllers/events-controller.ts`
    * **status:** pending

### Tool · sem Search (started)

    {
      "args": {
        "query": "How do other HTTP controllers handle the connection parameter?",
        "targetDirectories": [
          "src/protocols/pusher/http/controllers"
        ],
        "explanation": ""
      }
    }

### Tool · read (completed)

    * **path:** `src/protocols/pusher/http/controllers/events-controller.ts`
    * **status:** success
        * lines: 1-100
    * **content:**

    import type { Application } from "../../../../application";
    import type { Connection } from "../../../../servers/reverb/http/connection";
    import { Response } from "../../../../servers/reverb/http/response";
    import type { IHttpRequest } from "../../../../servers/reverb/http/router";
    import type { ChannelConnection } from "../../channels/channel-connection";
    import type { ChannelManager } from "../../contracts/channel-manager";
    import { dispatch } from "../../event-dispatcher";
    import type { MetricsHandler } from "../../metrics-handler";
    import { Controller } from "./controller";
    
    /**
     * Validation error type
     */
    interface ValidationErrors {
      [field: string]: string[];
    }
    
    /**
     * Events payload structure
     */
    interface EventsPayload {
      name?: string;
      data?: string;
      channels?: string[];
      channel?: string;
      socket_id?: string;
      info?: string;
    }
    
    /**
     * Events Controller
     *
     * Handles POST /apps/:appId/events endpoint.
     * Triggers server-to-client events on one or more channels.
     *
     * This controller allows backend applications to trigger events on channels
     * without requiring a WebSocket connection. Events are validated and then
     * broadcast to all subscribed connections.
     *
     * @example
     * ```typescript
     * // POST /apps/123/events
     * // Body: {
     * //   "name": "my-event",
     * //   "data": "{\"message\":\"hello\"}",
     * //   "channels": ["my-channel"]
     * // }
     *
     * const controller = new EventsController(channelManager, metricsHandler);
     * const response = await controller.__invoke(request, connection, application, channelManager);
     * ```
     */
    export class EventsController extends Controller {
      /**
       * Create a new events controller instance.
       *
       * @param channelManager - The channel manager for accessing channels
       * @param metricsHandler - The metrics handler for gathering channel info
       */
      constructor(
        protected override readonly channelManager: ChannelManager,
        protected readonly metricsHandler: MetricsHandler,
      ) {
        // EventsController uses a simplified constructor since it doesn't need applicationProvider
        // The channelManager is already scoped to the app by the router
        super(null, channelManager);
      }
    
      /**
       * Handle the request to trigger events.
       *
       * Processes the incoming event trigger request:
       * 1. Parses and validates the request body
       * 2. Validates required fields (name, data, channels/channel)
       * 3. Dispatches the event to specified channels
       * 4. Optionally gathers and returns channel metrics
       *
       * @param request - The HTTP request object
       * @param connection - The connection object
       * @param application - The application context
       * @param channelManager - The channel manager scoped to the application
       * @returns Response with empty object or channel metrics
       */
      async __invoke(
        request: IHttpRequest,
        _connection: Connection,
        application: Application,
        channelManager: ChannelManager,
      ): Promise<Response> {
        // Parse the request body
        const body = this.getBody(request);
        let payload: EventsPayload;
    
        try {
          payload = JSON.parse(body);
        } catch (_error) {
          return new Response({ message: "Invalid JSON payload" }, 422);
        }
    
        // Validate the payload

### Tool · sem Search (completed)

    {
      "args": {
        "query": "How do other HTTP controllers handle the connection parameter?",
        "targetDirectories": [
          "src/protocols/pusher/http/controllers"
        ],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"src/protocols/pusher/http/controllers/connections-controller.ts\" startLine=\"2\" endLine=\"113\">\n     2|import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\n     3|import { Factory } from \"../../../../servers/reverb/factory\";\n     4|import type { Connection } from \"../../../../servers/reverb/http/connection\";\n     5|import { Response } from \"../../../../servers/reverb/http/response\";\n     6|import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\n     7|import type { ChannelManager } from \"../../contracts/channel-manager\";\n     8|import type { MetricsHandler } from \"../../metrics-handler\";\n     9|\n    10|/**\n    11| * Connections Controller\n    12| *\n    13| * Handles GET requests to retrieve connection information for an application.\n    14| *\n    15| * Endpoint: GET /apps/:appId/connections\n    16| *\n    17| * Returns:\n    18| * - 200 with connection count if successful\n    19| *\n    20| * Response Format:\n    21| * {\n    22| *   \"connections\": <number of active connections>\n    23| * }\n    24| *\n    25| * Authentication:\n    26| * - Requires valid Pusher authentication signature\n    27| * - Validates using auth_signature query parameter\n    28| *\n    29| * @example\n    30| * ```typescript\n    31| * // Usage in router\n    32| * router.get('/apps/:appId/connections', connectionsController);\n    33| *\n    34| * // Sample request\n    35| * GET /apps/123456/connections?auth_key=...&auth_signature=...\n    36| * ```\n    37| */\n    38|export async function connectionsController(\n    39|  request: IHttpRequest,\n    40|  _connection: Connection,\n    41|  appId: string,\n    42|): Promise<Response> {\n    43|  // Verify authentication and set up application/channels\n    44|  const { application } = await verify(request, _connection, appId);\n    45|\n    46|  // Get metrics handler instance\n    47|  const metricsHandler = getMetricsHandler();\n    48|\n    49|  // Gather connections metrics\n    50|  const connections = await metricsHandler.gather(application, \"connections\");\n    51|\n    52|  // Count the connections\n    53|  const connectionCount =\n    54|    typeof connections === \"object\" &&\n    55|    connections !== null &&\n    56|    !Array.isArray(connections)\n    57|      ? Object.keys(connections).length\n    58|      : 0;\n    59|\n    60|  return new Response({ connections: connectionCount });\n    61|}\n    62|\n    63|/**\n    64| * Verify the request authentication and set up application/channels.\n    65| *\n    66| * This function:\n    67| * 1. Parses query parameters\n    68| * 2. Extracts request body\n    69| * 3. Sets the application instance\n    70| * 4. Sets the channel manager\n    71| * 5. Verifies the Pusher authentication signature\n    72| *\n    73| * @param request - The HTTP request object\n    74| * @param connection - The connection object\n    75| * @param appId - The application ID from route parameters\n    76| * @returns Object containing application and channels instances\n    77| * @throws {Error} If authentication fails or application not found\n    78| */\n    79|async function verify(\n    80|  request: IHttpRequest,\n    81|  _connection: Connection,\n    82|  appId: string,\n    83|): Promise<{ application: Application; channels: ChannelManager }> {\n    84|  // Parse query parameters\n    85|  const path = request.path || request.getPath() || \"\";\n    86|  const url = new URL(path, \"http://localhost\");\n    87|  const query: Record<string, string> = {};\n    88|  url.searchParams.forEach((value, key) => {\n    89|    query[key] = value;\n    90|  });\n    91|\n    92|  // Get request body\n    93|  const body = request.body || \"\";\n    94|\n    95|  // Set application\n    96|  const application = await setApplication(appId);\n    97|\n    98|  // Set channels\n    99|  const channels = getChannelManager();\n   100|\n   101|  // Verify signature\n   102|  verifySignature(request, query, body, application);\n   103|\n   104|  return { application, channels };\n   105|}\n   106|\n   107|/**\n   108| * Set the application instance for the given app ID.\n   109| *\n   110| * @param appId - The application ID\n   111| * @returns The application instance\n   112| * @throws {Error} If application not found\n   113| */\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/controller.ts\" startLine=\"31\" endLine=\"105\">\n    31|export \n   ...\n    61|\n    62|\n    63|  /**\n    64|   * Verify that the incoming request is valid.\n    65|   *\n    66|   * Performs the following validations:\n    67|   * 1. Parses query parameters from the request path\n    68|   * 2. Extracts the request body\n    69|   * 3. Resolves and sets the application instance\n    70|   * 4. Sets up the channel manager for the application\n    71|   * 5. Verifies the HMAC signature\n    72|   *\n    73|   * @param request - The incoming HTTP request\n    74|   * @param connection - The HTTP connection\n    75|   * @param appId - The application ID from the route\n    76|   * @throws {HttpException} If validation fails\n    77|   */\n    78|  async verify(\n    79|    request: IHttpRequest,\n    80|    _connection: Connection,\n    81|    appId: string | null,\n    82|  ): Promise<void> {\n    83|    // Parse query parameters from URL\n    84|    const url = new URL(request.path, \"http://localhost\");\n    85|    const queryParams: Record<string, string> = {};\n    86|    url.searchParams.forEach((value, key) => {\n    87|      queryParams[key] = value;\n    88|    });\n    89|\n    90|    this.body = request.body;\n    91|    this.query = queryParams;\n    92|\n    93|    this.setApplication(appId);\n    94|    this.setChannels();\n    95|    await this.verifySignature(request);\n    96|  }\n    97|\n    98|  /**\n    99|   * Set the application instance for the incoming request's application ID.\n   100|   *\n   101|   * @param appId - The application ID to resolve\n   102|   * @returns The resolved Application instance\n   103|   * @throws {HttpException} 400 if application ID not provided\n   104|   * @throws {HttpException} 404 if no matching application found\n   105|   */\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/pusher-controller.ts\" startLine=\"27\" endLine=\"127\">\n    27|export class PusherController {\n   ...\n    81|\n    82|\n    83|  /**\n    84|   * Get the Reverb connection instance for the request.\n    85|   *\n    86|   * Looks up the application by key and creates a new ReverbConnection\n    87|   * with the application context and origin information.\n    88|   *\n    89|   * If the application is not found, sends an error message to the client\n    90|   * and closes the connection.\n    91|   *\n    92|   * @param request - The HTTP request\n    93|   * @param connection - The WebSocket connection wrapper\n    94|   * @param key - The application key\n    95|   * @returns The Reverb connection instance, or null if the application is invalid\n    96|   */\n    97|  protected connection(\n    98|    request: IHttpRequest,\n    99|    connection: Connection,\n   100|    key: string,\n   101|  ): ReverbConnection | null {\n   102|    try {\n   103|      const application = this.applications.findByKey(key);\n   104|\n   105|      return new ReverbConnection(\n   106|        connection,\n   107|        application,\n   108|        request.getHeader(\"Origin\") || null,\n   109|      );\n   110|    } catch (e) {\n   111|      const error = e as Error;\n   112|\n   113|      // Check if it's an InvalidApplication error\n   114|      if (error.name === \"InvalidApplication\") {\n   115|        connection.send(\n   116|          '{\"event\":\"pusher:error\",\"data\":\"{\\\\\"code\\\\\":4001,\\\\\"message\\\\\":\\\\\"Application does not exist\\\\\"}\"}',\n   117|        );\n   118|\n   119|        connection.close();\n   120|        return null;\n   121|      }\n   122|\n   123|      // Re-throw other errors\n   124|      throw error;\n   125|    }\n   126|  }\n   127|}\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/channel-controller.ts\" startLine=\"23\" endLine=\"282\">\n    23|export class ChannelController {\n   ...\n    55|\n    56|\n    57|  /**\n    58|   * Handle the incoming request.\n    59|   *\n    60|   * @param request - The incoming HTTP request\n    61|   * @param appId - The application ID from the route\n    62|   * @param channel - The channel name from the route\n    63|   * @returns Promise resolving to a Response with channel information\n    64|   *\n    65|   * @example\n    66|   * ```typescript\n    67|   * const controller = new ChannelController(appProvider, channelManager, metricsHandler);\n    68|   * const response = await controller.handle(request, 'app123', 'my-channel');\n    69|   * ```\n    70|   */\n    71|  async handle(\n    72|    request: Request,\n    73|    appId: string,\n    74|    channel: string,\n    75|  ): Promise<Response> {\n    76|    // Verify the request (authentication, app ID, etc.)\n    77|    await this.verify(request, appId);\n    78|\n    79|    // Parse query parameters\n    80|    const url = new URL(request.url);\n    81|    const infoParam = url.searchParams.get(\"info\");\n    82|\n    83|    // Add 'occupied' to the info fields if not already present\n    84|    const info = infoParam ? `${infoParam},occupied` : \"occupied\";\n    85|\n    86|    if (!this.application) {\n    87|      throw new Error(\"Application not set.\");\n    88|    }\n    89|\n    90|    // Gather channel metrics\n    91|    const channelData = await this.metricsHandler.gather(\n    92|      this.application,\n    93|      \"channel\",\n    94|      {\n    95|        channel,\n    96|        info,\n    97|      },\n    98|    );\n    99|\n   100|    // Return response with channel data\n   101|    return new Response(channelData);\n   102|  }\n   103|\n   104|  /**\n   105|   * Verify that the incoming request is valid.\n   106|   *\n   107|   * This method:\n   108|   * 1. Parses the request query parameters\n   109|   * 2. Reads the request body\n   110|   * 3. Sets the application instance\n   111|   * 4. Sets the channel manager\n   112|   * 5. Verifies the Pusher signature\n   113|   *\n   114|   * @param request - The incoming HTTP request\n   115|   * @param appId - The application ID\n   116|   * @throws {HttpException} If verification fails\n   117|   */\n   ...\n   282|}\n</search_result>\n\n<search_result path=\"src/protocols/pusher/http/controllers/events-controller.ts\" showSignaturesOnly=\"true\" startLine=\"52\" endLine=\"260\">\n   53|export class EventsController extends Controller {\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/channels-controller.ts\" endLine=\"316\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/channels-controller.ts\" showSignaturesOnly=\"true\" startLine=\"22\" endLine=\"316\">\n   23|export class ChannelsController {\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/channel-users-controller.ts\" endLine=\"91\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/channel-users-controller.ts\" startLine=\"74\" endLine=\"126\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/users-terminate-controller.ts\" showSignaturesOnly=\"true\" startLine=\"34\" endLine=\"219\">\n   35|export class UsersTerminateController {\n</search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/health-check-controller.ts\" endLine=\"32\"></search_result>\n<search_result path=\"src/protocols/pusher/http/controllers/events-batch-controller.ts\" showSignaturesOnly=\"true\" startLine=\"70\" endLine=\"280\">\n   71|export class EventsBatchController {\n</search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/connections-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 77,
                    "column": 3
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport { Factory } from \"../../../../servers/reverb/factory\";\nimport type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * Connections Controller\n *\n * Handles GET requests to retrieve connection information for an application.\n *\n * Endpoint: GET /apps/:appId/connections\n *\n * Returns:\n * - 200 with connection count if successful\n *\n * Response Format:\n * {\n *   \"connections\": <number of active connections>\n * }\n *\n * Authentication:\n * - Requires valid Pusher authentication signature\n * - Validates using auth_signature query parameter\n *\n * @example\n * ```typescript\n * // Usage in router\n * router.get('/apps/:appId/connections', connectionsController);\n *\n * // Sample request\n * GET /apps/123456/connections?auth_key=...&auth_signature=...\n * ```\n */\nexport async function connectionsController(\n  request: IHttpRequest,\n  _connection: Connection,\n  appId: string,\n): Promise<Response> {\n  // Verify authentication and set up application/channels\n  const { application } = await verify(request, _connection, appId);\n\n  // Get metrics handler instance\n  const metricsHandler = getMetricsHandler();\n\n  // Gather connections metrics\n  const connections = await metricsHandler.gather(application, \"connections\");\n\n  // Count the connections\n  const connectionCount =\n    typeof connections === \"object\" &&\n    connections !== null &&\n    !Array.isArray(connections)\n      ? Object.keys(connections).length\n      : 0;\n\n  return new Response({ connections: connectionCount });\n}\n\n/**\n * Verify the request authentication and set up application/channels.\n *\n * This function:\n * 1. Parses query parameters\n * 2. Extracts request body\n * 3. Sets the application instance\n * 4. Sets the channel manager\n * 5. Verifies the Pusher authentication signature\n *\n * @param request - The HTTP request object\n * @param connection - The connection object\n * @param appId - The application ID from route parameters\n * @returns Object containing application and channels instances\n * @throws {Error} If authentication fails or application not found\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Factory } from \"../../../../servers/reverb/factory\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * Connections Controller",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles GET requests to retrieve connection information for an application.",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * Endpoint: GET /apps/:appId/connections",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * Returns:",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - 200 with connection count if successful",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * Response Format:",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"connections\": <number of active connections>",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * Authentication:",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " * - Requires valid Pusher authentication signature",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * - Validates using auth_signature query parameter",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " * // Usage in router",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " * router.get('/apps/:appId/connections', connectionsController);",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sample request",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " * GET /apps/123456/connections?auth_key=...&auth_signature=...",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "export async function connectionsController(",
                    "lineNumber": 38,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 39,
                    "isSignature": true
                  },
                  {
                    "text": "  _connection: Connection,",
                    "lineNumber": 40,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 41,
                    "isSignature": true
                  },
                  {
                    "text": "): Promise<Response> {",
                    "lineNumber": 42,
                    "isSignature": true
                  },
                  {
                    "text": "  // Verify authentication and set up application/channels",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  const { application } = await verify(request, _connection, appId);",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  // Get metrics handler instance",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  const metricsHandler = getMetricsHandler();",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "  // Gather connections metrics",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "  const connections = await metricsHandler.gather(application, \"connections\");",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  // Count the connections",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "  const connectionCount =",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    typeof connections === \"object\" &&",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    connections !== null &&",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    !Array.isArray(connections)",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "      ? Object.keys(connections).length",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "      : 0;",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "  return new Response({ connections: connectionCount });",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 61,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " * Verify the request authentication and set up application/channels.",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * This function:",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Parses query parameters",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Extracts request body",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Sets the application instance",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Sets the channel manager",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Verifies the Pusher authentication signature",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " * @param request - The HTTP request object",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " * @param connection - The connection object",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID from route parameters",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Object containing application and channels instances",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If authentication fails or application not found",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 78,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.40785470604896545
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/connections-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 60,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 112,
                    "column": 3
                  }
                },
                "contents": "/**\n * Verify the request authentication and set up application/channels.\n *\n * This function:\n * 1. Parses query parameters\n * 2. Extracts request body\n * 3. Sets the application instance\n * 4. Sets the channel manager\n * 5. Verifies the Pusher authentication signature\n *\n * @param request - The HTTP request object\n * @param connection - The connection object\n * @param appId - The application ID from route parameters\n * @returns Object containing application and channels instances\n * @throws {Error} If authentication fails or application not found\n */\nasync function verify(\n  request: IHttpRequest,\n  _connection: Connection,\n  appId: string,\n): Promise<{ application: Application; channels: ChannelManager }> {\n  // Parse query parameters\n  const path = request.path || request.getPath() || \"\";\n  const url = new URL(path, \"http://localhost\");\n  const query: Record<string, string> = {};\n  url.searchParams.forEach((value, key) => {\n    query[key] = value;\n  });\n\n  // Get request body\n  const body = request.body || \"\";\n\n  // Set application\n  const application = await setApplication(appId);\n\n  // Set channels\n  const channels = getChannelManager();\n\n  // Verify signature\n  verifySignature(request, query, body, application);\n\n  return { application, channels };\n}\n\n/**\n * Set the application instance for the given app ID.\n *\n * @param appId - The application ID\n * @returns The application instance\n * @throws {Error} If application not found\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " * Verify the request authentication and set up application/channels.",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * This function:",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Parses query parameters",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Extracts request body",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Sets the application instance",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Sets the channel manager",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Verifies the Pusher authentication signature",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " * @param request - The HTTP request object",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " * @param connection - The connection object",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID from route parameters",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Object containing application and channels instances",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If authentication fails or application not found",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "async function verify(",
                    "lineNumber": 79,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 80,
                    "isSignature": true
                  },
                  {
                    "text": "  _connection: Connection,",
                    "lineNumber": 81,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 82,
                    "isSignature": true
                  },
                  {
                    "text": "): Promise<{ application: Application; channels: ChannelManager }> {",
                    "lineNumber": 83,
                    "isSignature": true
                  },
                  {
                    "text": "  // Parse query parameters",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "  const path = request.path || request.getPath() || \"\";",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "  const url = new URL(path, \"http://localhost\");",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "  const query: Record<string, string> = {};",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "  url.searchParams.forEach((value, key) => {",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "    query[key] = value;",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "  });",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "  // Get request body",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "  const body = request.body || \"\";",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "  // Set application",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "  const application = await setApplication(appId);",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "  // Set channels",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  const channels = getChannelManager();",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  // Verify signature",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  verifySignature(request, query, body, application);",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "  return { application, channels };",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 105,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": " * Set the application instance for the given app ID.",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns The application instance",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If application not found",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 113,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3815842866897583
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/controller.ts",
                "range": {
                  "startPosition": {
                    "line": 30,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 283,
                    "column": 0
                  }
                },
                "contents": "export \n\n\n  /**\n   * Verify that the incoming request is valid.\n   *\n   * Performs the following validations:\n   * 1. Parses query parameters from the request path\n   * 2. Extracts the request body\n   * 3. Resolves and sets the application instance\n   * 4. Sets up the channel manager for the application\n   * 5. Verifies the HMAC signature\n   *\n   * @param request - The incoming HTTP request\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from the route\n   * @throws {HttpException} If validation fails\n   */\n  async verify(\n    request: IHttpRequest,\n    _connection: Connection,\n    appId: string | null,\n  ): Promise<void> {\n    // Parse query parameters from URL\n    const url = new URL(request.path, \"http://localhost\");\n    const queryParams: Record<string, string> = {};\n    url.searchParams.forEach((value, key) => {\n      queryParams[key] = value;\n    });\n\n    this.body = request.body;\n    this.query = queryParams;\n\n    this.setApplication(appId);\n    this.setChannels();\n    await this.verifySignature(request);\n  }\n\n  /**\n   * Set the application instance for the incoming request's application ID.\n   *\n   * @param appId - The application ID to resolve\n   * @returns The resolved Application instance\n   * @throws {HttpException} 400 if application ID not provided\n   * @throws {HttpException} 404 if no matching application found\n   */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 31,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 31,
                        "column": 8
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export ",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid.",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   * Performs the following validations:",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses query parameters from the request path",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Extracts the request body",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Resolves and sets the application instance",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Sets up the channel manager for the application",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Verifies the HMAC signature",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} If validation fails",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "  async verify(",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "    appId: string | null,",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<void> {",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse query parameters from URL",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(request.path, \"http://localhost\");",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    const queryParams: Record<string, string> = {};",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    url.searchParams.forEach((value, key) => {",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "      queryParams[key] = value;",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    this.body = request.body;",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "    this.query = queryParams;",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setApplication(appId);",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setChannels();",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "    await this.verifySignature(request);",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "   * Set the application instance for the incoming request's application ID.",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID to resolve",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The resolved Application instance",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} 400 if application ID not provided",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} 404 if no matching application found",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 105,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3546355366706848
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/pusher-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 26,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 126,
                    "column": 1
                  }
                },
                "contents": "export class PusherController {\n\n\n  /**\n   * Get the Reverb connection instance for the request.\n   *\n   * Looks up the application by key and creates a new ReverbConnection\n   * with the application context and origin information.\n   *\n   * If the application is not found, sends an error message to the client\n   * and closes the connection.\n   *\n   * @param request - The HTTP request\n   * @param connection - The WebSocket connection wrapper\n   * @param key - The application key\n   * @returns The Reverb connection instance, or null if the application is invalid\n   */\n  protected connection(\n    request: IHttpRequest,\n    connection: Connection,\n    key: string,\n  ): ReverbConnection | null {\n    try {\n      const application = this.applications.findByKey(key);\n\n      return new ReverbConnection(\n        connection,\n        application,\n        request.getHeader(\"Origin\") || null,\n      );\n    } catch (e) {\n      const error = e as Error;\n\n      // Check if it's an InvalidApplication error\n      if (error.name === \"InvalidApplication\") {\n        connection.send(\n          '{\"event\":\"pusher:error\",\"data\":\"{\\\\\"code\\\\\":4001,\\\\\"message\\\\\":\\\\\"Application does not exist\\\\\"}\"}',\n        );\n\n        connection.close();\n        return null;\n      }\n\n      // Re-throw other errors\n      throw error;\n    }\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 27,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 27,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 27,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 28,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class PusherController {",
                    "lineNumber": 27,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the Reverb connection instance for the request.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * Looks up the application by key and creates a new ReverbConnection",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * with the application context and origin information.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * If the application is not found, sends an error message to the client",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * and closes the connection.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The WebSocket connection wrapper",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param key - The application key",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The Reverb connection instance, or null if the application is invalid",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "  protected connection(",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    connection: Connection,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    key: string,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): ReverbConnection | null {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "      const application = this.applications.findByKey(key);",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "      return new ReverbConnection(",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "        connection,",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "        application,",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "        request.getHeader(\"Origin\") || null,",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (e) {",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "      const error = e as Error;",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "      // Check if it's an InvalidApplication error",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "      if (error.name === \"InvalidApplication\") {",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "        connection.send(",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "          '{\"event\":\"pusher:error\",\"data\":\"{\\\\\"code\\\\\":4001,\\\\\"message\\\\\":\\\\\"Application does not exist\\\\\"}\"}',",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "        connection.close();",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "        return null;",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "      // Re-throw other errors",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      throw error;",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 127,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.35078179836273193
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 281,
                    "column": 1
                  }
                },
                "contents": "export class ChannelController {\n\n\n  /**\n   * Handle the incoming request.\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID from the route\n   * @param channel - The channel name from the route\n   * @returns Promise resolving to a Response with channel information\n   *\n   * @example\n   * ```typescript\n   * const controller = new ChannelController(appProvider, channelManager, metricsHandler);\n   * const response = await controller.handle(request, 'app123', 'my-channel');\n   * ```\n   */\n  async handle(\n    request: Request,\n    appId: string,\n    channel: string,\n  ): Promise<Response> {\n    // Verify the request (authentication, app ID, etc.)\n    await this.verify(request, appId);\n\n    // Parse query parameters\n    const url = new URL(request.url);\n    const infoParam = url.searchParams.get(\"info\");\n\n    // Add 'occupied' to the info fields if not already present\n    const info = infoParam ? `${infoParam},occupied` : \"occupied\";\n\n    if (!this.application) {\n      throw new Error(\"Application not set.\");\n    }\n\n    // Gather channel metrics\n    const channelData = await this.metricsHandler.gather(\n      this.application,\n      \"channel\",\n      {\n        channel,\n        info,\n      },\n    );\n\n    // Return response with channel data\n    return new Response(channelData);\n  }\n\n  /**\n   * Verify that the incoming request is valid.\n   *\n   * This method:\n   * 1. Parses the request query parameters\n   * 2. Reads the request body\n   * 3. Sets the application instance\n   * 4. Sets the channel manager\n   * 5. Verifies the Pusher signature\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID\n   * @throws {HttpException} If verification fails\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the incoming request.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channel - The channel name from the route",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to a Response with channel information",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * const controller = new ChannelController(appProvider, channelManager, metricsHandler);",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   * const response = await controller.handle(request, 'app123', 'my-channel');",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    request: Request,",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    appId: string,",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    channel: string,",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    // Verify the request (authentication, app ID, etc.)",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    await this.verify(request, appId);",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse query parameters",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(request.url);",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "    const infoParam = url.searchParams.get(\"info\");",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "    // Add 'occupied' to the info fields if not already present",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    const info = infoParam ? `${infoParam},occupied` : \"occupied\";",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!this.application) {",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error(\"Application not set.\");",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    // Gather channel metrics",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "    const channelData = await this.metricsHandler.gather(",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "      this.application,",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "      \"channel\",",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "        channel,",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "        info,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    // Return response with channel data",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response(channelData);",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses the request query parameters",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Reads the request body",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Sets the application instance",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Sets the channel manager",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Verifies the Pusher signature",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} If verification fails",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 282,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.33699148893356323
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 52,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 260,
                    "column": 1
                  }
                },
                "contents": "export class EventsController extends Controller {\nconstructor(\n    protected override readonly channelManager: ChannelManager,\n    protected readonly metricsHandler: MetricsHandler,\n  ) {\n\n  }\n\n  /**\n   * Handle the request to trigger events.\n   *\n   * Processes the incoming event trigger request:\n   * 1. Parses and validates the request body\n   * 2. Validates required fields (name, data, channels/channel)\n   * 3. Dispatches the event to specified channels\n   * 4. Optionally gathers and returns channel metrics\n   *\n   * @param request - The HTTP request object\n   * @param connection - The connection object\n   * @param application - The application context\n   * @param channelManager - The channel manager scoped to the application\n   * @returns Response with empty object or channel metrics\n   */\n  async __invoke(\n    request: IHttpRequest,\n    _connection: Connection,\n    application: Application,\n    channelManager: ChannelManager,\n  ): Promise<Response> {\n    // Parse the request body\n    const body = this.getBody(request);\n    let payload: EventsPayload;\n\n    try {\n      payload = JSON.parse(body);\n    } catch (_error) {\n      return new Response({ message: \"Invalid JSON payload\" }, 422);\n    }\n\n    // Validate the payload\n    const validator = this.validator(payload);\n\n    if (Object.keys(validator).length > 0) {\n      return new Response(validator, 422);\n    }\n\n    // At this point, validator ensures name and data exist\n    if (!payload.name || !payload.data) {\n      return new Response({ message: \"Invalid payload\" }, 422);\n    }\n\n    // Normalize channels to array\n    const channels = this.normalizeChannels(payload);\n\n    // Get the connection to exclude from broadcast (if socket_id provided)\n    let except: ChannelConnection | null = null;\n    if (payload.socket_id) {\n      const connections = channelManager.connections();\n      except = connections[payload.socket_id] ?? null;\n    }\n\n    // Dispatch the event to all specified channels\n    dispatch(\n      application,\n      {\n        event: payload.name,\n        channels,\n        data: payload.data,\n      },\n      channelManager,\n      except?.connection() ?? null,\n    );\n\n    // If info parameter is provided, gather and return channel metrics\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 53,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 53,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 53,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 54,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsController extends Controller {",
                    "lineNumber": 53,
                    "isSignature": true
                  },
                  {
                    "text": "constructor(",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    protected override readonly channelManager: ChannelManager,",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly metricsHandler: MetricsHandler,",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the request to trigger events.",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   * Processes the incoming event trigger request:",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses and validates the request body",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Validates required fields (name, data, channels/channel)",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Dispatches the event to specified channels",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Optionally gathers and returns channel metrics",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection object",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application context",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channelManager - The channel manager scoped to the application",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response with empty object or channel metrics",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "  async __invoke(",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    channelManager: ChannelManager,",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse the request body",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "    const body = this.getBody(request);",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "    let payload: EventsPayload;",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "    try {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "      payload = JSON.parse(body);",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    } catch (_error) {",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({ message: \"Invalid JSON payload\" }, 422);",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    // Validate the payload",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    const validator = this.validator(payload);",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    if (Object.keys(validator).length > 0) {",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response(validator, 422);",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "    // At this point, validator ensures name and data exist",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!payload.name || !payload.data) {",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({ message: \"Invalid payload\" }, 422);",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "    // Normalize channels to array",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "    const channels = this.normalizeChannels(payload);",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "    // Get the connection to exclude from broadcast (if socket_id provided)",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "    let except: ChannelConnection | null = null;",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "    if (payload.socket_id) {",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "      const connections = channelManager.connections();",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "      except = connections[payload.socket_id] ?? null;",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "    // Dispatch the event to all specified channels",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "    dispatch(",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "      application,",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "      {",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "        event: payload.name,",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "        data: payload.data,",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "      channelManager,",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "      except?.connection() ?? null,",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    // If info parameter is provided, gather and return channel metrics",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 261,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3196764886379242
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 283,
                    "column": 0
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/request\";\nimport { HttpException } from \"../../../../servers/reverb/http/server\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\n\n/**\n * Base Controller for Pusher HTTP API\n *\n * Provides authentication and request validation for Pusher HTTP API controllers.\n * This abstract class handles:\n * - Application resolution and validation\n * - HMAC-SHA256 signature verification\n * - Request body and query parameter parsing\n * - Channel manager setup\n *\n * All HTTP API controllers should extend this class to inherit authentication\n * and validation functionality.\n *\n * @example\n * ```typescript\n * class EventsController extends Controller {\n *   async handle(request: IHttpRequest, connection: Connection, appId: string): Promise<Response> {\n *     await this.verify(request, connection, appId);\n *     // Handle the request...\n *   }\n * }\n * ```\n */\nexport abstract class Controller {\n  /**\n   * Current application instance for the request.\n   */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/request\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { HttpException } from \"../../../../servers/reverb/http/server\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Base Controller for Pusher HTTP API",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides authentication and request validation for Pusher HTTP API controllers.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * This abstract class handles:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - Application resolution and validation",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - HMAC-SHA256 signature verification",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Request body and query parameter parsing",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Channel manager setup",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * All HTTP API controllers should extend this class to inherit authentication",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * and validation functionality.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * class EventsController extends Controller {",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " *   async handle(request: IHttpRequest, connection: Connection, appId: string): Promise<Response> {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " *     await this.verify(request, connection, appId);",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *     // Handle the request...",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "export abstract class Controller {",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   * Current application instance for the request.",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 34,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3085879981517792
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channels-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 316,
                    "column": 1
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport { InvalidApplication } from \"../../../../exceptions/invalid-application\";\nimport type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/request\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * ChannelsController\n *\n * Handles GET /apps/:appId/channels endpoint.\n * Returns list of channels with optional prefix filtering.\n *\n * This controller:\n * - Verifies the request signature\n * - Retrieves channel information using MetricsHandler\n * - Supports optional filter_by_prefix query parameter\n * - Supports optional info query parameter for channel metadata\n * - Returns channels in Pusher-compatible format\n */\nexport class ChannelsController {\n  /**\n   * Current application instance.\n   */\n  protected application: Application | null = null;\n\n  /**\n   * Active channels for the application.\n   */\n  protected channels: ChannelManager | null = null;\n\n  /**\n   * The incoming request's body.\n   */\n  protected body: string | null = null;\n\n  /**\n   * The incoming request's query parameters.\n   */\n  protected query: Record<string, string> = {};\n\n  /**\n   * Create a new ChannelsController instance.\n   *\n   * @param metricsHandler - The metrics handler for gathering channel information\n   * @param applicationProvider - The application provider for finding applications\n   * @param channelManager - The channel manager for accessing channels\n   */\n  constructor(\n    protected metricsHandler: MetricsHandler,\n    protected applicationProvider: IApplicationProvider,\n    protected channelManager: ChannelManager,\n  ) {}\n\n  /**\n   * Handle the request.\n   *\n   * @param request - The HTTP request\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from the route\n   * @returns Promise resolving to the HTTP response\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { InvalidApplication } from \"../../../../exceptions/invalid-application\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/request\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * ChannelsController",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles GET /apps/:appId/channels endpoint.",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Returns list of channels with optional prefix filtering.",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * This controller:",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - Verifies the request signature",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - Retrieves channel information using MetricsHandler",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * - Supports optional filter_by_prefix query parameter",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - Supports optional info query parameter for channel metadata",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - Returns channels in Pusher-compatible format",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "export class ChannelsController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * Current application instance.",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  protected application: Application | null = null;",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Active channels for the application.",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  protected channels: ChannelManager | null = null;",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's body.",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  protected body: string | null = null;",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's query parameters.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  protected query: Record<string, string> = {};",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new ChannelsController instance.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param metricsHandler - The metrics handler for gathering channel information",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applicationProvider - The application provider for finding applications",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channelManager - The channel manager for accessing channels",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    protected metricsHandler: MetricsHandler,",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    protected applicationProvider: IApplicationProvider,",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    protected channelManager: ChannelManager,",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the request.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the HTTP response",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 317,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.30353844165802
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 281,
                    "column": 1
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * ChannelController\n *\n * Handles GET /apps/:appId/channels/:channel endpoint.\n * Returns information about a specific channel including:\n * - occupied: Whether the channel has any connections\n * - user_count: Number of unique users (presence channels only)\n * - subscription_count: Number of subscriptions (non-presence channels)\n * - cache: Cached payload (cache channels only)\n *\n * This controller implements the Pusher HTTP API specification for retrieving\n * channel information. It requires proper authentication via Pusher signature.\n *\n * @example\n * GET /apps/app123/channels/my-channel?info=user_count,subscription_count\n */\nexport class ChannelController {\n  /**\n   * The current application instance\n   */\n  protected application: Application | null = null;\n\n  /**\n   * The active channels for the application\n   */\n  protected channels: ChannelManager | null = null;\n\n  /**\n   * The incoming request's body\n   */\n  protected body: string | null = null;\n\n  /**\n   * The incoming request's query parameters\n   */\n  protected query: Record<string, string> = {};\n\n  /**\n   * Create a new ChannelController instance.\n   *\n   * @param applicationProvider - Provider for application configuration\n   * @param channelManager - Manager for channel operations\n   * @param metricsHandler - Handler for gathering metrics\n   */\n  constructor(\n    protected applicationProvider: IApplicationProvider,\n    protected channelManager: ChannelManager,\n    protected metricsHandler: MetricsHandler,\n  ) {}\n\n  /**\n   * Handle the incoming request.\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID from the route\n   * @param channel - The channel name from the route\n   * @returns Promise resolving to a Response with channel information\n   *\n   * @example\n   * ```typescript\n   * const controller = new ChannelController(appProvider, channelManager, metricsHandler);\n   * const response = await controller.handle(request, 'app123', 'my-channel');\n   * ```\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * ChannelController",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles GET /apps/:appId/channels/:channel endpoint.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * Returns information about a specific channel including:",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * - occupied: Whether the channel has any connections",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - user_count: Number of unique users (presence channels only)",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - subscription_count: Number of subscriptions (non-presence channels)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - cache: Cached payload (cache channels only)",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * This controller implements the Pusher HTTP API specification for retrieving",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * channel information. It requires proper authentication via Pusher signature.",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * GET /apps/app123/channels/my-channel?info=user_count,subscription_count",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "export class ChannelController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * The current application instance",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  protected application: Application | null = null;",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * The active channels for the application",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  protected channels: ChannelManager | null = null;",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's body",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  protected body: string | null = null;",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's query parameters",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  protected query: Record<string, string> = {};",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new ChannelController instance.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applicationProvider - Provider for application configuration",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channelManager - Manager for channel operations",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param metricsHandler - Handler for gathering metrics",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    protected applicationProvider: IApplicationProvider,",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    protected channelManager: ChannelManager,",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    protected metricsHandler: MetricsHandler,",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the incoming request.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channel - The channel name from the route",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to a Response with channel information",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * const controller = new ChannelController(appProvider, channelManager, metricsHandler);",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   * const response = await controller.handle(request, 'app123', 'my-channel');",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 282,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.30327311158180237
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channels-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 316,
                    "column": 1
                  }
                },
                "contents": "export class ChannelsController {\n\n\n  /**\n   * Handle the request.\n   *\n   * @param request - The HTTP request\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from the route\n   * @returns Promise resolving to the HTTP response\n   */\n  async __invoke(\n    request: IHttpRequest,\n    _connection: Connection,\n    appId: string,\n  ): Promise<Response> {\n    this.verify(request, _connection, appId);\n\n    if (!this.application) {\n      throw new Error(\"Application not set.\");\n    }\n\n    const options: Record<string, string> = {};\n    if (this.query.filter_by_prefix) {\n      options.filter = this.query.filter_by_prefix;\n    }\n    if (this.query.info) {\n      options.info = this.query.info;\n    }\n\n    const channels = await this.metricsHandler.gather(\n      this.application,\n      \"channels\",\n      options,\n    );\n\n    // Convert channels object to array format expected by Pusher API\n    if (\n      typeof channels === \"object\" &&\n      channels !== null &&\n      !Array.isArray(channels)\n    ) {\n      return new Response({\n        channels: this.formatChannels(channels as Record<string, unknown>),\n      });\n    }\n    return new Response({ channels: {} });\n  }\n\n  /**\n   * Format channels object into Pusher-compatible response format.\n   *\n   * @param channels - Record of channel names to channel info\n   * @returns Object with channels property containing the formatted data\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelsController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the request.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the HTTP response",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "  async __invoke(",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "    appId: string,",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "    this.verify(request, _connection, appId);",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!this.application) {",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error(\"Application not set.\");",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    const options: Record<string, string> = {};",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.query.filter_by_prefix) {",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "      options.filter = this.query.filter_by_prefix;",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.query.info) {",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "      options.info = this.query.info;",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    const channels = await this.metricsHandler.gather(",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "      this.application,",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "      \"channels\",",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "      options,",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    // Convert channels object to array format expected by Pusher API",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "    if (",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "      typeof channels === \"object\" &&",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "      channels !== null &&",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "      !Array.isArray(channels)",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "    ) {",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "        channels: this.formatChannels(channels as Record<string, unknown>),",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ channels: {} });",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   * Format channels object into Pusher-compatible response format.",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channels - Record of channel names to channel info",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Object with channels property containing the formatted data",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 317,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.30074629187583923
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channels-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 316,
                    "column": 1
                  }
                },
                "contents": "export class ChannelsController {\n\n\n  /**\n   * Parse query parameters from the request path.\n   *\n   * @param path - The request path including query string\n   * @returns Parsed query parameters\n   */\n  protected parseQuery(path: string): Record<string, string> {\n    const queryIndex = path.indexOf(\"?\");\n    if (queryIndex === -1) {\n      return {};\n    }\n\n    const queryString = path.substring(queryIndex + 1);\n    const params: Record<string, string> = {};\n\n    if (!queryString) {\n      return params;\n    }\n\n    const pairs = queryString.split(\"&\");\n    for (const pair of pairs) {\n      const [key, value] = pair.split(\"=\");\n      if (key) {\n        params[decodeURIComponent(key)] = value\n          ? decodeURIComponent(value)\n          : \"\";\n      }\n    }\n\n    return params;\n  }\n\n  /**\n   * Set the Reverb application instance for the incoming request's application ID.\n   *\n   * @param appId - The application ID\n   * @returns The application instance\n   * @throws {Error} Throws 400 if no appId provided, 404 if application not found\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelsController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   * Parse query parameters from the request path.",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param path - The request path including query string",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Parsed query parameters",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "  protected parseQuery(path: string): Record<string, string> {",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "    const queryIndex = path.indexOf(\"?\");",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "    if (queryIndex === -1) {",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return {};",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "    const queryString = path.substring(queryIndex + 1);",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "    const params: Record<string, string> = {};",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!queryString) {",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "      return params;",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "    const pairs = queryString.split(\"&\");",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const pair of pairs) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      const [key, value] = pair.split(\"=\");",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      if (key) {",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "        params[decodeURIComponent(key)] = value",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "          ? decodeURIComponent(value)",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "          : \"\";",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return params;",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Set the Reverb application instance for the incoming request's application ID.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The application instance",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} Throws 400 if no appId provided, 404 if application not found",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 317,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2974083125591278
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/pusher-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 26,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 126,
                    "column": 1
                  }
                },
                "contents": "export class PusherController {\n\n\n  /**\n   * Invoke the Reverb WebSocket server.\n   *\n   * Handles the initialization of a WebSocket connection for the Pusher protocol.\n   * This method:\n   * 1. Validates the connection and looks up the application\n   * 2. Configures the connection with the application's max message size\n   * 3. Registers event handlers for messages, control frames, and close events\n   * 4. Opens the connection buffer to begin receiving frames\n   * 5. Notifies the server to open the connection\n   *\n   * @param request - The HTTP request that initiated the WebSocket upgrade\n   * @param connection - The WebSocket connection wrapper\n   * @param appKey - The application key from the request path\n   */\n  __invoke(\n    request: IHttpRequest,\n    connection: Connection,\n    appKey: string,\n  ): void {\n    const reverbConnection = this.connection(request, connection, appKey);\n\n    if (!reverbConnection) {\n      return;\n    }\n\n    connection.withMaxMessageSize(reverbConnection.app().maxMessageSize());\n\n    connection.onMessage((message: string | Buffer) =>\n      this.server.message(reverbConnection, String(message)),\n    );\n\n    connection.onControl((message: Frame) =>\n      this.server.control(reverbConnection, message),\n    );\n\n    connection.onClose(() => this.server.close(reverbConnection));\n\n    // Note: openBuffer() is not needed in TypeScript implementation\n    // as Bun's WebSocket handles buffering automatically\n\n    this.server.open(reverbConnection);\n  }\n\n  /**\n   * Get the Reverb connection instance for the request.\n   *\n   * Looks up the application by key and creates a new ReverbConnection\n   * with the application context and origin information.\n   *\n   * If the application is not found, sends an error message to the client\n   * and closes the connection.\n   *\n   * @param request - The HTTP request\n   * @param connection - The WebSocket connection wrapper\n   * @param key - The application key\n   * @returns The Reverb connection instance, or null if the application is invalid\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 27,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 27,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 27,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 28,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class PusherController {",
                    "lineNumber": 27,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * Invoke the Reverb WebSocket server.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handles the initialization of a WebSocket connection for the Pusher protocol.",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Validates the connection and looks up the application",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Configures the connection with the application's max message size",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Registers event handlers for messages, control frames, and close events",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Opens the connection buffer to begin receiving frames",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Notifies the server to open the connection",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request that initiated the WebSocket upgrade",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The WebSocket connection wrapper",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appKey - The application key from the request path",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  __invoke(",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    connection: Connection,",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    appKey: string,",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "  ): void {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "    const reverbConnection = this.connection(request, connection, appKey);",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!reverbConnection) {",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "      return;",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    connection.withMaxMessageSize(reverbConnection.app().maxMessageSize());",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "    connection.onMessage((message: string | Buffer) =>",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "      this.server.message(reverbConnection, String(message)),",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    connection.onControl((message: Frame) =>",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "      this.server.control(reverbConnection, message),",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "    connection.onClose(() => this.server.close(reverbConnection));",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    // Note: openBuffer() is not needed in TypeScript implementation",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "    // as Bun's WebSocket handles buffering automatically",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    this.server.open(reverbConnection);",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the Reverb connection instance for the request.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * Looks up the application by key and creates a new ReverbConnection",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * with the application context and origin information.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * If the application is not found, sends an error message to the client",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   * and closes the connection.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The WebSocket connection wrapper",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param key - The application key",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The Reverb connection instance, or null if the application is invalid",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 127,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.288571834564209
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-users-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 59
                  },
                  "endPosition": {
                    "line": 91,
                    "column": 3
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport { Factory } from \"../../../../servers/reverb/factory\";\nimport type { Connection } from \"../../../../servers/reverb/http/connection\";\nimport { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport { isPresenceChannel } from \"../../concerns/interacts-with-channel-information\";\nimport type { ChannelManager } from \"../../contracts/channel-manager\";\nimport type { MetricsHandler } from \"../../metrics-handler\";\n\n/**\n * Channel Users Controller\n *\n * Handles GET requests to retrieve the list of users in a presence channel.\n *\n * Endpoint: GET /apps/:appId/channels/:channel/users\n *\n * Returns:\n * - 404 if channel doesn't exist\n * - 400 if channel is not a presence channel\n * - 200 with list of users if successful\n *\n * Response Format:\n * {\n *   \"users\": [\n *     { \"id\": \"user_id_1\" },\n *     { \"id\": \"user_id_2\" },\n *     ...\n *   ]\n * }\n *\n * Authentication:\n * - Requires valid Pusher authentication signature\n * - Validates using auth_signature query parameter\n *\n * @example\n * ```typescript\n * // Usage in router\n * router.get('/apps/:appId/channels/:channel/users', channelUsersController);\n *\n * // Sample request\n * GET /apps/123456/channels/presence-chat/users?auth_key=...&auth_signature=...\n * ```\n */\nexport async function channelUsersController(\n  request: IHttpRequest,\n  _connection: Connection,\n  channel: string,\n  appId: string,\n): Promise<Response> {\n  // Verify authentication and set up application/channels\n  const { application, channels } = await verify(request, _connection, appId);\n\n  // Find the channel\n  const channelInstance = channels.for(application).find(channel);\n\n  if (!channelInstance) {\n    return new Response({}, 404);\n  }\n\n  // Check if it's a presence channel\n  if (!isPresenceChannel(channelInstance)) {\n    return new Response({}, 400);\n  }\n\n  // Get metrics handler instance\n  const metricsHandler = getMetricsHandler();\n\n  // Gather channel users metrics\n  const users = await metricsHandler.gather(application, \"channel_users\", {\n    channel: channel,\n  });\n\n  return new Response({ users });\n}\n\n/**\n * Verify the request authentication and set up application/channels.\n *\n * This function:\n * 1. Parses query parameters\n * 2. Extracts request body\n * 3. Sets the application instance\n * 4. Sets the channel manager\n * 5. Verifies the Pusher authentication signature\n *\n * @param request - The HTTP request object\n * @param connection - The connection object\n * @param appId - The application ID from route parameters\n * @returns Object containing application and channels instances\n * @throws {Error} If authentication fails or application not found\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { Factory } from \"../../../../servers/reverb/factory\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/http/connection\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "import { isPresenceChannel } from \"../../concerns/interacts-with-channel-information\";",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "import type { ChannelManager } from \"../../contracts/channel-manager\";",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "import type { MetricsHandler } from \"../../metrics-handler\";",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * Channel Users Controller",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Handles GET requests to retrieve the list of users in a presence channel.",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * Endpoint: GET /apps/:appId/channels/:channel/users",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * Returns:",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * - 404 if channel doesn't exist",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - 400 if channel is not a presence channel",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - 200 with list of users if successful",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * Response Format:",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " *   \"users\": [",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"id\": \"user_id_1\" },",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " *     { \"id\": \"user_id_2\" },",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " *     ...",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " *   ]",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": " * Authentication:",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": " * - Requires valid Pusher authentication signature",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * - Validates using auth_signature query parameter",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " * // Usage in router",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " * router.get('/apps/:appId/channels/:channel/users', channelUsersController);",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sample request",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * GET /apps/123456/channels/presence-chat/users?auth_key=...&auth_signature=...",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "export async function channelUsersController(",
                    "lineNumber": 45,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 46,
                    "isSignature": true
                  },
                  {
                    "text": "  _connection: Connection,",
                    "lineNumber": 47,
                    "isSignature": true
                  },
                  {
                    "text": "  channel: string,",
                    "lineNumber": 48,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 49,
                    "isSignature": true
                  },
                  {
                    "text": "): Promise<Response> {",
                    "lineNumber": 50,
                    "isSignature": true
                  },
                  {
                    "text": "  // Verify authentication and set up application/channels",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  const { application, channels } = await verify(request, _connection, appId);",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  // Find the channel",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "  const channelInstance = channels.for(application).find(channel);",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "  if (!channelInstance) {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({}, 404);",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "  // Check if it's a presence channel",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "  if (!isPresenceChannel(channelInstance)) {",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({}, 400);",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "  // Get metrics handler instance",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "  const metricsHandler = getMetricsHandler();",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "  // Gather channel users metrics",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "  const users = await metricsHandler.gather(application, \"channel_users\", {",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    channel: channel,",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "  });",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "  return new Response({ users });",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 75,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " * Verify the request authentication and set up application/channels.",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": " * This function:",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Parses query parameters",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Extracts request body",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Sets the application instance",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Sets the channel manager",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Verifies the Pusher authentication signature",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": " * @param request - The HTTP request object",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": " * @param connection - The connection object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID from route parameters",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Object containing application and channels instances",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If authentication fails or application not found",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 92,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2880763113498688
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-users-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 74,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 126,
                    "column": 3
                  }
                },
                "contents": "/**\n * Verify the request authentication and set up application/channels.\n *\n * This function:\n * 1. Parses query parameters\n * 2. Extracts request body\n * 3. Sets the application instance\n * 4. Sets the channel manager\n * 5. Verifies the Pusher authentication signature\n *\n * @param request - The HTTP request object\n * @param connection - The connection object\n * @param appId - The application ID from route parameters\n * @returns Object containing application and channels instances\n * @throws {Error} If authentication fails or application not found\n */\nasync function verify(\n  request: IHttpRequest,\n  _connection: Connection,\n  appId: string,\n): Promise<{ application: Application; channels: ChannelManager }> {\n  // Parse query parameters\n  const path = request.path || request.getPath() || \"\";\n  const url = new URL(path, \"http://localhost\");\n  const query: Record<string, string> = {};\n  url.searchParams.forEach((value, key) => {\n    query[key] = value;\n  });\n\n  // Get request body\n  const body = request.body || \"\";\n\n  // Set application\n  const application = await setApplication(appId);\n\n  // Set channels\n  const channels = getChannelManager();\n\n  // Verify signature\n  verifySignature(request, query, body, application);\n\n  return { application, channels };\n}\n\n/**\n * Set the application instance for the given app ID.\n *\n * @param appId - The application ID\n * @returns The application instance\n * @throws {Error} If application not found\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " * Verify the request authentication and set up application/channels.",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": " * This function:",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Parses query parameters",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Extracts request body",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. Sets the application instance",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Sets the channel manager",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Verifies the Pusher authentication signature",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": " * @param request - The HTTP request object",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": " * @param connection - The connection object",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID from route parameters",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Object containing application and channels instances",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If authentication fails or application not found",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "async function verify(",
                    "lineNumber": 93,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 94,
                    "isSignature": true
                  },
                  {
                    "text": "  _connection: Connection,",
                    "lineNumber": 95,
                    "isSignature": true
                  },
                  {
                    "text": "  appId: string,",
                    "lineNumber": 96,
                    "isSignature": true
                  },
                  {
                    "text": "): Promise<{ application: Application; channels: ChannelManager }> {",
                    "lineNumber": 97,
                    "isSignature": true
                  },
                  {
                    "text": "  // Parse query parameters",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  const path = request.path || request.getPath() || \"\";",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "  const url = new URL(path, \"http://localhost\");",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  const query: Record<string, string> = {};",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  url.searchParams.forEach((value, key) => {",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "    query[key] = value;",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "  });",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "  // Get request body",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "  const body = request.body || \"\";",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "  // Set application",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "  const application = await setApplication(appId);",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "  // Set channels",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "  const channels = getChannelManager();",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "  // Verify signature",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "  verifySignature(request, query, body, application);",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "  return { application, channels };",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 119,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": " * Set the application instance for the given app ID.",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": " * @param appId - The application ID",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns The application instance",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If application not found",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 127,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.28534549474716187
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/connections-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 125,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 202,
                    "column": 3
                  }
                },
                "contents": "/**\n * Verify the Pusher authentication signature.\n *\n * @param request - The HTTP request object\n * @param query - The parsed query parameters\n * @param body - The request body\n * @param application - The application instance\n * @throws {Error} If signature is invalid\n */\nfunction verifySignature(\n  request: IHttpRequest,\n  query: Record<string, string>,\n  body: string,\n  application: Application,\n): void {\n  const crypto = require(\"node:crypto\");\n\n  // Prepare params for signature (exclude auth_signature and internal params)\n  const params: Record<string, string> = {};\n  for (const [key, value] of Object.entries(query)) {\n    if (\n      ![\n        \"auth_signature\",\n        \"body_md5\",\n        \"appId\",\n        \"appKey\",\n        \"channelName\",\n      ].includes(key)\n    ) {\n      params[key] = value;\n    }\n  }\n\n  // Add body_md5 if body is not empty\n  if (body !== \"\") {\n    params.body_md5 = crypto.createHash(\"md5\").update(body).digest(\"hex\");\n  }\n\n  // Sort params by key\n  const sortedKeys = Object.keys(params).sort();\n  const sortedParams: Record<string, string> = {};\n  for (const key of sortedKeys) {\n    sortedParams[key] = params[key] ?? \"\";\n  }\n\n  // Format params for verification\n  const queryString = formatQueryParametersForVerification(sortedParams);\n\n  // Build signature string\n  const method = request.method || request.getMethod() || \"GET\";\n  const requestPath = request.path || request.getPath() || \"/\";\n  const path = requestPath.includes(\"?\")\n    ? requestPath.substring(0, requestPath.indexOf(\"?\"))\n    : requestPath;\n\n  const signatureString = [method, path, queryString].join(\"\\n\");\n\n  // Generate signature\n  const signature = crypto\n    .createHmac(\"sha256\", application.secret())\n    .update(signatureString)\n    .digest(\"hex\");\n\n  const authSignature = query.auth_signature || \"\";\n\n  if (signature !== authSignature) {\n    throw new Error(\"Authentication signature invalid.\");\n  }\n}\n\n/**\n * Format query parameters for signature verification.\n *\n * @param params - The parameters to format\n * @returns Formatted query string\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": " * Verify the Pusher authentication signature.",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": " * @param request - The HTTP request object",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": " * @param query - The parsed query parameters",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": " * @param body - The request body",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": " * @param application - The application instance",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": " * @throws {Error} If signature is invalid",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "function verifySignature(",
                    "lineNumber": 137,
                    "isSignature": true
                  },
                  {
                    "text": "  request: IHttpRequest,",
                    "lineNumber": 138,
                    "isSignature": true
                  },
                  {
                    "text": "  query: Record<string, string>,",
                    "lineNumber": 139,
                    "isSignature": true
                  },
                  {
                    "text": "  body: string,",
                    "lineNumber": 140,
                    "isSignature": true
                  },
                  {
                    "text": "  application: Application,",
                    "lineNumber": 141,
                    "isSignature": true
                  },
                  {
                    "text": "): void {",
                    "lineNumber": 142,
                    "isSignature": true
                  },
                  {
                    "text": "  const crypto = require(\"node:crypto\");",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "  // Prepare params for signature (exclude auth_signature and internal params)",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "  const params: Record<string, string> = {};",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "  for (const [key, value] of Object.entries(query)) {",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "    if (",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      ![",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "        \"auth_signature\",",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "        \"body_md5\",",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "        \"appId\",",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "        \"appKey\",",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "        \"channelName\",",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "      ].includes(key)",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "    ) {",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "      params[key] = value;",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "  // Add body_md5 if body is not empty",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "  if (body !== \"\") {",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    params.body_md5 = crypto.createHash(\"md5\").update(body).digest(\"hex\");",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "  // Sort params by key",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "  const sortedKeys = Object.keys(params).sort();",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "  const sortedParams: Record<string, string> = {};",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "  for (const key of sortedKeys) {",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "    sortedParams[key] = params[key] ?? \"\";",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  // Format params for verification",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "  const queryString = formatQueryParametersForVerification(sortedParams);",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "  // Build signature string",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "  const method = request.method || request.getMethod() || \"GET\";",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "  const requestPath = request.path || request.getPath() || \"/\";",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "  const path = requestPath.includes(\"?\")",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "    ? requestPath.substring(0, requestPath.indexOf(\"?\"))",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "    : requestPath;",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "  const signatureString = [method, path, queryString].join(\"\\n\");",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "  // Generate signature",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "  const signature = crypto",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "    .createHmac(\"sha256\", application.secret())",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    .update(signatureString)",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "    .digest(\"hex\");",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "  const authSignature = query.auth_signature || \"\";",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "  if (signature !== authSignature) {",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "    throw new Error(\"Authentication signature invalid.\");",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 196,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": " * Format query parameters for signature verification.",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": " * @param params - The parameters to format",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Formatted query string",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 203,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2806439995765686
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/users-terminate-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 34,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 219,
                    "column": 1
                  }
                },
                "contents": "export class UsersTerminateController {\n\n\n  /**\n   * Handle the user connection termination request.\n   *\n   * Validates the request, finds the application, and either publishes a\n   * terminate message (in distributed setup) or directly disconnects the\n   * user's connections (in standalone setup).\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID\n   * @param userId - The user ID whose connections should be terminated\n   * @returns Promise resolving to a Response with empty JSON object\n   * @throws {Error} If authentication fails or application is not found\n   */\n  async handle(\n    request: Request,\n    appId: string,\n    userId: string,\n  ): Promise<Response> {\n    // Verify the request is authenticated and get the application\n    const application = await this.verify(request, appId);\n\n    // Check if we're in a distributed environment with pub/sub\n    if (this.serverProvider.subscribesToEvents() && this.pubSubProvider) {\n      // Publish terminate message to all servers\n      await this.pubSubProvider.publish({\n        type: \"terminate\",\n        application: application.toArray(),\n        payload: { user_id: userId },\n      });\n\n      return new Response({}, 200, { \"Content-Type\": \"application/json\" });\n    }\n\n    // Standalone mode: directly disconnect connections on this server\n    const channels = this.channelManager.for(application);\n    const connections = Object.values(channels.connections());\n\n    // Disconnect all connections belonging to this user\n    for (const connection of connections) {\n      const userData = connection.data() as Map<string, unknown>;\n      const connectionUserId = userData.get(\"user_id\");\n\n      // Compare as strings to handle both string and number user IDs\n      if (String(connectionUserId) === userId) {\n        connection.connection().disconnect();\n      }\n    }\n\n    return new Response({}, 200, { \"Content-Type\": \"application/json\" });\n  }\n\n  /**\n   * Verify that the incoming request is valid and authenticated.\n   *\n   * Validates the request signature and finds the application.\n   * This should implement the same authentication logic as other\n   * Pusher HTTP API endpoints (HMAC signature verification).\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID to verify against\n   * @returns Promise resolving to the Application instance\n   * @throws {Error} If authentication fails or application is not found\n   *\n   * @private\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 35,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 35,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 35,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 36,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class UsersTerminateController {",
                    "lineNumber": 35,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the user connection termination request.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates the request, finds the application, and either publishes a",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * terminate message (in distributed setup) or directly disconnects the",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   * user's connections (in standalone setup).",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param userId - The user ID whose connections should be terminated",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to a Response with empty JSON object",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} If authentication fails or application is not found",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "  async handle(",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    request: Request,",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "    appId: string,",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "    userId: string,",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    // Verify the request is authenticated and get the application",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "    const application = await this.verify(request, appId);",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if we're in a distributed environment with pub/sub",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.serverProvider.subscribesToEvents() && this.pubSubProvider) {",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "      // Publish terminate message to all servers",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "      await this.pubSubProvider.publish({",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "        type: \"terminate\",",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "        application: application.toArray(),",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "        payload: { user_id: userId },",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({}, 200, { \"Content-Type\": \"application/json\" });",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    // Standalone mode: directly disconnect connections on this server",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    const channels = this.channelManager.for(application);",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    const connections = Object.values(channels.connections());",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    // Disconnect all connections belonging to this user",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const connection of connections) {",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "      const userData = connection.data() as Map<string, unknown>;",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "      const connectionUserId = userData.get(\"user_id\");",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "      // Compare as strings to handle both string and number user IDs",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "      if (String(connectionUserId) === userId) {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "        connection.connection().disconnect();",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({}, 200, { \"Content-Type\": \"application/json\" });",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid and authenticated.",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates the request signature and finds the application.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * This should implement the same authentication logic as other",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * Pusher HTTP API endpoints (HMAC signature verification).",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID to verify against",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Promise resolving to the Application instance",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} If authentication fails or application is not found",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 220,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2781623601913452
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/controller.ts",
                "range": {
                  "startPosition": {
                    "line": 29,
                    "column": 3
                  },
                  "endPosition": {
                    "line": 283,
                    "column": 0
                  }
                },
                "contents": "export abstract class Controller {\n  /**\n   * Current application instance for the request.\n   */\n  protected application: Application | null = null;\n\n  /**\n   * Active channels for the application.\n   */\n  protected channels: ChannelManager | null = null;\n\n  /**\n   * The incoming request's body.\n   */\n  protected body: string | null = null;\n\n  /**\n   * The incoming request's query parameters.\n   */\n  protected query: Record<string, string> = {};\n\n  /**\n   * Create a new controller instance.\n   *\n   * @param applicationProvider - The application provider for resolving applications\n   * @param channelManager - The channel manager for accessing channels\n   */\n  constructor(\n    protected readonly applicationProvider: IApplicationProvider | null,\n    protected readonly channelManager: ChannelManager,\n  ) {}\n\n  /**\n   * Verify that the incoming request is valid.\n   *\n   * Performs the following validations:\n   * 1. Parses query parameters from the request path\n   * 2. Extracts the request body\n   * 3. Resolves and sets the application instance\n   * 4. Sets up the channel manager for the application\n   * 5. Verifies the HMAC signature\n   *\n   * @param request - The incoming HTTP request\n   * @param connection - The HTTP connection\n   * @param appId - The application ID from the route\n   * @throws {HttpException} If validation fails\n   */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 31,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 31,
                        "column": 8
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export abstract class Controller {",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   * Current application instance for the request.",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "  protected application: Application | null = null;",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   * Active channels for the application.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "  protected channels: ChannelManager | null = null;",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's body.",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "  protected body: string | null = null;",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * The incoming request's query parameters.",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "  protected query: Record<string, string> = {};",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new controller instance.",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applicationProvider - The application provider for resolving applications",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param channelManager - The channel manager for accessing channels",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly applicationProvider: IApplicationProvider | null,",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly channelManager: ChannelManager,",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid.",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "   * Performs the following validations:",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses query parameters from the request path",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Extracts the request body",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Resolves and sets the application instance",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Sets up the channel manager for the application",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Verifies the HMAC signature",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID from the route",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} If validation fails",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 77,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.26928746700286865
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/pusher-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 72
                  },
                  "endPosition": {
                    "line": 126,
                    "column": 1
                  }
                },
                "contents": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";\nimport type { Frame } from \"../../../../contracts/websocket-connection\";\nimport type { Connection } from \"../../../../servers/reverb/connection\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/request\";\nimport type { Server as PusherServer } from \"../../server\";\n\n/**\n * Pusher Controller\n *\n * Base controller for handling Pusher WebSocket connections.\n * Provides the core functionality for:\n * - Connection validation and initialization\n * - Application lookup and verification\n * - Event handler registration (message, control, close)\n * - WebSocket lifecycle management\n *\n * This controller acts as the entry point for Pusher protocol WebSocket\n * connections, delegating specific protocol operations to the PusherServer.\n *\n * @example\n * ```typescript\n * const controller = new PusherController(pusherServer, applications);\n * await controller.__invoke(request, connection, appKey);\n * ```\n */\nexport class PusherController {\n  /**\n   * Create a new controller instance.\n   *\n   * @param server - The Pusher protocol server instance\n   * @param applications - The application provider for looking up app configurations\n   */\n  constructor(\n    protected readonly server: PusherServer,\n    protected readonly applications: IApplicationProvider,\n  ) {}\n\n  /**\n   * Invoke the Reverb WebSocket server.\n   *\n   * Handles the initialization of a WebSocket connection for the Pusher protocol.\n   * This method:\n   * 1. Validates the connection and looks up the application\n   * 2. Configures the connection with the application's max message size\n   * 3. Registers event handlers for messages, control frames, and close events\n   * 4. Opens the connection buffer to begin receiving frames\n   * 5. Notifies the server to open the connection\n   *\n   * @param request - The HTTP request that initiated the WebSocket upgrade\n   * @param connection - The WebSocket connection wrapper\n   * @param appKey - The application key from the request path\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { IApplicationProvider } from \"../../../../contracts/application-provider\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Frame } from \"../../../../contracts/websocket-connection\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Connection } from \"../../../../servers/reverb/connection\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/request\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "import type { Server as PusherServer } from \"../../server\";",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Pusher Controller",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * Base controller for handling Pusher WebSocket connections.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides the core functionality for:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection validation and initialization",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Application lookup and verification",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Event handler registration (message, control, close)",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - WebSocket lifecycle management",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * This controller acts as the entry point for Pusher protocol WebSocket",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * connections, delegating specific protocol operations to the PusherServer.",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * const controller = new PusherController(pusherServer, applications);",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * await controller.__invoke(request, connection, appKey);",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "export class PusherController {",
                    "lineNumber": 27,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new controller instance.",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param server - The Pusher protocol server instance",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param applications - The application provider for looking up app configurations",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly server: PusherServer,",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly applications: IApplicationProvider,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {}",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * Invoke the Reverb WebSocket server.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handles the initialization of a WebSocket connection for the Pusher protocol.",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Validates the connection and looks up the application",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Configures the connection with the application's max message size",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Registers event handlers for messages, control frames, and close events",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Opens the connection buffer to begin receiving frames",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Notifies the server to open the connection",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request that initiated the WebSocket upgrade",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The WebSocket connection wrapper",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appKey - The application key from the request path",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 127,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.25905290246009827
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 281,
                    "column": 1
                  }
                },
                "contents": "export class ChannelController {\nasync handle(\n    request: Request,\n    appId: string,\n    channel: string,\n  ): Promise<Response> {\n\n  }\n\n  /**\n   * Verify that the incoming request is valid.\n   *\n   * This method:\n   * 1. Parses the request query parameters\n   * 2. Reads the request body\n   * 3. Sets the application instance\n   * 4. Sets the channel manager\n   * 5. Verifies the Pusher signature\n   *\n   * @param request - The incoming HTTP request\n   * @param appId - The application ID\n   * @throws {HttpException} If verification fails\n   */\n  protected async verify(request: Request, appId: string): Promise<void> {\n    // Parse query parameters\n    const url = new URL(request.url);\n    this.query = {};\n    url.searchParams.forEach((value, key) => {\n      this.query[key] = value;\n    });\n\n    // Read request body\n    this.body = await request.text();\n\n    // Set application and channels\n    this.setApplication(appId);\n    this.setChannels();\n\n    // Verify signature\n    this.verifySignature(request);\n  }\n\n  /**\n   * Set the Reverb application instance for the incoming request's application ID.\n   *\n   * @param appId - The application ID\n   * @throws {Error} If application ID is not provided or application not found\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    request: Request,",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    appId: string,",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    channel: string,",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method:",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. Parses the request query parameters",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Reads the request body",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Sets the application instance",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Sets the channel manager",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   * 5. Verifies the Pusher signature",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} If verification fails",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "  protected async verify(request: Request, appId: string): Promise<void> {",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "    // Parse query parameters",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(request.url);",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "    this.query = {};",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "    url.searchParams.forEach((value, key) => {",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "      this.query[key] = value;",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "    // Read request body",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    this.body = await request.text();",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "    // Set application and channels",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setApplication(appId);",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setChannels();",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "    // Verify signature",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "    this.verifySignature(request);",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "   * Set the Reverb application instance for the incoming request's application ID.",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} If application ID is not provided or application not found",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 282,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.25787246227264404
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/health-check-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 77
                  },
                  "endPosition": {
                    "line": 32,
                    "column": 1
                  }
                },
                "contents": "import { Response } from \"../../../../servers/reverb/http/response\";\nimport type { IHttpRequest } from \"../../../../servers/reverb/http/router\";\nimport { Controller } from \"./controller\";\n\n/**\n * Health Check Controller\n *\n * Simple health check endpoint that returns 200 OK.\n * This endpoint is used for monitoring and load balancer health checks.\n *\n * @example\n * ```typescript\n * const controller = new HealthCheckController();\n * const response = controller.__invoke(request, connection);\n * // Returns: Response with {health: 'OK'}\n * ```\n */\nexport class HealthCheckController extends Controller {\n  /**\n   * Handle the health check request.\n   *\n   * Returns a simple JSON response indicating the server is healthy\n   * and able to accept requests.\n   *\n   * @param request - The HTTP request object\n   * @param connection - The connection object\n   * @returns Response with health status\n   */\n  __invoke(_request: IHttpRequest, _connection: Connection): Response {\n    return new Response({ health: \"OK\" });\n  }\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import { Response } from \"../../../../servers/reverb/http/response\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import type { IHttpRequest } from \"../../../../servers/reverb/http/router\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import { Controller } from \"./controller\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * Health Check Controller",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Simple health check endpoint that returns 200 OK.",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * This endpoint is used for monitoring and load balancer health checks.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * const controller = new HealthCheckController();",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * const response = controller.__invoke(request, connection);",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * // Returns: Response with {health: 'OK'}",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "export class HealthCheckController extends Controller {",
                    "lineNumber": 19,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handle the health check request.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns a simple JSON response indicating the server is healthy",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "   * and able to accept requests.",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request object",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The connection object",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Response with health status",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  __invoke(_request: IHttpRequest, _connection: Connection): Response {",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ health: \"OK\" });",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 33,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.248299703001976
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/controller.ts",
                "range": {
                  "startPosition": {
                    "line": 30,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 283,
                    "column": 0
                  }
                },
                "contents": "export \n\n\n  /**\n   * Verify the Pusher authentication signature using HMAC-SHA256.\n   *\n   * Validates that the request was signed with the correct application secret\n   * by comparing the provided auth_signature against a computed signature.\n   *\n   * The signature is computed over:\n   * 1. HTTP method (e.g., POST)\n   * 2. Request path\n   * 3. Sorted query parameters (excluding auth_signature and internal params)\n   * 4. Body MD5 hash (if body is present)\n   *\n   * @param request - The incoming HTTP request\n   * @throws {HttpException} 401 if signature is invalid or missing\n   */\n  protected async verifySignature(request: IHttpRequest): Promise<void> {\n    if (!this.application) {\n      throw new HttpException(500, \"Application not set.\");\n    }\n\n    // Build parameters for signature, excluding internal and signature params\n    const params: Record<string, string> = { ...this.query };\n    delete params.auth_signature;\n    delete params.body_md5;\n    delete params.appId;\n    delete params.appKey;\n    delete params.channelName;\n\n    // Add body MD5 if body exists\n    if (this.body && this.body !== \"\") {\n      params.body_md5 = await this.md5(this.body);\n    }\n\n    // Sort parameters by key\n    const sortedKeys = Object.keys(params).sort();\n    const sortedParams: Record<string, string> = {};\n    for (const key of sortedKeys) {\n      sortedParams[key] = params[key] ?? \"\";\n    }\n\n    // Build signature string\n    const url = new URL(request.path, \"http://localhost\");\n    const signatureString = [\n      request.method,\n      url.pathname,\n      this.formatQueryParametersForVerification(sortedParams),\n    ].join(\"\\n\");\n\n    // Compute HMAC-SHA256 signature\n    const signature = await this.hmacSha256(\n      signatureString,\n      this.application.secret(),\n    );\n    const authSignature = this.query.auth_signature ?? \"\";\n\n    if (signature !== authSignature) {\n      throw new HttpException(401, \"Authentication signature invalid.\");\n    }\n  }\n\n  /**\n   * Format query parameters for signature verification.\n   *\n   * Converts a parameters object into a query string format (key=value&key=value).\n   * Arrays are converted to comma-separated strings.\n   *\n   * @param params - The parameters to format\n   * @returns Formatted query string\n   */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 31,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 31,
                        "column": 8
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export ",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify the Pusher authentication signature using HMAC-SHA256.",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates that the request was signed with the correct application secret",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "   * by comparing the provided auth_signature against a computed signature.",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   * The signature is computed over:",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. HTTP method (e.g., POST)",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Request path",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Sorted query parameters (excluding auth_signature and internal params)",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Body MD5 hash (if body is present)",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {HttpException} 401 if signature is invalid or missing",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "  protected async verifySignature(request: IHttpRequest): Promise<void> {",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!this.application) {",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new HttpException(500, \"Application not set.\");",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "    // Build parameters for signature, excluding internal and signature params",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    const params: Record<string, string> = { ...this.query };",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    delete params.auth_signature;",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "    delete params.body_md5;",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    delete params.appId;",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "    delete params.appKey;",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "    delete params.channelName;",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "    // Add body MD5 if body exists",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.body && this.body !== \"\") {",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "      params.body_md5 = await this.md5(this.body);",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    // Sort parameters by key",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "    const sortedKeys = Object.keys(params).sort();",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "    const sortedParams: Record<string, string> = {};",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const key of sortedKeys) {",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "      sortedParams[key] = params[key] ?? \"\";",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "    // Build signature string",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(request.path, \"http://localhost\");",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "    const signatureString = [",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "      request.method,",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "      url.pathname,",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "      this.formatQueryParametersForVerification(sortedParams),",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "    ].join(\"\\n\");",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "    // Compute HMAC-SHA256 signature",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "    const signature = await this.hmacSha256(",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "      signatureString,",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "      this.application.secret(),",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "    const authSignature = this.query.auth_signature ?? \"\";",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "    if (signature !== authSignature) {",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new HttpException(401, \"Authentication signature invalid.\");",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "   * Format query parameters for signature verification.",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "   * Converts a parameters object into a query string format (key=value&key=value).",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "   * Arrays are converted to comma-separated strings.",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param params - The parameters to format",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Formatted query string",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 207,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.228077232837677
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/events-batch-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 70,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 280,
                    "column": 1
                  }
                },
                "contents": "export class EventsBatchController {\nasync handle(\n    request: IHttpRequest,\n    _connection: Connection,\n    _appId: string,\n    application: Application,\n    channels: ChannelManager,\n  ): Promise<Response> {\nconst ;\n    const batch = typedPayload.batch;\n\n    // Process each batch item\n    const items = batch.map((item) => {\n      // Dispatch the event\n      const channelConnection = item.socket_id\n        ? (channels.connections()[item.socket_id] ?? null)\n        : null;\n      const excludeConnection = channelConnection\n        ? channelConnection.connection()\n        : null;\n\n      dispatch(\n        application,\n        {\n          event: item.name,\n          channel: item.channel,\n          data: item.data,\n        },\n        channels,\n        excludeConnection,\n      );\n\n      // Return promise for metrics gathering if requested\n      return item.info\n        ? this.metricsHandler.gather(application, \"channel\", {\n            channel: item.channel,\n            info: item.info,\n          })\n        : Promise.resolve({});\n    });\n\n    // Check if any items requested metrics\n    const hasMetrics = batch.some((item) => item.info);\n\n    if (hasMetrics) {\n      // Wait for all metrics to be gathered\n      const results = await Promise.all(items);\n      return new Response({\n        batch: results.map((result) => result || {}),\n      });\n    }\n\n    // No metrics requested, return empty batch object\n    return new Response({ batch: {} });\n  }\n\n  /**\n   * Validate the request payload.\n   *\n   * Validates:\n   * - batch is required and must be an array\n   * - batch must contain at most 10 items\n   * - Each item must have required fields (name, data, channel)\n   * - Each item's fields must be strings\n   *\n   * @param payload - The parsed request body\n   * @returns Validation errors object or null if valid\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 71,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 71,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 72,
                        "column": 3
                      }
                    },
                    {
                      "startPosition": {
                        "line": 95,
                        "column": 3
                      },
                      "endPosition": {
                        "line": 102,
                        "column": 5
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class EventsBatchController {",
                    "lineNumber": 71,
                    "isSignature": true
                  },
                  {
                    "text": "async handle(",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    request: IHttpRequest,",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    _connection: Connection,",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    _appId: string,",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "    application: Application,",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    channels: ChannelManager,",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<Response> {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "const ;",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "    const batch = typedPayload.batch;",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "    // Process each batch item",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "    const items = batch.map((item) => {",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "      // Dispatch the event",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "      const channelConnection = item.socket_id",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "        ? (channels.connections()[item.socket_id] ?? null)",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "      const excludeConnection = channelConnection",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "        ? channelConnection.connection()",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "        : null;",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "      dispatch(",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "        application,",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "        {",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "          event: item.name,",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "          channel: item.channel,",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "          data: item.data,",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "        },",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "        channels,",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "        excludeConnection,",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "      );",
                    "lineNumber": 149,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 150,
                    "isSignature": false
                  },
                  {
                    "text": "      // Return promise for metrics gathering if requested",
                    "lineNumber": 151,
                    "isSignature": false
                  },
                  {
                    "text": "      return item.info",
                    "lineNumber": 152,
                    "isSignature": false
                  },
                  {
                    "text": "        ? this.metricsHandler.gather(application, \"channel\", {",
                    "lineNumber": 153,
                    "isSignature": false
                  },
                  {
                    "text": "            channel: item.channel,",
                    "lineNumber": 154,
                    "isSignature": false
                  },
                  {
                    "text": "            info: item.info,",
                    "lineNumber": 155,
                    "isSignature": false
                  },
                  {
                    "text": "          })",
                    "lineNumber": 156,
                    "isSignature": false
                  },
                  {
                    "text": "        : Promise.resolve({});",
                    "lineNumber": 157,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 158,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 159,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if any items requested metrics",
                    "lineNumber": 160,
                    "isSignature": false
                  },
                  {
                    "text": "    const hasMetrics = batch.some((item) => item.info);",
                    "lineNumber": 161,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 162,
                    "isSignature": false
                  },
                  {
                    "text": "    if (hasMetrics) {",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "      // Wait for all metrics to be gathered",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "      const results = await Promise.all(items);",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "      return new Response({",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "        batch: results.map((result) => result || {}),",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "      });",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "    // No metrics requested, return empty batch object",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "    return new Response({ batch: {} });",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validate the request payload.",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "   * Validates:",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch is required and must be an array",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "   * - batch must contain at most 10 items",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item must have required fields (name, data, channel)",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "   * - Each item's fields must be strings",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param payload - The parsed request body",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Validation errors object or null if valid",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 281,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.22522740066051483
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channels-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 316,
                    "column": 1
                  }
                },
                "contents": "export class ChannelsController {\n\n\n  /**\n   * Verify that the incoming request is valid.\n   *\n   * @param request - The HTTP request\n   * @param connection - The HTTP connection\n   * @param appId - The application ID\n   * @throws {Error} Throws if verification fails\n   */\n  verify(request: IHttpRequest, _connection: Connection, appId: string): void {\n    this.body = request.body;\n    this.query = this.parseQuery(request.path);\n\n    this.setApplication(appId);\n    this.setChannels();\n    this.verifySignature(request);\n  }\n\n  /**\n   * Parse query parameters from the request path.\n   *\n   * @param path - The request path including query string\n   * @returns Parsed query parameters\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelsController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify that the incoming request is valid.",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The HTTP request",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The HTTP connection",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param appId - The application ID",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} Throws if verification fails",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "  verify(request: IHttpRequest, _connection: Connection, appId: string): void {",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "    this.body = request.body;",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "    this.query = this.parseQuery(request.path);",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 137,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setApplication(appId);",
                    "lineNumber": 138,
                    "isSignature": false
                  },
                  {
                    "text": "    this.setChannels();",
                    "lineNumber": 139,
                    "isSignature": false
                  },
                  {
                    "text": "    this.verifySignature(request);",
                    "lineNumber": 140,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 141,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 142,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 143,
                    "isSignature": false
                  },
                  {
                    "text": "   * Parse query parameters from the request path.",
                    "lineNumber": 144,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 145,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param path - The request path including query string",
                    "lineNumber": 146,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Parsed query parameters",
                    "lineNumber": 147,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 148,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 317,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.2233780026435852
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/channel-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 22,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 281,
                    "column": 1
                  }
                },
                "contents": "export class ChannelController {\n\n\n  /**\n   * Verify the Pusher authentication signature.\n   *\n   * The signature is computed from:\n   * 1. HTTP method (GET, POST, etc.)\n   * 2. Request path\n   * 3. Query parameters (sorted, excluding auth_signature)\n   * 4. Body MD5 (if body is not empty)\n   *\n   * @param request - The incoming HTTP request\n   * @throws {Error} If signature verification fails\n   */\n  protected verifySignature(request: Request): void {\n    if (!this.application) {\n      throw new Error(\"Application not set\");\n    }\n\n    // Exclude certain parameters from signature calculation\n    const params: Record<string, string> = {};\n    for (const [key, value] of Object.entries(this.query)) {\n      if (\n        ![\n          \"auth_signature\",\n          \"body_md5\",\n          \"appId\",\n          \"appKey\",\n          \"channelName\",\n        ].includes(key)\n      ) {\n        params[key] = value;\n      }\n    }\n\n    // Add body MD5 if body is not empty\n    if (this.body && this.body !== \"\") {\n      params.body_md5 = this.md5(this.body);\n    }\n\n    // Sort parameters by key\n    const sortedKeys = Object.keys(params).sort();\n    const sortedParams: Record<string, string> = {};\n    for (const key of sortedKeys) {\n      sortedParams[key] = params[key] ?? \"\";\n    }\n\n    // Format query parameters for verification\n    const queryString = this.formatQueryParametersForVerification(sortedParams);\n\n    // Build signature string\n    const url = new URL(request.url);\n    const signatureString = [request.method, url.pathname, queryString].join(\n      \"\\n\",\n    );\n\n    // Compute HMAC SHA256 signature\n    const signature = this.hmacSha256(\n      signatureString,\n      this.application.secret(),\n    );\n    const authSignature = this.query.auth_signature ?? \"\";\n\n    if (signature !== authSignature) {\n      throw new Error(\"Authentication signature invalid.\");\n    }\n  }\n\n  /**\n   * Format the given parameters into the correct format for signature verification.\n   *\n   * Converts parameters object into a query string format: key1=value1&key2=value2\n   * Arrays are joined with commas.\n   *\n   * @param params - The parameters to format\n   * @returns Formatted query string\n   */\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 23,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 23,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 24,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class ChannelController {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 163,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 164,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 165,
                    "isSignature": false
                  },
                  {
                    "text": "   * Verify the Pusher authentication signature.",
                    "lineNumber": 166,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 167,
                    "isSignature": false
                  },
                  {
                    "text": "   * The signature is computed from:",
                    "lineNumber": 168,
                    "isSignature": false
                  },
                  {
                    "text": "   * 1. HTTP method (GET, POST, etc.)",
                    "lineNumber": 169,
                    "isSignature": false
                  },
                  {
                    "text": "   * 2. Request path",
                    "lineNumber": 170,
                    "isSignature": false
                  },
                  {
                    "text": "   * 3. Query parameters (sorted, excluding auth_signature)",
                    "lineNumber": 171,
                    "isSignature": false
                  },
                  {
                    "text": "   * 4. Body MD5 (if body is not empty)",
                    "lineNumber": 172,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 173,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param request - The incoming HTTP request",
                    "lineNumber": 174,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws {Error} If signature verification fails",
                    "lineNumber": 175,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 176,
                    "isSignature": false
                  },
                  {
                    "text": "  protected verifySignature(request: Request): void {",
                    "lineNumber": 177,
                    "isSignature": false
                  },
                  {
                    "text": "    if (!this.application) {",
                    "lineNumber": 178,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error(\"Application not set\");",
                    "lineNumber": 179,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 180,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 181,
                    "isSignature": false
                  },
                  {
                    "text": "    // Exclude certain parameters from signature calculation",
                    "lineNumber": 182,
                    "isSignature": false
                  },
                  {
                    "text": "    const params: Record<string, string> = {};",
                    "lineNumber": 183,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const [key, value] of Object.entries(this.query)) {",
                    "lineNumber": 184,
                    "isSignature": false
                  },
                  {
                    "text": "      if (",
                    "lineNumber": 185,
                    "isSignature": false
                  },
                  {
                    "text": "        ![",
                    "lineNumber": 186,
                    "isSignature": false
                  },
                  {
                    "text": "          \"auth_signature\",",
                    "lineNumber": 187,
                    "isSignature": false
                  },
                  {
                    "text": "          \"body_md5\",",
                    "lineNumber": 188,
                    "isSignature": false
                  },
                  {
                    "text": "          \"appId\",",
                    "lineNumber": 189,
                    "isSignature": false
                  },
                  {
                    "text": "          \"appKey\",",
                    "lineNumber": 190,
                    "isSignature": false
                  },
                  {
                    "text": "          \"channelName\",",
                    "lineNumber": 191,
                    "isSignature": false
                  },
                  {
                    "text": "        ].includes(key)",
                    "lineNumber": 192,
                    "isSignature": false
                  },
                  {
                    "text": "      ) {",
                    "lineNumber": 193,
                    "isSignature": false
                  },
                  {
                    "text": "        params[key] = value;",
                    "lineNumber": 194,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 195,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 196,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 197,
                    "isSignature": false
                  },
                  {
                    "text": "    // Add body MD5 if body is not empty",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": "    if (this.body && this.body !== \"\") {",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": "      params.body_md5 = this.md5(this.body);",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": "    // Sort parameters by key",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "    const sortedKeys = Object.keys(params).sort();",
                    "lineNumber": 204,
                    "isSignature": false
                  },
                  {
                    "text": "    const sortedParams: Record<string, string> = {};",
                    "lineNumber": 205,
                    "isSignature": false
                  },
                  {
                    "text": "    for (const key of sortedKeys) {",
                    "lineNumber": 206,
                    "isSignature": false
                  },
                  {
                    "text": "      sortedParams[key] = params[key] ?? \"\";",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "    // Format query parameters for verification",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "    const queryString = this.formatQueryParametersForVerification(sortedParams);",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "    // Build signature string",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "    const url = new URL(request.url);",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "    const signatureString = [request.method, url.pathname, queryString].join(",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "      \"\\n\",",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 218,
                    "isSignature": false
                  },
                  {
                    "text": "    // Compute HMAC SHA256 signature",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": "    const signature = this.hmacSha256(",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": "      signatureString,",
                    "lineNumber": 221,
                    "isSignature": false
                  },
                  {
                    "text": "      this.application.secret(),",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": "    );",
                    "lineNumber": 223,
                    "isSignature": false
                  },
                  {
                    "text": "    const authSignature = this.query.auth_signature ?? \"\";",
                    "lineNumber": 224,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 225,
                    "isSignature": false
                  },
                  {
                    "text": "    if (signature !== authSignature) {",
                    "lineNumber": 226,
                    "isSignature": false
                  },
                  {
                    "text": "      throw new Error(\"Authentication signature invalid.\");",
                    "lineNumber": 227,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 228,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 229,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 230,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 231,
                    "isSignature": false
                  },
                  {
                    "text": "   * Format the given parameters into the correct format for signature verification.",
                    "lineNumber": 232,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 233,
                    "isSignature": false
                  },
                  {
                    "text": "   * Converts parameters object into a query string format: key1=value1&key2=value2",
                    "lineNumber": 234,
                    "isSignature": false
                  },
                  {
                    "text": "   * Arrays are joined with commas.",
                    "lineNumber": 235,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 236,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param params - The parameters to format",
                    "lineNumber": 237,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Formatted query string",
                    "lineNumber": 238,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 239,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 282,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.22056590020656586
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/protocols/pusher/http/controllers/connections-controller.ts",
                "range": {
                  "startPosition": {
                    "line": 195,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 223,
                    "column": 3
                  }
                },
                "contents": "/**\n * Format query parameters for signature verification.\n *\n * @param params - The parameters to format\n * @returns Formatted query string\n */\nfunction formatQueryParametersForVerification(\n  params: Record<string, string | string[]>,\n): string {\n  const parts: string[] = [];\n\n  for (const [key, value] of Object.entries(params)) {\n    if (Array.isArray(value)) {\n      parts.push(`${key}=${value.join(\",\")}`);\n    } else {\n      parts.push(`${key}=${value}`);\n    }\n  }\n\n  return parts.join(\"&\");\n}\n\n/**\n * Get the application provider instance from the Factory.\n *\n * @returns The application provider instance\n */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 198,
                    "isSignature": false
                  },
                  {
                    "text": " * Format query parameters for signature verification.",
                    "lineNumber": 199,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 200,
                    "isSignature": false
                  },
                  {
                    "text": " * @param params - The parameters to format",
                    "lineNumber": 201,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns Formatted query string",
                    "lineNumber": 202,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 203,
                    "isSignature": false
                  },
                  {
                    "text": "function formatQueryParametersForVerification(",
                    "lineNumber": 204,
                    "isSignature": true
                  },
                  {
                    "text": "  params: Record<string, string | string[]>,",
                    "lineNumber": 205,
                    "isSignature": true
                  },
                  {
                    "text": "): string {",
                    "lineNumber": 206,
                    "isSignature": true
                  },
                  {
                    "text": "  const parts: string[] = [];",
                    "lineNumber": 207,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 208,
                    "isSignature": false
                  },
                  {
                    "text": "  for (const [key, value] of Object.entries(params)) {",
                    "lineNumber": 209,
                    "isSignature": false
                  },
                  {
                    "text": "    if (Array.isArray(value)) {",
                    "lineNumber": 210,
                    "isSignature": false
                  },
                  {
                    "text": "      parts.push(`${key}=${value.join(\",\")}`);",
                    "lineNumber": 211,
                    "isSignature": false
                  },
                  {
                    "text": "    } else {",
                    "lineNumber": 212,
                    "isSignature": false
                  },
                  {
                    "text": "      parts.push(`${key}=${value}`);",
                    "lineNumber": 213,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 214,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 215,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 216,
                    "isSignature": false
                  },
                  {
                    "text": "  return parts.join(\"&\");",
                    "lineNumber": 217,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 218,
                    "isSignature": true
                  },
                  {
                    "text": "",
                    "lineNumber": 219,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 220,
                    "isSignature": false
                  },
                  {
                    "text": " * Get the application provider instance from the Factory.",
                    "lineNumber": 221,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 222,
                    "isSignature": false
                  },
                  {
                    "text": " * @returns The application provider instance",
                    "lineNumber": 223,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 224,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.21915070712566376
            }
          ]
        }
      }
    }

### Assistant

Running typecheck to see the actual errors:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | grep -A 5 "factory.ts" | head -50`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | grep -A 5 "factory.ts" | head -50`
    * **cwd:** `.`
    * **status:** failure
    * **details:**

    {
      "command": "cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | grep -A 5 \"factory.ts\" | head -50",
      "workingDirectory": "",
      "exitCode": 1,
      "signal": "",
      "stdout": "",
      "stderr": "",
      "executionTime": 1857
    }

### Assistant

Running typecheck to see all errors:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    $ tsc --noEmit

### Assistant

Typecheck passes. Checking lint errors, focusing on the specific lines mentioned in the review:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | grep -E "(error|warning|any)" | head -30`
    * **cwd:** `.`
    * **status:** pending

### Tool · read (started)

    * **path:** `tests/e2e/websocket-connection.test.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `tests/unit/events/event-dispatcher.test.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/e2e/websocket-connection.test.ts`
    * **status:** success
        * lines: 93-97
    * **content:**

      it("should receive connection_established message", async () => {
        const ws = new WebSocket(`ws://127.0.0.1:${testPort}/app/${testAppKey}`);
    
        const message = await new Promise<unknown>((resolve, reject) => {
          const timeout = setTimeout(() => {

### Tool · read (completed)

    * **path:** `tests/unit/events/event-dispatcher.test.ts`
    * **status:** success
        * lines: 305-319
    * **content:**

    
          // Register multiple listeners
          EventDispatcher.on("user:login", (data: unknown) => {
            const eventData = data as { user: string };
            log.push(`login: ${eventData.user}`);
          });
    
          EventDispatcher.once("user:login", (data: unknown) => {
            const eventData = data as { user: string };
            log.push(`once: ${eventData.user}`);
          });
    
          const unsubscribe = EventDispatcher.on("user:login", (data: unknown) => {
            const eventData = data as { user: string };
            log.push(`temp: ${eventData.user}`);

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | grep -E "(error|warning|any)" | head -30`
    * **cwd:** `.`
    * **status:** failure
    * **details:**

    {
      "command": "cd /Users/tom/personal/revurb && bun run lint 2>&1 | grep -E \"(error|warning|any)\" | head -30",
      "workingDirectory": "",
      "exitCode": 1,
      "signal": "",
      "stdout": "Found 1 error.\n  × Some errors were emitted while running checks.\nerror: script \"lint\" exited with code 1\n",
      "stderr": "",
      "executionTime": 1093
    }

### Assistant

Running lint to see the actual errors:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1`
    * **cwd:** `.`
    * **status:** failure
    * **details:**

    {
      "command": "cd /Users/tom/personal/revurb && bun run lint 2>&1",
      "workingDirectory": "",
      "exitCode": 1,
      "signal": "",
      "stdout": "$ biome check .\nsrc/servers/reverb/factory.ts format ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n  × Formatter would have printed the following content:\n  \n    1184 1184 │       });\n    1185 1185 │   \n    1186      │ - ····const·request:·IHttpRequest·&·{·url:·string;·httpVersion:·string;·getSize():·number·}·=·{\n         1186 │ + ····const·request:·IHttpRequest·&·{\n         1187 │ + ······url:·string;\n         1188 │ + ······httpVersion:·string;\n         1189 │ + ······getSize():·number;\n         1190 │ + ····}·=·{\n    1187 1191 │         method,\n    1188 1192 │         path: pathWithQuery,\n  \n\nChecked 110 files in 34ms. No fixes applied.\nFound 1 error.\ncheck ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n  × Some errors were emitted while running checks.\n  \n\nerror: script \"lint\" exited with code 1\n",
      "stderr": "",
      "executionTime": 1131
    }

### Assistant

Fixing the formatting issue:

### Tool · edit (started)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts"
      }
    }

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint:fix`
    * **cwd:** `.`
    * **status:** pending

### Tool · edit (completed)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts"
      },
      "result": {
        "success": {
          "path": "/Users/tom/personal/revurb/src/servers/reverb/factory.ts",
          "resultForModel": "",
          "linesAdded": 5,
          "linesRemoved": 1,
          "diffString": "      });\n  \n-     const request: IHttpRequest & { url: string; httpVersion: string; getSize(): number } = {\n+     const request: IHttpRequest & {\n+       url: string;\n+       httpVersion: string;\n+       getSize(): number;\n+     } = {\n        method,\n        path: pathWithQuery,",
          "beforeFullFileContent": "/**\n * Factory for creating Reverb WebSocket servers\n *\n * Creates and configures HTTP servers with WebSocket support for the Pusher protocol.\n * Handles routing, TLS/SSL configuration, and protocol selection.\n *\n * @module Servers/Reverb/Factory\n */\n\nimport type { ServeOptions, ServerWebSocket, WebSocket } from \"bun\";\nimport type { Application } from \"../../application\";\nimport { ApplicationManager } from \"../../application-manager\";\nimport { Certificate } from \"../../certificate\";\nimport type { ReverbConfig } from \"../../config/types\";\nimport { Connection as ReverbConnection } from \"../../connection\";\nimport type { IApplicationProvider } from \"../../contracts/application-provider\";\nimport { ServerProvider } from \"../../contracts/server-provider\";\nimport { FrameOpcode } from \"../../contracts/websocket-connection\";\nimport { CliLogger } from \"../../loggers/cli-logger\";\nimport { Log } from \"../../loggers/log\";\nimport type { NullLogger } from \"../../loggers/null-logger\";\nimport { ClientEvent } from \"../../protocols/pusher/client-event\";\nimport { EventHandler } from \"../../protocols/pusher/event-handler\";\nimport { ChannelController } from \"../../protocols/pusher/http/controllers/channel-controller\";\nimport { channelUsersController } from \"../../protocols/pusher/http/controllers/channel-users-controller\";\nimport { ChannelsController } from \"../../protocols/pusher/http/controllers/channels-controller\";\nimport { connectionsController } from \"../../protocols/pusher/http/controllers/connections-controller\";\nimport { EventsBatchController } from \"../../protocols/pusher/http/controllers/events-batch-controller\";\nimport { EventsController } from \"../../protocols/pusher/http/controllers/events-controller\";\nimport { UsersTerminateController } from \"../../protocols/pusher/http/controllers/users-terminate-controller\";\nimport { ArrayChannelConnectionManager } from \"../../protocols/pusher/managers/array-channel-connection-manager\";\nimport { ArrayChannelManager } from \"../../protocols/pusher/managers/array-channel-manager\";\nimport { MetricsHandler } from \"../../protocols/pusher/metrics-handler\";\nimport { Server as PusherServer } from \"../../protocols/pusher/server\";\nimport { Connection as WebSocketConnection } from \"./connection\";\nimport { Connection as HttpConnection } from \"./http/connection\";\nimport { Response as HttpResponse } from \"./http/response\";\nimport type { IHttpRequest } from \"./http/router\";\n\n/**\n * WebSocket connection data stored in Bun's ws.data\n */\ninterface WebSocketData {\n  app?: Application;\n  origin?: string | null;\n  connection?: ReverbConnection;\n  onMessage?: (message: string | Buffer) => void;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onPing?: () => void;\n  onPong?: () => void;\n}\n\n/**\n * Route definition for HTTP handlers\n */\ninterface RouteDefinition {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  path: string;\n  handler: (\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ) => Response | Promise<Response> | undefined;\n}\n\n/**\n * Router for handling HTTP requests with pattern matching\n */\nclass Router {\n  private routes: RouteDefinition[] = [];\n\n  /**\n   * Add a GET route\n   */\n  public get(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"GET\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a POST route\n   */\n  public post(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"POST\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a route\n   */\n  public add(\n    method: \"GET\" | \"POST\",\n    path: string,\n    handler: RouteDefinition[\"handler\"],\n  ): this {\n    this.routes.push({ method, path, handler });\n    return this;\n  }\n\n  /**\n   * Match a request to a route and extract parameters\n   */\n  public match(\n    method: string,\n    pathname: string,\n  ): {\n    handler: RouteDefinition[\"handler\"];\n    params: Record<string, string>;\n  } | null {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n\n      const params = this.matchPath(route.path, pathname);\n      if (params !== null) {\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Match a path pattern to a URL pathname\n   * Converts /apps/{appId}/events to regex and extracts parameters\n   */\n  private matchPath(\n    pattern: string,\n    pathname: string,\n  ): Record<string, string> | null {\n    // Convert pattern to regex: /apps/{appId}/events => /apps\\/([^/]+)\\/events/\n    const regexPattern = pattern\n      .replace(/\\//g, \"\\\\/\")\n      .replace(/\\{([^}]+)\\}/g, \"([^/]+)\");\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = pathname.match(regex);\n\n    if (!match) return null;\n\n    // Extract parameter names from pattern\n    const paramNames: string[] = [];\n    const paramRegex = /\\{([^}]+)\\}/g;\n    let match_params: RegExpExecArray | null = null;\n    match_params = paramRegex.exec(pattern);\n    while (match_params !== null) {\n      if (match_params[1]) {\n        paramNames.push(match_params[1]);\n      }\n      match_params = paramRegex.exec(pattern);\n    }\n\n    // Build params object from matched groups\n    const params: Record<string, string> = {};\n    paramNames.forEach((name, index) => {\n      params[name] = match[index + 1] || \"\";\n    });\n\n    return params;\n  }\n}\n\n/**\n * TLS/SSL configuration context\n */\ninterface TlsContext {\n  local_cert?: string;\n  local_pk?: string;\n  verify_peer?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * HTTP Server options for Bun\n */\ninterface HttpServerOptions {\n  tls?: TlsContext;\n  [key: string]: unknown;\n}\n\n/**\n * Factory for creating Reverb WebSocket servers with Pusher protocol support\n *\n * @class Factory\n * @example\n * ```typescript\n * const server = Factory.make('0.0.0.0', '8080', '', 'localhost');\n * ```\n */\n// biome-ignore lint/complexity/noStaticOnlyClass: Factory pattern requires static methods for singleton-like behavior\nexport class Factory {\n  /**\n   * Application manager for app lookup and validation\n   */\n  private static appManager: ApplicationManager | null = null;\n\n  /**\n   * Channel manager for managing Pusher channels\n   */\n  private static channelManager: ArrayChannelManager | null = null;\n\n  /**\n   * Pusher protocol server instance\n   */\n  private static pusherServer: PusherServer | null = null;\n\n  /**\n   * Logger instance\n   */\n  private static logger: CliLogger | NullLogger | null = null;\n\n  /**\n   * Metrics handler instance\n   */\n  private static metricsHandler: MetricsHandler | null = null;\n\n  /**\n   * Controller instances\n   */\n  private static eventsController: EventsController | null = null;\n  private static eventsBatchController: EventsBatchController | null = null;\n  private static channelsController: ChannelsController | null = null;\n  private static channelController: ChannelController | null = null;\n  private static usersTerminateController: UsersTerminateController | null =\n    null;\n\n  /**\n   * Application provider instance (used by controllers)\n   */\n  private static applicationProvider: IApplicationProvider | null = null;\n\n  /**\n   * Server provider instance (used by controllers)\n   */\n  private static serverProvider: ServerProvider | null = null;\n\n  /**\n   * Initialize the factory with configuration\n   *\n   * @param config - The Reverb configuration\n   */\n  public static initialize(config: ReverbConfig): void {\n    Factory.logger = new CliLogger();\n    // Set the logger in the Log facade so it's available globally\n    Log.setLogger(Factory.logger);\n    Factory.appManager = new ApplicationManager(config);\n\n    // Create application provider and channel connection manager\n    Factory.applicationProvider = Factory.appManager.driver();\n    const channelConnectionManager = new ArrayChannelConnectionManager();\n\n    Factory.channelManager = new ArrayChannelManager(\n      Factory.applicationProvider,\n      channelConnectionManager,\n      Factory.logger,\n    );\n\n    const eventHandler = new EventHandler(Factory.channelManager);\n    const clientEvent = new ClientEvent(Factory.channelManager);\n\n    Factory.pusherServer = new PusherServer(\n      Factory.channelManager,\n      eventHandler,\n      clientEvent,\n      Factory.logger,\n    );\n\n    // Create a minimal server provider\n    // By default, server does not subscribe to events (standalone mode)\n    Factory.serverProvider = new (class extends ServerProvider {\n      override subscribesToEvents(): boolean {\n        return false;\n      }\n    })();\n\n    // Initialize metrics handler with all required dependencies\n    Factory.metricsHandler = new MetricsHandler(\n      Factory.serverProvider,\n      Factory.channelManager,\n      null,\n    );\n\n    // Initialize class-based controllers with proper dependencies\n    Factory.eventsController = new EventsController(\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.eventsBatchController = new EventsBatchController(\n      Factory.metricsHandler,\n    );\n    Factory.channelsController = new ChannelsController(\n      Factory.metricsHandler,\n      Factory.applicationProvider,\n      Factory.channelManager,\n    );\n    Factory.channelController = new ChannelController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.usersTerminateController = new UsersTerminateController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.serverProvider,\n      undefined,\n    );\n  }\n\n  /**\n   * Get the channel manager instance\n   *\n   * @returns The channel manager instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getChannelManager(): ArrayChannelManager {\n    if (!Factory.channelManager) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.channelManager;\n  }\n\n  /**\n   * Get the application provider instance\n   *\n   * @returns The application provider instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getApplicationProvider(): IApplicationProvider {\n    if (!Factory.applicationProvider) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.applicationProvider;\n  }\n\n  /**\n   * Get the logger instance\n   *\n   * @returns The logger instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getLogger(): CliLogger | NullLogger {\n    if (!Factory.logger) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.logger;\n  }\n\n  /**\n   * Get the metrics handler instance\n   *\n   * @returns The metrics handler instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getMetricsHandler(): MetricsHandler {\n    if (!Factory.metricsHandler) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.metricsHandler;\n  }\n\n  /**\n   * Create a new WebSocket server instance\n   *\n   * Creates and configures an HTTP server with WebSocket support using Bun.\n   * Handles TLS/SSL configuration and protocol routing.\n   *\n   * @param host - Server host address (default: '0.0.0.0')\n   * @param port - Server port (default: '8080')\n   * @param path - URL path prefix for all routes (default: '')\n   * @param hostname - Hostname for TLS certificate resolution (optional)\n   * @param maxRequestSize - Maximum request size in bytes (default: 10000)\n   * @param options - Additional server options (default: {})\n   * @param protocol - Protocol to use ('pusher' only for now) (default: 'pusher')\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                      Used to determine TLS peer verification settings\n   * @returns The configured Bun server instance\n   *\n   * @throws {Error} If protocol is unsupported\n   *\n   * @example\n   * ```typescript\n   * const server = Factory.make('127.0.0.1', '8080', '', 'myapp.test', 10000, {}, 'pusher', 'production');\n   * console.log('Server running on port 8080');\n   * ```\n   */\n  public static make(\n    host = \"0.0.0.0\",\n    port = \"8080\",\n    path = \"\",\n    hostname?: string,\n    maxRequestSize = 10000,\n    options: HttpServerOptions = {},\n    protocol = \"pusher\",\n    environment: string = process.env.NODE_ENV || \"development\",\n  ) {\n    if (protocol !== \"pusher\") {\n      throw new Error(`Unsupported protocol [${protocol}].`);\n    }\n\n    const router = Factory.makePusherRouter(path);\n    const tlsContext = Factory.configureTls(\n      options.tls ?? {},\n      hostname,\n      environment,\n    );\n    const portNum = Number.parseInt(port, 10);\n\n    // Build Bun server options\n    const serveOptions: ServeOptions & { maxRequestBodySize?: number } = {\n      hostname: host,\n      port: portNum,\n      maxRequestBodySize: maxRequestSize,\n      fetch: async (req: Request, server: ReturnType<typeof Bun.serve>) =>\n        Factory.handleRequest(req, router, server),\n      websocket: {\n        open: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket open handler - create connection and notify Pusher server\n          const data = ws.data as WebSocketData | undefined;\n          if (!data || !data.app) {\n            console.error(\"WebSocket opened without app data\");\n            ws.close();\n            return;\n          }\n\n          try {\n            // Create WebSocket connection wrapper\n            const wsConnection = new WebSocketConnection(\n              ws as unknown as WebSocket,\n            );\n\n            // Create Reverb connection with app and origin\n            const connection = new ReverbConnection(\n              wsConnection,\n              data.app,\n              data.origin || null,\n            );\n\n            // Store connection in ws.data for later use\n            data.connection = connection;\n\n            // Notify Pusher server of new connection\n            if (Factory.pusherServer) {\n              Factory.pusherServer.open(connection);\n            }\n          } catch (error) {\n            console.error(\"Error opening WebSocket connection:\", error);\n            ws.close();\n          }\n        },\n        message: (ws: ServerWebSocket<unknown>, message: string | Buffer) => {\n          // WebSocket message handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            console.error(\"WebSocket message received without connection\");\n            return;\n          }\n\n          try {\n            const messageStr =\n              typeof message === \"string\" ? message : message.toString(\"utf-8\");\n\n            // Pass message to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.message(data.connection, messageStr);\n            }\n          } catch (error) {\n            console.error(\"Error handling WebSocket message:\", error);\n          }\n        },\n        close: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket close handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Notify Pusher server of connection close\n            if (Factory.pusherServer) {\n              Factory.pusherServer.close(data.connection);\n            }\n          } catch (error) {\n            console.error(\"Error closing WebSocket connection:\", error);\n          }\n        },\n        ping: (ws: ServerWebSocket<unknown>) => {\n          // Ping handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PING frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PING,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling ping:\", error);\n          }\n        },\n        pong: (ws: ServerWebSocket<unknown>) => {\n          // Pong handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PONG frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PONG,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling pong:\", error);\n          }\n        },\n      },\n    };\n\n    // Add TLS configuration if present\n    if (\n      Factory.usesTls(tlsContext) &&\n      tlsContext.local_cert &&\n      tlsContext.local_pk\n    ) {\n      serveOptions.tls = {\n        cert: Bun.file(tlsContext.local_cert),\n        key: Bun.file(tlsContext.local_pk),\n      };\n    }\n\n    return Bun.serve(serveOptions);\n  }\n\n  /**\n   * Handle incoming HTTP requests and route them appropriately\n   *\n   * @param req - The incoming request\n   * @param router - The router instance\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response to send back to client\n   *\n   * @private\n   */\n  private static async handleRequest(\n    req: Request,\n    router: Router,\n    server: ReturnType<typeof Bun.serve>,\n  ): Promise<Response | undefined> {\n    const url = new URL(req.url);\n    const pathname = url.pathname;\n    const method = req.method;\n\n    const match = router.match(method, pathname);\n    if (!match) {\n      return new Response(JSON.stringify({ error: \"Not Found\" }), {\n        status: 404,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    try {\n      // Pass server to handler for WebSocket upgrade support\n      return await Promise.resolve(match.handler(req, match.params, server));\n    } catch (error) {\n      console.error(\"Route handler error:\", error);\n      return new Response(JSON.stringify({ error: \"Internal Server Error\" }), {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n  }\n\n  /**\n   * Create a new router for the Pusher protocol\n   *\n   * Sets up all routes required for Pusher protocol support.\n   * This includes WebSocket connections and HTTP API endpoints.\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Router - Configured router instance\n   *\n   * @private\n   */\n  private static makePusherRouter(path: string): Router {\n    const router = new Router();\n\n    // Set up Pusher routes with optional path prefix\n    const routes = Factory.pusherRoutes(path);\n\n    for (const route of routes) {\n      if (route.method === \"GET\") {\n        router.get(route.path, route.handler);\n      } else if (route.method === \"POST\") {\n        router.post(route.path, route.handler);\n      }\n    }\n\n    return router;\n  }\n\n  /**\n   * Generate the routes required to handle Pusher protocol requests\n   *\n   * Defines all HTTP API endpoints for:\n   * - WebSocket connections\n   * - Event triggering\n   * - Connection management\n   * - Channel information\n   * - Health checks\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Array of route definitions\n   *\n   * @private\n   */\n  private static pusherRoutes(path: string): RouteDefinition[] {\n    const basePath = path || \"\";\n    const prefix = (route: string) => `${basePath}${route}`;\n\n    return [\n      {\n        method: \"GET\",\n        path: prefix(\"/app/{appKey}\"),\n        handler: Factory.handleWebSocketConnection.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/events\"),\n        handler: Factory.handleEvents.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/batch_events\"),\n        handler: Factory.handleBatchEvents.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/connections\"),\n        handler: Factory.handleConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels\"),\n        handler: Factory.handleChannels.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}\"),\n        handler: Factory.handleChannelInfo.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),\n        handler: Factory.handleChannelUsers.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),\n        handler: Factory.handleTerminateConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/up\"),\n        handler: Factory.handleHealthCheck.bind(Factory),\n      },\n    ];\n  }\n\n  /**\n   * Handle WebSocket connection requests\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appKey\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response with WebSocket upgrade or error, or undefined for successful upgrade\n   *\n   * @private\n   */\n  private static handleWebSocketConnection(\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ): Response | undefined {\n    // Check if this is a WebSocket upgrade request\n    if (req.headers.get(\"upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket upgrade\", { status: 400 });\n    }\n\n    if (!server) {\n      return new Response(\"Server instance not available\", { status: 500 });\n    }\n\n    if (!Factory.appManager || !Factory.pusherServer) {\n      return new Response(\n        \"Server not initialized. Call Factory.initialize() first.\",\n        { status: 500 },\n      );\n    }\n\n    const appKey = params.appKey;\n    if (!appKey) {\n      return new Response(\"Missing app key\", { status: 400 });\n    }\n\n    // Find application by key\n    let app: Application | null = null;\n    try {\n      const provider = Factory.appManager.driver();\n      app = provider.findByKey(appKey);\n    } catch (error) {\n      console.error(\"Error finding application:\", error);\n      return new Response(\"Invalid application\", { status: 404 });\n    }\n\n    if (!app) {\n      return new Response(\"Application not found\", { status: 404 });\n    }\n\n    // Get origin from request\n    const origin = req.headers.get(\"origin\");\n\n    // Set up WebSocket data with app and origin for use in handlers\n    const wsData: WebSocketData = {\n      app,\n      origin,\n    };\n\n    // Upgrade the connection to WebSocket\n    const upgraded = server.upgrade(req, {\n      data: wsData,\n    });\n\n    if (!upgraded) {\n      return new Response(\"WebSocket upgrade failed\", { status: 500 });\n    }\n\n    // Return undefined to indicate successful upgrade (Bun requirement)\n    // The actual connection handling will happen in the websocket.open handler\n    return undefined;\n  }\n\n  /**\n   * Handle event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      // Convert Bun Request to IHttpRequest\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n\n      // Get the application\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      // Call the controller\n      const response = await Factory.eventsController.__invoke(\n        httpRequest,\n        httpConnection,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle batch event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleBatchEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsBatchController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      const response = await Factory.eventsBatchController.handle(\n        httpRequest,\n        httpConnection,\n        params.appId,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling batch events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle connection listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of connections\n   *\n   * @private\n   */\n  private static async handleConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await connectionsController(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of channels\n   *\n   * @private\n   */\n  private static async handleChannels(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelsController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await Factory.channelsController.__invoke(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channels:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel information request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with channel info\n   *\n   * @private\n   */\n  private static async handleChannelInfo(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const response = await Factory.channelController.handle(\n        req,\n        params.appId,\n        params.channel,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel info:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel users listing (presence)\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with list of users in channel\n   *\n   * @private\n   */\n  private static async handleChannelUsers(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await channelUsersController(\n        httpRequest,\n        httpConnection,\n        params.channel,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel users:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle user connection termination\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and userId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleTerminateConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.usersTerminateController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.userId) {\n      return new Response(\"Missing appId or userId parameter\", { status: 400 });\n    }\n\n    try {\n      const response = await Factory.usersTerminateController.handle(\n        req,\n        params.appId,\n        params.userId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling terminate connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle health check request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters (none for this endpoint)\n   * @returns Response indicating server health\n   *\n   * @private\n   */\n  private static handleHealthCheck(\n    _req: Request,\n    _params: Record<string, string>,\n  ): Response {\n    return Response.json({ health: \"OK\" }, { status: 200 });\n  }\n\n  /**\n   * Configure TLS context for the server\n   *\n   * Filters out null values and attempts to auto-detect certificates\n   * for the given hostname if not explicitly provided.\n   * Sets verify_peer to true in production environments for better security.\n   *\n   * @param context - Initial TLS context (may contain null values)\n   * @param hostname - Hostname for certificate auto-detection\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                     Used to determine TLS peer verification settings\n   * @returns Configured TLS context\n   *\n   * @private\n   */\n  private static configureTls(\n    context: TlsContext,\n    hostname?: string,\n    environment: string = process.env.NODE_ENV || \"development\",\n  ): TlsContext {\n    // Filter out null/undefined values\n    const filtered: TlsContext = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (value !== null && value !== undefined) {\n        filtered[key] = value;\n      }\n    }\n\n    // Try to auto-detect certificates if not provided and hostname is given\n    if (\n      !Factory.usesTls(filtered) &&\n      hostname &&\n      Certificate.exists(hostname)\n    ) {\n      const certs = Certificate.resolve(hostname);\n      if (certs) {\n        const [certPath, keyPath] = certs;\n        filtered.local_cert = certPath;\n        filtered.local_pk = keyPath;\n        // Enable peer verification in production for better security\n        filtered.verify_peer = environment === \"production\";\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Determine whether the server uses TLS\n   *\n   * Checks if TLS context has both certificate and key configured.\n   *\n   * @param context - TLS context to check\n   * @returns True if TLS is configured, false otherwise\n   *\n   * @private\n   */\n  private static usesTls(context: TlsContext): boolean {\n    return !!(context.local_cert || context.local_pk);\n  }\n\n  /**\n   * Convert Bun Request to IHttpRequest\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\n    const url = new URL(req.url);\n    const body = req.method !== \"GET\" ? await req.text() : \"\";\n    const method = req.method;\n    // Store pathname + search for full path, but pathname only for signature verification\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    const request: IHttpRequest & { url: string; httpVersion: string; getSize(): number } = {\n      method,\n      path: pathWithQuery,\n      url: req.url, // Include full URL with query string for controllers to access query params\n      httpVersion: \"1.1\",\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        // Return path without query string for Pusher signature verification\n        // Pusher signatures are calculated over the path without the query string\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n      getSize(): number {\n        return Buffer.byteLength(body, \"utf8\");\n      },\n    };\n\n    return request;\n  }\n\n  /**\n   * Create a mock HTTP connection for controller use\n   *\n   * @returns HTTP Connection object\n   *\n   * @private\n   */\n  private static createHttpConnection(): HttpConnection {\n    return new HttpConnection({\n      stream: Math.floor(Math.random() * 1000000),\n    });\n  }\n\n  /**\n   * Convert controller Response to Bun Response\n   *\n   * @param controllerResponse - The response from the controller\n   * @returns Bun Response object\n   *\n   * @private\n   */\n  private static convertToResponse(\n    controllerResponse:\n      | HttpResponse\n      | { status?: number; content?: string | Record<string, unknown> },\n  ): Response {\n    // Check if it's our custom HttpResponse class\n    if (controllerResponse instanceof HttpResponse) {\n      const status = controllerResponse.getStatusCode();\n      const body = controllerResponse.getContent();\n      const headers = controllerResponse.getHeaders();\n\n      return new Response(body, {\n        status,\n        headers,\n      });\n    }\n\n    // Fallback for other response types\n    const status = controllerResponse.status || 200;\n    const body =\n      typeof controllerResponse.content === \"string\"\n        ? controllerResponse.content\n        : JSON.stringify(controllerResponse.content);\n\n    return new Response(body, {\n      status,\n      headers: {\n        \"Content-Type\":\n          typeof controllerResponse.content === \"string\"\n            ? \"text/plain\"\n            : \"application/json\",\n      },\n    });\n  }\n}\n",
          "afterFullFileContent": "/**\n * Factory for creating Reverb WebSocket servers\n *\n * Creates and configures HTTP servers with WebSocket support for the Pusher protocol.\n * Handles routing, TLS/SSL configuration, and protocol selection.\n *\n * @module Servers/Reverb/Factory\n */\n\nimport type { ServeOptions, ServerWebSocket, WebSocket } from \"bun\";\nimport type { Application } from \"../../application\";\nimport { ApplicationManager } from \"../../application-manager\";\nimport { Certificate } from \"../../certificate\";\nimport type { ReverbConfig } from \"../../config/types\";\nimport { Connection as ReverbConnection } from \"../../connection\";\nimport type { IApplicationProvider } from \"../../contracts/application-provider\";\nimport { ServerProvider } from \"../../contracts/server-provider\";\nimport { FrameOpcode } from \"../../contracts/websocket-connection\";\nimport { CliLogger } from \"../../loggers/cli-logger\";\nimport { Log } from \"../../loggers/log\";\nimport type { NullLogger } from \"../../loggers/null-logger\";\nimport { ClientEvent } from \"../../protocols/pusher/client-event\";\nimport { EventHandler } from \"../../protocols/pusher/event-handler\";\nimport { ChannelController } from \"../../protocols/pusher/http/controllers/channel-controller\";\nimport { channelUsersController } from \"../../protocols/pusher/http/controllers/channel-users-controller\";\nimport { ChannelsController } from \"../../protocols/pusher/http/controllers/channels-controller\";\nimport { connectionsController } from \"../../protocols/pusher/http/controllers/connections-controller\";\nimport { EventsBatchController } from \"../../protocols/pusher/http/controllers/events-batch-controller\";\nimport { EventsController } from \"../../protocols/pusher/http/controllers/events-controller\";\nimport { UsersTerminateController } from \"../../protocols/pusher/http/controllers/users-terminate-controller\";\nimport { ArrayChannelConnectionManager } from \"../../protocols/pusher/managers/array-channel-connection-manager\";\nimport { ArrayChannelManager } from \"../../protocols/pusher/managers/array-channel-manager\";\nimport { MetricsHandler } from \"../../protocols/pusher/metrics-handler\";\nimport { Server as PusherServer } from \"../../protocols/pusher/server\";\nimport { Connection as WebSocketConnection } from \"./connection\";\nimport { Connection as HttpConnection } from \"./http/connection\";\nimport { Response as HttpResponse } from \"./http/response\";\nimport type { IHttpRequest } from \"./http/router\";\n\n/**\n * WebSocket connection data stored in Bun's ws.data\n */\ninterface WebSocketData {\n  app?: Application;\n  origin?: string | null;\n  connection?: ReverbConnection;\n  onMessage?: (message: string | Buffer) => void;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onPing?: () => void;\n  onPong?: () => void;\n}\n\n/**\n * Route definition for HTTP handlers\n */\ninterface RouteDefinition {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  path: string;\n  handler: (\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ) => Response | Promise<Response> | undefined;\n}\n\n/**\n * Router for handling HTTP requests with pattern matching\n */\nclass Router {\n  private routes: RouteDefinition[] = [];\n\n  /**\n   * Add a GET route\n   */\n  public get(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"GET\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a POST route\n   */\n  public post(path: string, handler: RouteDefinition[\"handler\"]): this {\n    this.routes.push({ method: \"POST\", path, handler });\n    return this;\n  }\n\n  /**\n   * Add a route\n   */\n  public add(\n    method: \"GET\" | \"POST\",\n    path: string,\n    handler: RouteDefinition[\"handler\"],\n  ): this {\n    this.routes.push({ method, path, handler });\n    return this;\n  }\n\n  /**\n   * Match a request to a route and extract parameters\n   */\n  public match(\n    method: string,\n    pathname: string,\n  ): {\n    handler: RouteDefinition[\"handler\"];\n    params: Record<string, string>;\n  } | null {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n\n      const params = this.matchPath(route.path, pathname);\n      if (params !== null) {\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Match a path pattern to a URL pathname\n   * Converts /apps/{appId}/events to regex and extracts parameters\n   */\n  private matchPath(\n    pattern: string,\n    pathname: string,\n  ): Record<string, string> | null {\n    // Convert pattern to regex: /apps/{appId}/events => /apps\\/([^/]+)\\/events/\n    const regexPattern = pattern\n      .replace(/\\//g, \"\\\\/\")\n      .replace(/\\{([^}]+)\\}/g, \"([^/]+)\");\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = pathname.match(regex);\n\n    if (!match) return null;\n\n    // Extract parameter names from pattern\n    const paramNames: string[] = [];\n    const paramRegex = /\\{([^}]+)\\}/g;\n    let match_params: RegExpExecArray | null = null;\n    match_params = paramRegex.exec(pattern);\n    while (match_params !== null) {\n      if (match_params[1]) {\n        paramNames.push(match_params[1]);\n      }\n      match_params = paramRegex.exec(pattern);\n    }\n\n    // Build params object from matched groups\n    const params: Record<string, string> = {};\n    paramNames.forEach((name, index) => {\n      params[name] = match[index + 1] || \"\";\n    });\n\n    return params;\n  }\n}\n\n/**\n * TLS/SSL configuration context\n */\ninterface TlsContext {\n  local_cert?: string;\n  local_pk?: string;\n  verify_peer?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * HTTP Server options for Bun\n */\ninterface HttpServerOptions {\n  tls?: TlsContext;\n  [key: string]: unknown;\n}\n\n/**\n * Factory for creating Reverb WebSocket servers with Pusher protocol support\n *\n * @class Factory\n * @example\n * ```typescript\n * const server = Factory.make('0.0.0.0', '8080', '', 'localhost');\n * ```\n */\n// biome-ignore lint/complexity/noStaticOnlyClass: Factory pattern requires static methods for singleton-like behavior\nexport class Factory {\n  /**\n   * Application manager for app lookup and validation\n   */\n  private static appManager: ApplicationManager | null = null;\n\n  /**\n   * Channel manager for managing Pusher channels\n   */\n  private static channelManager: ArrayChannelManager | null = null;\n\n  /**\n   * Pusher protocol server instance\n   */\n  private static pusherServer: PusherServer | null = null;\n\n  /**\n   * Logger instance\n   */\n  private static logger: CliLogger | NullLogger | null = null;\n\n  /**\n   * Metrics handler instance\n   */\n  private static metricsHandler: MetricsHandler | null = null;\n\n  /**\n   * Controller instances\n   */\n  private static eventsController: EventsController | null = null;\n  private static eventsBatchController: EventsBatchController | null = null;\n  private static channelsController: ChannelsController | null = null;\n  private static channelController: ChannelController | null = null;\n  private static usersTerminateController: UsersTerminateController | null =\n    null;\n\n  /**\n   * Application provider instance (used by controllers)\n   */\n  private static applicationProvider: IApplicationProvider | null = null;\n\n  /**\n   * Server provider instance (used by controllers)\n   */\n  private static serverProvider: ServerProvider | null = null;\n\n  /**\n   * Initialize the factory with configuration\n   *\n   * @param config - The Reverb configuration\n   */\n  public static initialize(config: ReverbConfig): void {\n    Factory.logger = new CliLogger();\n    // Set the logger in the Log facade so it's available globally\n    Log.setLogger(Factory.logger);\n    Factory.appManager = new ApplicationManager(config);\n\n    // Create application provider and channel connection manager\n    Factory.applicationProvider = Factory.appManager.driver();\n    const channelConnectionManager = new ArrayChannelConnectionManager();\n\n    Factory.channelManager = new ArrayChannelManager(\n      Factory.applicationProvider,\n      channelConnectionManager,\n      Factory.logger,\n    );\n\n    const eventHandler = new EventHandler(Factory.channelManager);\n    const clientEvent = new ClientEvent(Factory.channelManager);\n\n    Factory.pusherServer = new PusherServer(\n      Factory.channelManager,\n      eventHandler,\n      clientEvent,\n      Factory.logger,\n    );\n\n    // Create a minimal server provider\n    // By default, server does not subscribe to events (standalone mode)\n    Factory.serverProvider = new (class extends ServerProvider {\n      override subscribesToEvents(): boolean {\n        return false;\n      }\n    })();\n\n    // Initialize metrics handler with all required dependencies\n    Factory.metricsHandler = new MetricsHandler(\n      Factory.serverProvider,\n      Factory.channelManager,\n      null,\n    );\n\n    // Initialize class-based controllers with proper dependencies\n    Factory.eventsController = new EventsController(\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.eventsBatchController = new EventsBatchController(\n      Factory.metricsHandler,\n    );\n    Factory.channelsController = new ChannelsController(\n      Factory.metricsHandler,\n      Factory.applicationProvider,\n      Factory.channelManager,\n    );\n    Factory.channelController = new ChannelController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.metricsHandler,\n    );\n    Factory.usersTerminateController = new UsersTerminateController(\n      Factory.applicationProvider,\n      Factory.channelManager,\n      Factory.serverProvider,\n      undefined,\n    );\n  }\n\n  /**\n   * Get the channel manager instance\n   *\n   * @returns The channel manager instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getChannelManager(): ArrayChannelManager {\n    if (!Factory.channelManager) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.channelManager;\n  }\n\n  /**\n   * Get the application provider instance\n   *\n   * @returns The application provider instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getApplicationProvider(): IApplicationProvider {\n    if (!Factory.applicationProvider) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.applicationProvider;\n  }\n\n  /**\n   * Get the logger instance\n   *\n   * @returns The logger instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getLogger(): CliLogger | NullLogger {\n    if (!Factory.logger) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.logger;\n  }\n\n  /**\n   * Get the metrics handler instance\n   *\n   * @returns The metrics handler instance\n   * @throws {Error} If factory has not been initialized\n   */\n  public static getMetricsHandler(): MetricsHandler {\n    if (!Factory.metricsHandler) {\n      throw new Error(\n        \"Factory not initialized. Call Factory.initialize() first.\",\n      );\n    }\n    return Factory.metricsHandler;\n  }\n\n  /**\n   * Create a new WebSocket server instance\n   *\n   * Creates and configures an HTTP server with WebSocket support using Bun.\n   * Handles TLS/SSL configuration and protocol routing.\n   *\n   * @param host - Server host address (default: '0.0.0.0')\n   * @param port - Server port (default: '8080')\n   * @param path - URL path prefix for all routes (default: '')\n   * @param hostname - Hostname for TLS certificate resolution (optional)\n   * @param maxRequestSize - Maximum request size in bytes (default: 10000)\n   * @param options - Additional server options (default: {})\n   * @param protocol - Protocol to use ('pusher' only for now) (default: 'pusher')\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                      Used to determine TLS peer verification settings\n   * @returns The configured Bun server instance\n   *\n   * @throws {Error} If protocol is unsupported\n   *\n   * @example\n   * ```typescript\n   * const server = Factory.make('127.0.0.1', '8080', '', 'myapp.test', 10000, {}, 'pusher', 'production');\n   * console.log('Server running on port 8080');\n   * ```\n   */\n  public static make(\n    host = \"0.0.0.0\",\n    port = \"8080\",\n    path = \"\",\n    hostname?: string,\n    maxRequestSize = 10000,\n    options: HttpServerOptions = {},\n    protocol = \"pusher\",\n    environment: string = process.env.NODE_ENV || \"development\",\n  ) {\n    if (protocol !== \"pusher\") {\n      throw new Error(`Unsupported protocol [${protocol}].`);\n    }\n\n    const router = Factory.makePusherRouter(path);\n    const tlsContext = Factory.configureTls(\n      options.tls ?? {},\n      hostname,\n      environment,\n    );\n    const portNum = Number.parseInt(port, 10);\n\n    // Build Bun server options\n    const serveOptions: ServeOptions & { maxRequestBodySize?: number } = {\n      hostname: host,\n      port: portNum,\n      maxRequestBodySize: maxRequestSize,\n      fetch: async (req: Request, server: ReturnType<typeof Bun.serve>) =>\n        Factory.handleRequest(req, router, server),\n      websocket: {\n        open: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket open handler - create connection and notify Pusher server\n          const data = ws.data as WebSocketData | undefined;\n          if (!data || !data.app) {\n            console.error(\"WebSocket opened without app data\");\n            ws.close();\n            return;\n          }\n\n          try {\n            // Create WebSocket connection wrapper\n            const wsConnection = new WebSocketConnection(\n              ws as unknown as WebSocket,\n            );\n\n            // Create Reverb connection with app and origin\n            const connection = new ReverbConnection(\n              wsConnection,\n              data.app,\n              data.origin || null,\n            );\n\n            // Store connection in ws.data for later use\n            data.connection = connection;\n\n            // Notify Pusher server of new connection\n            if (Factory.pusherServer) {\n              Factory.pusherServer.open(connection);\n            }\n          } catch (error) {\n            console.error(\"Error opening WebSocket connection:\", error);\n            ws.close();\n          }\n        },\n        message: (ws: ServerWebSocket<unknown>, message: string | Buffer) => {\n          // WebSocket message handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            console.error(\"WebSocket message received without connection\");\n            return;\n          }\n\n          try {\n            const messageStr =\n              typeof message === \"string\" ? message : message.toString(\"utf-8\");\n\n            // Pass message to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.message(data.connection, messageStr);\n            }\n          } catch (error) {\n            console.error(\"Error handling WebSocket message:\", error);\n          }\n        },\n        close: (ws: ServerWebSocket<unknown>) => {\n          // WebSocket close handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Notify Pusher server of connection close\n            if (Factory.pusherServer) {\n              Factory.pusherServer.close(data.connection);\n            }\n          } catch (error) {\n            console.error(\"Error closing WebSocket connection:\", error);\n          }\n        },\n        ping: (ws: ServerWebSocket<unknown>) => {\n          // Ping handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PING frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PING,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling ping:\", error);\n          }\n        },\n        pong: (ws: ServerWebSocket<unknown>) => {\n          // Pong handler\n          const data = ws.data as WebSocketData | undefined;\n          if (!data?.connection) {\n            return;\n          }\n\n          try {\n            // Create PONG frame and pass to Pusher server\n            if (Factory.pusherServer) {\n              Factory.pusherServer.control(data.connection, {\n                opcode: FrameOpcode.PONG,\n                payload: \"\",\n                getContents: () => \"\",\n              });\n            }\n          } catch (error) {\n            console.error(\"Error handling pong:\", error);\n          }\n        },\n      },\n    };\n\n    // Add TLS configuration if present\n    if (\n      Factory.usesTls(tlsContext) &&\n      tlsContext.local_cert &&\n      tlsContext.local_pk\n    ) {\n      serveOptions.tls = {\n        cert: Bun.file(tlsContext.local_cert),\n        key: Bun.file(tlsContext.local_pk),\n      };\n    }\n\n    return Bun.serve(serveOptions);\n  }\n\n  /**\n   * Handle incoming HTTP requests and route them appropriately\n   *\n   * @param req - The incoming request\n   * @param router - The router instance\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response to send back to client\n   *\n   * @private\n   */\n  private static async handleRequest(\n    req: Request,\n    router: Router,\n    server: ReturnType<typeof Bun.serve>,\n  ): Promise<Response | undefined> {\n    const url = new URL(req.url);\n    const pathname = url.pathname;\n    const method = req.method;\n\n    const match = router.match(method, pathname);\n    if (!match) {\n      return new Response(JSON.stringify({ error: \"Not Found\" }), {\n        status: 404,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    try {\n      // Pass server to handler for WebSocket upgrade support\n      return await Promise.resolve(match.handler(req, match.params, server));\n    } catch (error) {\n      console.error(\"Route handler error:\", error);\n      return new Response(JSON.stringify({ error: \"Internal Server Error\" }), {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n  }\n\n  /**\n   * Create a new router for the Pusher protocol\n   *\n   * Sets up all routes required for Pusher protocol support.\n   * This includes WebSocket connections and HTTP API endpoints.\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Router - Configured router instance\n   *\n   * @private\n   */\n  private static makePusherRouter(path: string): Router {\n    const router = new Router();\n\n    // Set up Pusher routes with optional path prefix\n    const routes = Factory.pusherRoutes(path);\n\n    for (const route of routes) {\n      if (route.method === \"GET\") {\n        router.get(route.path, route.handler);\n      } else if (route.method === \"POST\") {\n        router.post(route.path, route.handler);\n      }\n    }\n\n    return router;\n  }\n\n  /**\n   * Generate the routes required to handle Pusher protocol requests\n   *\n   * Defines all HTTP API endpoints for:\n   * - WebSocket connections\n   * - Event triggering\n   * - Connection management\n   * - Channel information\n   * - Health checks\n   *\n   * @param path - URL path prefix for all routes\n   * @returns Array of route definitions\n   *\n   * @private\n   */\n  private static pusherRoutes(path: string): RouteDefinition[] {\n    const basePath = path || \"\";\n    const prefix = (route: string) => `${basePath}${route}`;\n\n    return [\n      {\n        method: \"GET\",\n        path: prefix(\"/app/{appKey}\"),\n        handler: Factory.handleWebSocketConnection.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/events\"),\n        handler: Factory.handleEvents.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/batch_events\"),\n        handler: Factory.handleBatchEvents.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/connections\"),\n        handler: Factory.handleConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels\"),\n        handler: Factory.handleChannels.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}\"),\n        handler: Factory.handleChannelInfo.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/apps/{appId}/channels/{channel}/users\"),\n        handler: Factory.handleChannelUsers.bind(Factory),\n      },\n      {\n        method: \"POST\",\n        path: prefix(\"/apps/{appId}/users/{userId}/terminate_connections\"),\n        handler: Factory.handleTerminateConnections.bind(Factory),\n      },\n      {\n        method: \"GET\",\n        path: prefix(\"/up\"),\n        handler: Factory.handleHealthCheck.bind(Factory),\n      },\n    ];\n  }\n\n  /**\n   * Handle WebSocket connection requests\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appKey\n   * @param server - The Bun server instance for WebSocket upgrades\n   * @returns Response with WebSocket upgrade or error, or undefined for successful upgrade\n   *\n   * @private\n   */\n  private static handleWebSocketConnection(\n    req: Request,\n    params: Record<string, string>,\n    server?: ReturnType<typeof Bun.serve>,\n  ): Response | undefined {\n    // Check if this is a WebSocket upgrade request\n    if (req.headers.get(\"upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket upgrade\", { status: 400 });\n    }\n\n    if (!server) {\n      return new Response(\"Server instance not available\", { status: 500 });\n    }\n\n    if (!Factory.appManager || !Factory.pusherServer) {\n      return new Response(\n        \"Server not initialized. Call Factory.initialize() first.\",\n        { status: 500 },\n      );\n    }\n\n    const appKey = params.appKey;\n    if (!appKey) {\n      return new Response(\"Missing app key\", { status: 400 });\n    }\n\n    // Find application by key\n    let app: Application | null = null;\n    try {\n      const provider = Factory.appManager.driver();\n      app = provider.findByKey(appKey);\n    } catch (error) {\n      console.error(\"Error finding application:\", error);\n      return new Response(\"Invalid application\", { status: 404 });\n    }\n\n    if (!app) {\n      return new Response(\"Application not found\", { status: 404 });\n    }\n\n    // Get origin from request\n    const origin = req.headers.get(\"origin\");\n\n    // Set up WebSocket data with app and origin for use in handlers\n    const wsData: WebSocketData = {\n      app,\n      origin,\n    };\n\n    // Upgrade the connection to WebSocket\n    const upgraded = server.upgrade(req, {\n      data: wsData,\n    });\n\n    if (!upgraded) {\n      return new Response(\"WebSocket upgrade failed\", { status: 500 });\n    }\n\n    // Return undefined to indicate successful upgrade (Bun requirement)\n    // The actual connection handling will happen in the websocket.open handler\n    return undefined;\n  }\n\n  /**\n   * Handle event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      // Convert Bun Request to IHttpRequest\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n\n      // Get the application\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      // Call the controller\n      const response = await Factory.eventsController.__invoke(\n        httpRequest,\n        httpConnection,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle batch event triggering\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleBatchEvents(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (\n      !Factory.eventsBatchController ||\n      !Factory.channelManager ||\n      !Factory.appManager\n    ) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const app = Factory.appManager.driver().findById(params.appId);\n      const channelManager = Factory.channelManager.for(app);\n\n      const response = await Factory.eventsBatchController.handle(\n        httpRequest,\n        httpConnection,\n        params.appId,\n        app,\n        channelManager,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling batch events:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle connection listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of connections\n   *\n   * @private\n   */\n  private static async handleConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await connectionsController(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel listing\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId\n   * @returns JSON response with list of channels\n   *\n   * @private\n   */\n  private static async handleChannels(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelsController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId) {\n      return new Response(\"Missing appId parameter\", { status: 400 });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await Factory.channelsController.__invoke(\n        httpRequest,\n        httpConnection,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channels:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel information request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with channel info\n   *\n   * @private\n   */\n  private static async handleChannelInfo(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.channelController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const response = await Factory.channelController.handle(\n        req,\n        params.appId,\n        params.channel,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel info:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle channel users listing (presence)\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and channel\n   * @returns JSON response with list of users in channel\n   *\n   * @private\n   */\n  private static async handleChannelUsers(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.channel) {\n      return new Response(\"Missing appId or channel parameter\", {\n        status: 400,\n      });\n    }\n\n    try {\n      const httpRequest = await Factory.convertToHttpRequest(req);\n      const httpConnection = Factory.createHttpConnection();\n      const response = await channelUsersController(\n        httpRequest,\n        httpConnection,\n        params.channel,\n        params.appId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling channel users:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle user connection termination\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters including appId and userId\n   * @returns JSON response with result\n   *\n   * @private\n   */\n  private static async handleTerminateConnections(\n    req: Request,\n    params: Record<string, string>,\n  ): Promise<Response> {\n    if (!Factory.usersTerminateController || !Factory.appManager) {\n      return new Response(\"Server not initialized\", { status: 500 });\n    }\n\n    if (!params.appId || !params.userId) {\n      return new Response(\"Missing appId or userId parameter\", { status: 400 });\n    }\n\n    try {\n      const response = await Factory.usersTerminateController.handle(\n        req,\n        params.appId,\n        params.userId,\n      );\n\n      return Factory.convertToResponse(response);\n    } catch (error) {\n      console.error(\"Error handling terminate connections:\", error);\n      return new Response(\n        JSON.stringify({\n          error:\n            error instanceof Error ? error.message : \"Internal server error\",\n        }),\n        { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n  }\n\n  /**\n   * Handle health check request\n   *\n   * @param req - The incoming request\n   * @param params - Route parameters (none for this endpoint)\n   * @returns Response indicating server health\n   *\n   * @private\n   */\n  private static handleHealthCheck(\n    _req: Request,\n    _params: Record<string, string>,\n  ): Response {\n    return Response.json({ health: \"OK\" }, { status: 200 });\n  }\n\n  /**\n   * Configure TLS context for the server\n   *\n   * Filters out null values and attempts to auto-detect certificates\n   * for the given hostname if not explicitly provided.\n   * Sets verify_peer to true in production environments for better security.\n   *\n   * @param context - Initial TLS context (may contain null values)\n   * @param hostname - Hostname for certificate auto-detection\n   * @param environment - The environment name (default: NODE_ENV or 'development')\n   *                     Used to determine TLS peer verification settings\n   * @returns Configured TLS context\n   *\n   * @private\n   */\n  private static configureTls(\n    context: TlsContext,\n    hostname?: string,\n    environment: string = process.env.NODE_ENV || \"development\",\n  ): TlsContext {\n    // Filter out null/undefined values\n    const filtered: TlsContext = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (value !== null && value !== undefined) {\n        filtered[key] = value;\n      }\n    }\n\n    // Try to auto-detect certificates if not provided and hostname is given\n    if (\n      !Factory.usesTls(filtered) &&\n      hostname &&\n      Certificate.exists(hostname)\n    ) {\n      const certs = Certificate.resolve(hostname);\n      if (certs) {\n        const [certPath, keyPath] = certs;\n        filtered.local_cert = certPath;\n        filtered.local_pk = keyPath;\n        // Enable peer verification in production for better security\n        filtered.verify_peer = environment === \"production\";\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Determine whether the server uses TLS\n   *\n   * Checks if TLS context has both certificate and key configured.\n   *\n   * @param context - TLS context to check\n   * @returns True if TLS is configured, false otherwise\n   *\n   * @private\n   */\n  private static usesTls(context: TlsContext): boolean {\n    return !!(context.local_cert || context.local_pk);\n  }\n\n  /**\n   * Convert Bun Request to IHttpRequest\n   *\n   * @param req - The Bun Request object\n   * @returns IHttpRequest interface\n   *\n   * @private\n   */\n  private static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\n    const url = new URL(req.url);\n    const body = req.method !== \"GET\" ? await req.text() : \"\";\n    const method = req.method;\n    // Store pathname + search for full path, but pathname only for signature verification\n    const pathWithQuery = url.pathname + url.search;\n    const pathWithoutQuery = url.pathname;\n    const host = url.host;\n\n    // Convert Headers to Record<string, string>\n    const headers: Record<string, string> = {};\n    req.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    const request: IHttpRequest & {\n      url: string;\n      httpVersion: string;\n      getSize(): number;\n    } = {\n      method,\n      path: pathWithQuery,\n      url: req.url, // Include full URL with query string for controllers to access query params\n      httpVersion: \"1.1\",\n      body,\n      getMethod(): string {\n        return method;\n      },\n      getPath(): string {\n        // Return path without query string for Pusher signature verification\n        // Pusher signatures are calculated over the path without the query string\n        return pathWithoutQuery;\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n      getSize(): number {\n        return Buffer.byteLength(body, \"utf8\");\n      },\n    };\n\n    return request;\n  }\n\n  /**\n   * Create a mock HTTP connection for controller use\n   *\n   * @returns HTTP Connection object\n   *\n   * @private\n   */\n  private static createHttpConnection(): HttpConnection {\n    return new HttpConnection({\n      stream: Math.floor(Math.random() * 1000000),\n    });\n  }\n\n  /**\n   * Convert controller Response to Bun Response\n   *\n   * @param controllerResponse - The response from the controller\n   * @returns Bun Response object\n   *\n   * @private\n   */\n  private static convertToResponse(\n    controllerResponse:\n      | HttpResponse\n      | { status?: number; content?: string | Record<string, unknown> },\n  ): Response {\n    // Check if it's our custom HttpResponse class\n    if (controllerResponse instanceof HttpResponse) {\n      const status = controllerResponse.getStatusCode();\n      const body = controllerResponse.getContent();\n      const headers = controllerResponse.getHeaders();\n\n      return new Response(body, {\n        status,\n        headers,\n      });\n    }\n\n    // Fallback for other response types\n    const status = controllerResponse.status || 200;\n    const body =\n      typeof controllerResponse.content === \"string\"\n        ? controllerResponse.content\n        : JSON.stringify(controllerResponse.content);\n\n    return new Response(body, {\n      status,\n      headers: {\n        \"Content-Type\":\n          typeof controllerResponse.content === \"string\"\n            ? \"text/plain\"\n            : \"application/json\",\n      },\n    });\n  }\n}\n"
        }
      }
    }

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint:fix`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    Checked 110 files in 41ms. No fixes applied.

    * **stderr:**

    $ biome check --write .

### Assistant

Checking for remaining lint issues and verifying the review comments. Review mentions any types, but I see unknown. Checking if the review is outdated or if there are other issues:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1`
    * **cwd:** `.`
    * **status:** pending

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1220-1234
    * **content:**

    
        return request;
      }
    
      /**
       * Create a mock HTTP connection for controller use
       *
       * @returns HTTP Connection object
       *
       * @private
       */
      private static createHttpConnection(): HttpConnection {
        return new HttpConnection({
          stream: Math.floor(Math.random() * 1000000),
        });

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    $ biome check .
    Checked 110 files in 51ms. No fixes applied.

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    $ tsc --noEmit

### Assistant

Both lint and typecheck pass. The review may be outdated. Verifying the Connection type issue by checking the actual signature:

### Tool · grep (started)

    {
      "args": {
        "pattern": "handle.*Connection",
        "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers/events-batch-controller.ts",
        "contextAfter": 3,
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_b2b4d20c-53d3-44f9-8d01-3abccaa63f7"
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": "handle.*Connection",
        "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers/events-batch-controller.ts",
        "contextAfter": 3,
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_b2b4d20c-53d3-44f9-8d01-3abccaa63f7"
      },
      "result": {
        "success": {
          "pattern": "handle.*Connection",
          "path": "/Users/tom/personal/revurb/src/protocols/pusher/http/controllers/events-batch-controller.ts",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · read (started)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git log --oneline -10`
    * **cwd:** `.`
    * **status:** pending

### Tool · read (completed)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** success
        * lines: 95-99
    * **content:**

      async handle(
        request: IHttpRequest,
        _connection: Connection,
        _appId: string,
        application: Application,

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git log --oneline -10`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    97c385e Fix Factory: remove headers property from convertToHttpRequest and properly instantiate HttpConnection
    93f9905 review: update status for deb78c1
    deb78c1 Fix review feedback: type mismatches, lint errors, and Redis pub/sub types
    7841c5e review: update status for b2a9134
    b2a9134 Fix HTTP Response handling and lint errors
    32560f8 review: update status for 6ac77c0
    6ac77c0 add: husky
    1b0fe94 Fix lint and typecheck errors from review feedback
    346dfcb review: update status for 15f7528
    15f7528 Fix lint errors: replace any types with proper types, fix non-null assertions, convert static-only class to functions

### Assistant

Checking for any types in the test files mentioned in the review:

### Tool · grep (started)

    {
      "args": {
        "pattern": ":\\s*any\\b",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_0aaf291b-4a2d-41d9-8771-98daf5193f3"
      }
    }

### Tool · grep (started)

    {
      "args": {
        "pattern": "as any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_f18172ef-86bc-4897-8799-e04abfdee07"
      }
    }

### Tool · read (started)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** pending

### Tool · read (completed)

    * **path:** `tests/unit/channels/channel.test.ts`
    * **status:** success
        * lines: 20-64
    * **content:**

    }
    
    // Mock channel connection factory
    function createMockChannelConnection(
      connection: Connection,
      data: Map<string, unknown> = new Map(),
    ): ChannelConnection {
      return {
        connection: () => connection,
        data: () => data,
      } as ChannelConnection;
    }
    
    describe("Channel", () => {
      let channel: Channel;
      let mockConnectionManager: ChannelConnectionManager;
      let mockChannelManager: ChannelManager;
      let mockLogger: ILogger;
      let connection1: Connection;
      let connection2: Connection;
      let connection3: Connection;
    
      beforeEach(() => {
        // Create mock connections
        connection1 = createMockConnection("111.111");
        connection2 = createMockConnection("222.222");
        connection3 = createMockConnection("333.333");
    
        // Create mock logger
        mockLogger = {
          info: mock(() => {}),
          error: mock(() => {}),
          message: mock(() => {}),
        } as unknown as ILogger;
    
        // Create shared connections map for the channel
        const connections = new Map<string, ChannelConnection>();
    
        // Create mock connection manager with proper state management
        mockConnectionManager = {
          for: mock((_channelName: string) => mockConnectionManager),
          add: (conn: Connection, data: Map<string, unknown>) => {
            connections.set(conn.id(), createMockChannelConnection(conn, data));
          },
          remove: (conn: Connection) => {

### Tool · grep (completed)

    {
      "args": {
        "pattern": "as any",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_f18172ef-86bc-4897-8799-e04abfdee07"
      },
      "result": {
        "success": {
          "pattern": "as any",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Tool · grep (completed)

    {
      "args": {
        "pattern": ":\\s*any\\b",
        "path": "/Users/tom/personal/revurb/tests",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_0aaf291b-4a2d-41d9-8771-98daf5193f3"
      },
      "result": {
        "success": {
          "pattern": ":\\s*any\\b",
          "path": "/Users/tom/personal/revurb/tests",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Assistant

No any types found. Lint and typecheck pass. Committing the fix:

### Tool · update Todos (started)

    {
      "args": {
        "todos": [
          {
            "id": "1",
            "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064967368",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_IN_PROGRESS",
            "createdAt": "1763064925831",
            "updatedAt": "1763064967368",
            "dependencies": []
          }
        ],
        "merge": true
      }
    }

### Tool · update Todos (completed)

    {
      "args": {
        "todos": [
          {
            "id": "1",
            "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064967368",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_IN_PROGRESS",
            "createdAt": "1763064925831",
            "updatedAt": "1763064967368",
            "dependencies": []
          }
        ],
        "merge": true
      },
      "result": {
        "success": {
          "todos": [
            {
              "id": "1",
              "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064967368",
              "dependencies": []
            },
            {
              "id": "2",
              "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "3",
              "content": "Fix lint errors - replace any types with concrete types in test files",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            },
            {
              "id": "4",
              "content": "Run typecheck and lint to verify fixes",
              "status": "TODO_STATUS_IN_PROGRESS",
              "createdAt": "1763064925831",
              "updatedAt": "1763064967368",
              "dependencies": []
            },
            {
              "id": "5",
              "content": "Commit and push changes",
              "status": "TODO_STATUS_PENDING",
              "createdAt": "1763064925831",
              "updatedAt": "1763064925831",
              "dependencies": []
            }
          ],
          "totalCount": 5
        }
      }
    }

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git add src/servers/reverb/factory.ts && git commit -m "Fix convertToHttpRequest return type formatting"`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git add src/servers/reverb/factory.ts && git commit -m "Fix convertToHttpRequest return type formatting"`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    [main dc3fa1c] Fix convertToHttpRequest return type formatting
     1 file changed, 7 insertions(+), 1 deletion(-)

    * **stderr:**

    $ biome check --write .
    Checked 110 files in 44ms. No fixes applied.
    $ tsc --noEmit

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stderr:**

    Everything up-to-date

### Assistant

Checking git status and verifying the review issues. Review mentions Connection type issues; verifying the current state:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git status`
    * **cwd:** `.`
    * **status:** pending

### Tool · read (started)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** pending

### Tool · sem Search (started)

    {
      "args": {
        "query": "Where is HttpConnection class defined and what methods does it have?",
        "targetDirectories": [],
        "explanation": ""
      }
    }

### Tool · read (completed)

    * **path:** `src/protocols/pusher/http/controllers/events-batch-controller.ts`
    * **status:** success
        * lines: 1-10
    * **content:**

    import type { Application } from "../../../../application";
    import type { Connection } from "../../../../servers/reverb/http/connection";
    import { Response } from "../../../../servers/reverb/http/response";
    import type { IHttpRequest } from "../../../../servers/reverb/http/router";
    import type { ChannelManager } from "../../contracts/channel-manager";
    import { dispatch } from "../../event-dispatcher";
    import type { MetricsHandler } from "../../metrics-handler";
    
    /**
     * Batch item structure

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git status`
    * **cwd:** `.`
    * **status:** failure
    * **details:**

    {
      "command": "cd /Users/tom/personal/revurb && git status",
      "workingDirectory": "",
      "exitCode": -1,
      "signal": "",
      "stdout": "On branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   scripts/ralph/sync.sh\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tnotes/2025-11-13-1300-review-fixes.md\n\tspecs/logs/codex-2025-11-13-1200.md\n\tspecs/logs/composer-2025-11-13-1208.md\n\tspecs/logs/composer-2025-11-13-1213.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n",
      "stderr": "",
      "executionTime": 0
    }

### Tool · sem Search (completed)

    {
      "args": {
        "query": "Where is HttpConnection class defined and what methods does it have?",
        "targetDirectories": [],
        "explanation": ""
      },
      "result": {
        "success": {
          "results": "<search_result path=\"src/servers/reverb/http/connection.ts\" startLine=\"1\" endLine=\"128\">\n     1|/**\n     2| * HTTP Connection Wrapper\n     3| *\n     4| * Wraps an underlying socket/connection and manages state for HTTP message handling.\n     5| * This class is used by the Reverb server to manage HTTP connections before they're\n     6| * upgraded to WebSocket connections.\n     7| */\n     8|export class Connection {\n     9|  private id: number;\n    10|  private connected = false;\n    11|  private _buffer = \"\";\n    12|\n    13|  /**\n    14|   * Create a new HTTP connection instance.\n    15|   *\n    16|   * @param connection - The underlying socket/connection object\n    17|   */\n    18|  constructor(\n    19|    private readonly connection: {\n    20|      stream?: unknown;\n    21|      write?: (data: string | Uint8Array) => void;\n    22|      end?: () => void;\n    23|    },\n    24|  ) {\n    25|    this.id = Number(connection.stream) || 0;\n    26|  }\n    27|\n    28|  /**\n    29|   * Get the connection ID.\n    30|   *\n    31|   * @returns The connection ID as a number\n    32|   */\n   ...\n   128|}\n</search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Http/Connection.php\" startLine=\"1\" endLine=\"115\">\n     1|<?php\n     2|\n     3|namespace Laravel\\Reverb\\Servers\\Reverb\\Http;\n     4|\n     5|use BadMethodCallException;\n     6|use React\\Socket\\ConnectionInterface;\n     7|\n     8|class Connection\n     9|{\n    10|    /**\n    11|     * Connection ID.\n    12|     */\n    13|    protected int $id;\n    14|\n    15|    /**\n    16|     * Connection status.\n    17|     */\n    18|    protected bool $connected = false;\n    19|\n    20|    /**\n    21|     * Connection buffer.\n    22|     */\n    23|    protected string $buffer = '';\n    24|\n    25|    /**\n    26|     * Create a new connection instance.\n    27|     */\n    28|    public function __construct(protected ConnectionInterface $connection)\n    29|    {\n    30|        $this->id = (int) $connection->stream;\n    31|    }\n    32|\n    33|    /**\n    34|     * Return the connection ID.\n    35|     */\n    36|    public function id(): int\n    37|    {\n    38|        return $this->id;\n    39|    }\n    40|\n    41|    /**\n    42|     * Mark the connection as connected.\n    43|     */\n    44|    public function connect(): void\n    45|    {\n    46|        $this->connected = true;\n    47|    }\n    48|\n    49|    /**\n    50|     * Determine whether the connection is connected.\n    51|     */\n    52|    public function isConnected(): bool\n    53|    {\n    54|        return $this->connected;\n    55|    }\n    56|\n    57|    /**\n    58|     * Get the HTTP message buffer.\n    59|     */\n    60|    public function buffer(): string\n    61|    {\n    62|        return $this->buffer;\n    63|    }\n    64|\n    65|    /**\n    66|     * Determine whether the connection has an HTTP message buffer set.\n    67|     */\n    68|    public function hasBuffer(): bool\n    69|    {\n    70|        return $this->buffer !== '';\n    71|    }\n    72|\n    73|    /**\n    74|     * Return the HTTP message buffer length.\n    75|     */\n    76|    public function bufferLength(): int\n    77|    {\n    78|        return strlen($this->buffer);\n    79|    }\n    80|\n    81|    /**\n    82|     * Append to the HTTP message buffer.\n    83|     */\n    84|    public function appendToBuffer($message): void\n    85|    {\n    86|        $this->buffer .= $message;\n    87|    }\n    88|\n    89|    /**\n    90|     * Clear the HTTP message buffer.\n    91|     */\n    92|    public function clearBuffer(): void\n    93|    {\n    94|        $this->buffer = '';\n    95|    }\n    96|\n    97|    /**\n    98|     * Send a message to the connection.\n    99|     */\n   100|    public function send($data): self\n   101|    {\n   102|        $this->connection->write($data);\n   103|\n   104|        return $this;\n   105|    }\n   106|\n   107|    /**\n   108|     * Close the connection.\n   109|     */\n   110|    public function close(): self\n   111|    {\n   112|        $this->connection->end();\n   113|\n   114|        return $this;\n   115|    }\n</search_result>\n<search_result path=\"src/connection.ts\" startLine=\"2\" endLine=\"103\">\n     2|import type { FrameOpcode } from \"./contracts/websocket-connection\";\n     3|import { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";\n     4|import { MessageSent } from \"./events/message-sent\";\n     5|\n     6|/**\n     7| * Connection Implementation\n     8| *\n     9| * Concrete implementation of the Connection contract that wraps a WebSocket\n    10| * connection with application context and state management.\n    11| *\n    12| * This class implements the Pusher-compatible connection wrapper, handling:\n    13| * - Connection identification and normalization\n    14| * - Message sending with event dispatching\n    15| * - Control frame management (PING/PONG)\n    16| * - Connection lifecycle and termination\n    17| *\n    18| * The connection maintains state through the abstract base class:\n    19| * - lastSeenAt: Timestamp tracking for activity monitoring\n    20| * - hasBeenPinged: Ping state for stale connection detection\n    21| * - usesControlFrames: Whether the connection uses control frames\n    22| *\n    23| * @see Connection contract for state machine documentation\n    24| */\n    25|export class Connection extends ConnectionContract {\n    26|  /**\n    27|   * The normalized socket ID.\n    28|   *\n    29|   * Cached socket ID in Pusher format (\"number.number\").\n    30|   * Generated once on first access and reused for connection lifetime.\n    31|   *\n    32|   * @private\n    33|   */\n    34|  private _id: string | null = null;\n    35|\n    36|  /**\n    37|   * Get the raw socket connection identifier.\n    38|   *\n    39|   * Returns the underlying WebSocket connection's identifier as a string.\n    40|   * This is the raw transport-level identifier, not the normalized socket ID.\n    41|   *\n    42|   * @returns The raw connection identifier as a string\n    43|   */\n    44|  identifier(): string {\n    45|    return String(this.connection.id());\n    46|  }\n    47|\n    48|  /**\n    49|   * Get the normalized socket ID.\n    50|   *\n    51|   * Returns a Pusher-compatible socket ID in the format \"number.number\".\n    52|   * The ID is generated once and cached for the lifetime of the connection.\n    53|   *\n    54|   * @returns The normalized socket ID (e.g., \"123456789.987654321\")\n    55|   */\n   ...\n   103|}\n</search_result>\n<search_result path=\"src/contracts/connection.ts\" startLine=\"2\" endLine=\"88\">\n     2|import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";\n     3|\n     4|/**\n     5| * Connection State Machine\n     6| *\n     7| * The Connection class tracks connection state using a timestamp-based state machine:\n     8| *\n     9| * State Transitions:\n    10| * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n    11| * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n    12| * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n    13| *\n    14| * State Determination:\n    15| * - isActive(): time() < lastSeenAt + app.pingInterval()\n    16| * - isInactive(): !isActive()\n    17| * - isStale(): isInactive() && hasBeenPinged\n    18| *\n    19| * Lifecycle:\n    20| * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n    21| * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n    22| * 3. No activity for pingInterval → isInactive() = true\n    23| * 4. Ping sent → ping() → hasBeenPinged = true\n    24| * 5. Pong received → pong() → hasBeenPinged = false\n    25| * 6. No response after ping → isStale() = true → connection pruned\n    26| *\n    27| * Timestamps:\n    28| * - All timestamps use SECONDS (not milliseconds)\n    29| * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n    30| * - This matches PHP's time() function behavior\n    31| */\n    32|\n    33|/**\n    34| * Connection Abstract Class\n    35| *\n    36| * Application-aware connection wrapper that manages WebSocket connection state,\n    37| * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n    38| * activity tracking, and state management.\n    39| *\n    40| * Key Responsibilities:\n    41| * - Wrap WebSocketConnection with application context\n    42| * - Track connection activity via lastSeenAt timestamp\n    43| * - Implement state machine (Active/Inactive/Stale)\n    44| * - Manage ping/pong state for connection health\n    45| * - Generate normalized socket IDs\n    46| * - Provide connection lifecycle methods\n    47| *\n    48| * @abstract\n    49| *\n    50| * @example\n    51| * ```typescript\n    52| * class ReverbConnection extends Connection {\n    53| *   identifier(): string {\n    54| *     return String(this.connection.id());\n    55| *   }\n    56| *\n    57| *   id(): string {\n    58| *     if (!this._id) {\n    59| *       this._id = this.generateId();\n    60| *     }\n    61| *     return this._id;\n    62| *   }\n    63| *\n    64| *   send(message: string): void {\n    65| *     this.connection.send(message);\n    66| *     // Dispatch MessageSent event\n    67| *   }\n    68| *\n    69| *   control(type: FrameOpcode = FrameOpcode.PING): void {\n    70| *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n    71| *   }\n    72| *\n    73| *   terminate(): void {\n    74| *     this.connection.close();\n    75| *   }\n    76| * }\n    77| * ```\n    78| */\n    79|export abstract class Connection {\n    80|  /**\n    81|   * The last time the connection was seen (in seconds, not milliseconds).\n    82|   *\n    83|   * Initialized to current time when connection is created.\n    84|   * Updated via touch() when activity is detected.\n    85|   * Used to determine connection state (active/inactive/stale).\n    86|   *\n    87|   * @protected\n    88|   */\n</search_result>\n<search_result path=\"src/servers/reverb/connection.ts\" startLine=\"1\" endLine=\"277\">\n     1|import type { WebSocket } from \"bun\";\n     2|import type {\n     3|  Frame,\n     4|  IWebSocketConnection,\n     5|} from \"../../contracts/websocket-connection\";\n     6|\n     7|/**\n     8| * WebSocket Connection Implementation\n     9| *\n    10| * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\n    11| * This class handles WebSocket frame operations, message buffering for fragmented messages,\n    12| * and control frame handling according to RFC 6455.\n    13| *\n    14| * Key responsibilities:\n    15| * - Provide unique connection identification\n    16| * - Send text/binary messages over the WebSocket\n    17| * - Send and handle control frames (PING, PONG, CLOSE)\n    18| * - Manage connection lifecycle with proper cleanup\n    19| *\n    20| * Note: Bun's WebSocket handles frame framing automatically, so we focus on\n    21| * providing a consistent API for message handling and control frames.\n    22| */\n    23|export class Connection implements IWebSocketConnection {\n    24|  /**\n    25|   * Unique connection identifier.\n    26|   */\n    27|  private connectionId: string;\n    28|\n    29|  /**\n    30|   * Handler for complete messages.\n    31|   */\n    32|  private onMessageHandler?: (message: string | Buffer) => void;\n    33|\n    34|  /**\n    35|   * Handler for connection close events.\n    36|   */\n    37|  private _onCloseHandler?: () => void;\n    38|\n    39|  /**\n    40|   * Maximum allowed message size in bytes.\n    41|   */\n    42|  private maxMessageSize?: number;\n    43|\n    44|  /**\n    45|   * Create a new WebSocket connection instance.\n    46|   *\n    47|   * @param socket - The Bun WebSocket instance\n    48|   */\n    49|  constructor(private socket: WebSocket) {\n    50|    // Generate a unique connection ID using the socket's internal data\n    51|    this.connectionId = this.generateConnectionId();\n    52|    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\n    53|    // not on individual socket objects. We don't need setupHandlers() here.\n    54|  }\n    55|\n    56|  /**\n    57|   * Generate a unique connection identifier.\n    58|   * Uses the socket's remoteAddress and a timestamp for uniqueness.\n    59|   */\n   ...\n   277|}\n</search_result>\n\n<search_result path=\"src/servers/reverb/factory.ts\" showSignaturesOnly=\"true\" startLine=\"189\" endLine=\"1278\">\n  190|export class Factory {\n</search_result>\n<search_result path=\"reverb/src/contracts/Connection.php\" endLine=\"100\"></search_result>\n<search_result path=\"src/contracts/websocket-connection.ts\" startLine=\"49\" endLine=\"167\"></search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Connection.php\" endLine=\"81\"></search_result>\n<search_result path=\"reverb/src/Servers/Reverb/Http/Server.php\" endLine=\"79\"></search_result>\n<search_result path=\"notes/2025-11-13-1300-review-fixes.md\" endLine=\"37\"></search_result>\n<search_result path=\"specs/review.md\" endLine=\"6\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"10291\" endLine=\"10307\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"15945\" endLine=\"15961\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-1150.md\" startLine=\"5348\" endLine=\"5384\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"10956\" endLine=\"10972\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-1150.md\" startLine=\"5307\" endLine=\"5326\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"12846\" endLine=\"12863\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-1150.md\" startLine=\"1384\" endLine=\"1415\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-1150.md\" startLine=\"2196\" endLine=\"2213\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"13969\" endLine=\"13986\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-12-2308.md\" startLine=\"10669\" endLine=\"10726\"></search_result>\n<search_result path=\"specs/logs/composer-2025-11-13-1150.md\" startLine=\"5703\" endLine=\"5766\"></search_result>",
          "codeResults": [
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/http/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 127,
                    "column": 1
                  }
                },
                "contents": "/**\n * HTTP Connection Wrapper\n *\n * Wraps an underlying socket/connection and manages state for HTTP message handling.\n * This class is used by the Reverb server to manage HTTP connections before they're\n * upgraded to WebSocket connections.\n */\nexport class Connection {\n  private id: number;\n  private connected = false;\n  private _buffer = \"\";\n\n  /**\n   * Create a new HTTP connection instance.\n   *\n   * @param connection - The underlying socket/connection object\n   */\n  constructor(\n    private readonly connection: {\n      stream?: unknown;\n      write?: (data: string | Uint8Array) => void;\n      end?: () => void;\n    },\n  ) {\n    this.id = Number(connection.stream) || 0;\n  }\n\n  /**\n   * Get the connection ID.\n   *\n   * @returns The connection ID as a number\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": " * HTTP Connection Wrapper",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": " * Wraps an underlying socket/connection and manages state for HTTP message handling.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * This class is used by the Reverb server to manage HTTP connections before they're",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " * upgraded to WebSocket connections.",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection {",
                    "lineNumber": 8,
                    "isSignature": true
                  },
                  {
                    "text": "  private id: number;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "  private connected = false;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "  private _buffer = \"\";",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new HTTP connection instance.",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The underlying socket/connection object",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "    private readonly connection: {",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "      stream?: unknown;",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "      write?: (data: string | Uint8Array) => void;",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "      end?: () => void;",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    },",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    this.id = Number(connection.stream) || 0;",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the connection ID.",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The connection ID as a number",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 128,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.4495292901992798
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Http/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 116,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Servers\\Reverb\\Http;\n\nuse BadMethodCallException;\nuse React\\Socket\\ConnectionInterface;\n\nclass Connection\n{\n    /**\n     * Connection ID.\n     */\n    protected int $id;\n\n    /**\n     * Connection status.\n     */\n    protected bool $connected = false;\n\n    /**\n     * Connection buffer.\n     */\n    protected string $buffer = '';\n\n    /**\n     * Create a new connection instance.\n     */\n    public function __construct(protected ConnectionInterface $connection)\n    {\n        $this->id = (int) $connection->stream;\n    }\n\n    /**\n     * Return the connection ID.\n     */\n    public function id(): int\n    {\n        return $this->id;\n    }\n\n    /**\n     * Mark the connection as connected.\n     */\n    public function connect(): void\n    {\n        $this->connected = true;\n    }\n\n    /**\n     * Determine whether the connection is connected.\n     */\n    public function isConnected(): bool\n    {\n        return $this->connected;\n    }\n\n    /**\n     * Get the HTTP message buffer.\n     */\n    public function buffer(): string\n    {\n        return $this->buffer;\n    }\n\n    /**\n     * Determine whether the connection has an HTTP message buffer set.\n     */\n    public function hasBuffer(): bool\n    {\n        return $this->buffer !== '';\n    }\n\n    /**\n     * Return the HTTP message buffer length.\n     */\n    public function bufferLength(): int\n    {\n        return strlen($this->buffer);\n    }\n\n    /**\n     * Append to the HTTP message buffer.\n     */\n    public function appendToBuffer($message): void\n    {\n        $this->buffer .= $message;\n    }\n\n    /**\n     * Clear the HTTP message buffer.\n     */\n    public function clearBuffer(): void\n    {\n        $this->buffer = '';\n    }\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send($data): self\n    {\n        $this->connection->write($data);\n\n        return $this;\n    }\n\n    /**\n     * Close the connection.\n     */\n    public function close(): self\n    {\n        $this->connection->end();\n\n        return $this;\n    }",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Servers\\Reverb\\Http;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use BadMethodCallException;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\Socket\\ConnectionInterface;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "class Connection",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection ID.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "    protected int $id;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection status.",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "    protected bool $connected = false;",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "     * Connection buffer.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    protected string $buffer = '';",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new connection instance.",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(protected ConnectionInterface $connection)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->id = (int) $connection->stream;",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     * Return the connection ID.",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    public function id(): int",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->id;",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as connected.",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "    public function connect(): void",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connected = true;",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "     * Determine whether the connection is connected.",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    public function isConnected(): bool",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->connected;",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the HTTP message buffer.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "    public function buffer(): string",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->buffer;",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "     * Determine whether the connection has an HTTP message buffer set.",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "    public function hasBuffer(): bool",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->buffer !== '';",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "     * Return the HTTP message buffer length.",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    public function bufferLength(): int",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "        return strlen($this->buffer);",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "     * Append to the HTTP message buffer.",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "    public function appendToBuffer($message): void",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer .= $message;",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "     * Clear the HTTP message buffer.",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "    public function clearBuffer(): void",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer = '';",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send($data): self",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->write($data);",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this;",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "     * Close the connection.",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "    public function close(): self",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->end();",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this;",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 115,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.4490568935871124
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 74
                  },
                  "endPosition": {
                    "line": 102,
                    "column": 1
                  }
                },
                "contents": "import type { FrameOpcode } from \"./contracts/websocket-connection\";\nimport { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";\nimport { MessageSent } from \"./events/message-sent\";\n\n/**\n * Connection Implementation\n *\n * Concrete implementation of the Connection contract that wraps a WebSocket\n * connection with application context and state management.\n *\n * This class implements the Pusher-compatible connection wrapper, handling:\n * - Connection identification and normalization\n * - Message sending with event dispatching\n * - Control frame management (PING/PONG)\n * - Connection lifecycle and termination\n *\n * The connection maintains state through the abstract base class:\n * - lastSeenAt: Timestamp tracking for activity monitoring\n * - hasBeenPinged: Ping state for stale connection detection\n * - usesControlFrames: Whether the connection uses control frames\n *\n * @see Connection contract for state machine documentation\n */\nexport class Connection extends ConnectionContract {\n  /**\n   * The normalized socket ID.\n   *\n   * Cached socket ID in Pusher format (\"number.number\").\n   * Generated once on first access and reused for connection lifetime.\n   *\n   * @private\n   */\n  private _id: string | null = null;\n\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * Returns the underlying WebSocket connection's identifier as a string.\n   * This is the raw transport-level identifier, not the normalized socket ID.\n   *\n   * @returns The raw connection identifier as a string\n   */\n  identifier(): string {\n    return String(this.connection.id());\n  }\n\n  /**\n   * Get the normalized socket ID.\n   *\n   * Returns a Pusher-compatible socket ID in the format \"number.number\".\n   * The ID is generated once and cached for the lifetime of the connection.\n   *\n   * @returns The normalized socket ID (e.g., \"123456789.987654321\")\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { FrameOpcode } from \"./contracts/websocket-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "import { FrameOpcode as FrameOpcodeEnum } from \"./contracts/websocket-connection\";",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "import { MessageSent } from \"./events/message-sent\";",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Implementation",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * Concrete implementation of the Connection contract that wraps a WebSocket",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * connection with application context and state management.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * This class implements the Pusher-compatible connection wrapper, handling:",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection identification and normalization",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * - Message sending with event dispatching",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Control frame management (PING/PONG)",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Connection lifecycle and termination",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * The connection maintains state through the abstract base class:",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * - lastSeenAt: Timestamp tracking for activity monitoring",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * - hasBeenPinged: Ping state for stale connection detection",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * - usesControlFrames: Whether the connection uses control frames",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * @see Connection contract for state machine documentation",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection extends ConnectionContract {",
                    "lineNumber": 25,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "   * The normalized socket ID.",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "   * Cached socket ID in Pusher format (\"number.number\").",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generated once on first access and reused for connection lifetime.",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  private _id: string | null = null;",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns the underlying WebSocket connection's identifier as a string.",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is the raw transport-level identifier, not the normalized socket ID.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The raw connection identifier as a string",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  identifier(): string {",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "    return String(this.connection.id());",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the normalized socket ID.",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns a Pusher-compatible socket ID in the format \"number.number\".",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "   * The ID is generated once and cached for the lifetime of the connection.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The normalized socket ID (e.g., \"123456789.987654321\")",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 103,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.40115809440612793
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 50
                  },
                  "endPosition": {
                    "line": 344,
                    "column": 0
                  }
                },
                "contents": "import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";\n\n/**\n * Connection State Machine\n *\n * The Connection class tracks connection state using a timestamp-based state machine:\n *\n * State Transitions:\n * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\n * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\n * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\n *\n * State Determination:\n * - isActive(): time() < lastSeenAt + app.pingInterval()\n * - isInactive(): !isActive()\n * - isStale(): isInactive() && hasBeenPinged\n *\n * Lifecycle:\n * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\n * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\n * 3. No activity for pingInterval → isInactive() = true\n * 4. Ping sent → ping() → hasBeenPinged = true\n * 5. Pong received → pong() → hasBeenPinged = false\n * 6. No response after ping → isStale() = true → connection pruned\n *\n * Timestamps:\n * - All timestamps use SECONDS (not milliseconds)\n * - Use Math.floor(Date.now() / 1000) to get current time in seconds\n * - This matches PHP's time() function behavior\n */\n\n/**\n * Connection Abstract Class\n *\n * Application-aware connection wrapper that manages WebSocket connection state,\n * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\n * activity tracking, and state management.\n *\n * Key Responsibilities:\n * - Wrap WebSocketConnection with application context\n * - Track connection activity via lastSeenAt timestamp\n * - Implement state machine (Active/Inactive/Stale)\n * - Manage ping/pong state for connection health\n * - Generate normalized socket IDs\n * - Provide connection lifecycle methods\n *\n * @abstract\n *\n * @example\n * ```typescript\n * class ReverbConnection extends Connection {\n *   identifier(): string {\n *     return String(this.connection.id());\n *   }\n *\n *   id(): string {\n *     if (!this._id) {\n *       this._id = this.generateId();\n *     }\n *     return this._id;\n *   }\n *\n *   send(message: string): void {\n *     this.connection.send(message);\n *     // Dispatch MessageSent event\n *   }\n *\n *   control(type: FrameOpcode = FrameOpcode.PING): void {\n *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\n *   }\n *\n *   terminate(): void {\n *     this.connection.close();\n *   }\n * }\n * ```\n */\nexport abstract class Connection {\n  /**\n   * The last time the connection was seen (in seconds, not milliseconds).\n   *\n   * Initialized to current time when connection is created.\n   * Updated via touch() when activity is detected.\n   * Used to determine connection state (active/inactive/stale).\n   *\n   * @protected\n   */",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { FrameOpcode, IWebSocketConnection } from \"./websocket-connection\";",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection State Machine",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": " * The Connection class tracks connection state using a timestamp-based state machine:",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " * State Transitions:",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * State Determination:",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - isActive(): time() < lastSeenAt + app.pingInterval()",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - isInactive(): !isActive()",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - isStale(): isInactive() && hasBeenPinged",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " * Lifecycle:",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " * 3. No activity for pingInterval → isInactive() = true",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": " * 4. Ping sent → ping() → hasBeenPinged = true",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": " * 5. Pong received → pong() → hasBeenPinged = false",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": " * 6. No response after ping → isStale() = true → connection pruned",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": " * Timestamps:",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": " * - All timestamps use SECONDS (not milliseconds)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": " * - Use Math.floor(Date.now() / 1000) to get current time in seconds",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": " * - This matches PHP's time() function behavior",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": " * Connection Abstract Class",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": " * Application-aware connection wrapper that manages WebSocket connection state,",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": " * tracking, and lifecycle. Extends raw WebSocketConnection with application context,",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": " * activity tracking, and state management.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Responsibilities:",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": " * - Wrap WebSocketConnection with application context",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": " * - Track connection activity via lastSeenAt timestamp",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": " * - Implement state machine (Active/Inactive/Stale)",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage ping/pong state for connection health",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": " * - Generate normalized socket IDs",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide connection lifecycle methods",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": " * @abstract",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": " * class ReverbConnection extends Connection {",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " *   identifier(): string {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " *     return String(this.connection.id());",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " *   id(): string {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *     if (!this._id) {",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " *       this._id = this.generateId();",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " *     }",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " *     return this._id;",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " *   send(message: string): void {",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send(message);",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " *     // Dispatch MessageSent event",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " *   control(type: FrameOpcode = FrameOpcode.PING): void {",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " *   terminate(): void {",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " *     this.connection.close();",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " *   }",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * }",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "export abstract class Connection {",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * The last time the connection was seen (in seconds, not milliseconds).",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initialized to current time when connection is created.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Updated via touch() when activity is detected.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * Used to determine connection state (active/inactive/stale).",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 88,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3853467106819153
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 276,
                    "column": 1
                  }
                },
                "contents": "import type { WebSocket } from \"bun\";\nimport type {\n  Frame,\n  IWebSocketConnection,\n} from \"../../contracts/websocket-connection\";\n\n/**\n * WebSocket Connection Implementation\n *\n * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\n * This class handles WebSocket frame operations, message buffering for fragmented messages,\n * and control frame handling according to RFC 6455.\n *\n * Key responsibilities:\n * - Provide unique connection identification\n * - Send text/binary messages over the WebSocket\n * - Send and handle control frames (PING, PONG, CLOSE)\n * - Manage connection lifecycle with proper cleanup\n *\n * Note: Bun's WebSocket handles frame framing automatically, so we focus on\n * providing a consistent API for message handling and control frames.\n */\nexport class Connection implements IWebSocketConnection {\n  /**\n   * Unique connection identifier.\n   */\n  private connectionId: string;\n\n  /**\n   * Handler for complete messages.\n   */\n  private onMessageHandler?: (message: string | Buffer) => void;\n\n  /**\n   * Handler for connection close events.\n   */\n  private _onCloseHandler?: () => void;\n\n  /**\n   * Maximum allowed message size in bytes.\n   */\n  private maxMessageSize?: number;\n\n  /**\n   * Create a new WebSocket connection instance.\n   *\n   * @param socket - The Bun WebSocket instance\n   */\n  constructor(private socket: WebSocket) {\n    // Generate a unique connection ID using the socket's internal data\n    this.connectionId = this.generateConnectionId();\n    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\n    // not on individual socket objects. We don't need setupHandlers() here.\n  }\n\n  /**\n   * Generate a unique connection identifier.\n   * Uses the socket's remoteAddress and a timestamp for uniqueness.\n   */\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "import type { WebSocket } from \"bun\";",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "import type {",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "  Frame,",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "  IWebSocketConnection,",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "} from \"../../contracts/websocket-connection\";",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "/**",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocket Connection Implementation",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": " * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": " * This class handles WebSocket frame operations, message buffering for fragmented messages,",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": " * and control frame handling according to RFC 6455.",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": " * Key responsibilities:",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide unique connection identification",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send text/binary messages over the WebSocket",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send and handle control frames (PING, PONG, CLOSE)",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": " * - Manage connection lifecycle with proper cleanup",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": " * Note: Bun's WebSocket handles frame framing automatically, so we focus on",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": " * providing a consistent API for message handling and control frames.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "export class Connection implements IWebSocketConnection {",
                    "lineNumber": 23,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "   * Unique connection identifier.",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  private connectionId: string;",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for complete messages.",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  private onMessageHandler?: (message: string | Buffer) => void;",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "   * Handler for connection close events.",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "  private _onCloseHandler?: () => void;",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "   * Maximum allowed message size in bytes.",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "  private maxMessageSize?: number;",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new WebSocket connection instance.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param socket - The Bun WebSocket instance",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(private socket: WebSocket) {",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "    // Generate a unique connection ID using the socket's internal data",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    this.connectionId = this.generateConnectionId();",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    // not on individual socket objects. We don't need setupHandlers() here.",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "   * Generate a unique connection identifier.",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "   * Uses the socket's remoteAddress and a timestamp for uniqueness.",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 277,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.36424198746681213
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/servers/reverb/factory.ts",
                "range": {
                  "startPosition": {
                    "line": 189,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1278,
                    "column": 1
                  }
                },
                "contents": "export class Factory {\nprivate static async convertToHttpRequest(\n    req: Request,\n  ): Promise<\n    IHttpRequest & { url: string; httpVersion: string; getSize(): number }\n  > {\nconst request: IHttpRequest & {\n      url: string;\n      httpVersion: string;\n      getSize(): number;\n    } = {\ngetPath(): string {\n\n      },\n      getHost(): string {\n        return host;\n      },\n      getHeader(name: string): string | undefined {\n        return headers[name.toLowerCase()];\n      },\n      getHeaders(): Record<string, string> {\n        return { ...headers };\n      },\n      getUri(): { path: string; host: string } {\n        return { path: pathWithoutQuery, host };\n      },\n      getSize(): number {\n        return Buffer.byteLength(body, \"utf8\");\n      },\n    };\n\n    return request;\n  }\n\n  /**\n   * Create a mock HTTP connection for controller use\n   *\n   * @returns HTTP Connection object\n   *\n   * @private\n   */\n  private static createHttpConnection(): HttpConnection {\n    return new HttpConnection({\n      stream: Math.floor(Math.random() * 1000000),\n    });\n  }\n\n  /**\n   * Convert controller Response to Bun Response\n   *\n   * @param controllerResponse - The response from the controller\n   * @returns Bun Response object\n   *\n   * @private\n   */\n  private static convertToResponse(\n    controllerResponse:\n      | HttpResponse\n      | { status?: number; content?: string | Record<string, unknown> },\n  ): Response {\n    // Check if it's our custom HttpResponse class\n    if (controllerResponse instanceof HttpResponse) {\n      const status = controllerResponse.getStatusCode();\n  }\n}",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 184,
                        "column": 8
                      }
                    },
                    {
                      "startPosition": {
                        "line": 184,
                        "column": 8
                      },
                      "endPosition": {
                        "line": 185,
                        "column": 3
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export class Factory {",
                    "lineNumber": 190,
                    "isSignature": true
                  },
                  {
                    "text": "private static async convertToHttpRequest(",
                    "lineNumber": 1167,
                    "isSignature": false
                  },
                  {
                    "text": "    req: Request,",
                    "lineNumber": 1168,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Promise<",
                    "lineNumber": 1169,
                    "isSignature": false
                  },
                  {
                    "text": "    IHttpRequest & { url: string; httpVersion: string; getSize(): number }",
                    "lineNumber": 1170,
                    "isSignature": false
                  },
                  {
                    "text": "  > {",
                    "lineNumber": 1171,
                    "isSignature": false
                  },
                  {
                    "text": "const request: IHttpRequest & {",
                    "lineNumber": 1186,
                    "isSignature": false
                  },
                  {
                    "text": "      url: string;",
                    "lineNumber": 1187,
                    "isSignature": false
                  },
                  {
                    "text": "      httpVersion: string;",
                    "lineNumber": 1188,
                    "isSignature": false
                  },
                  {
                    "text": "      getSize(): number;",
                    "lineNumber": 1189,
                    "isSignature": false
                  },
                  {
                    "text": "    } = {",
                    "lineNumber": 1190,
                    "isSignature": false
                  },
                  {
                    "text": "getPath(): string {",
                    "lineNumber": 1199,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1202,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1203,
                    "isSignature": false
                  },
                  {
                    "text": "      getHost(): string {",
                    "lineNumber": 1204,
                    "isSignature": false
                  },
                  {
                    "text": "        return host;",
                    "lineNumber": 1205,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1206,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeader(name: string): string | undefined {",
                    "lineNumber": 1207,
                    "isSignature": false
                  },
                  {
                    "text": "        return headers[name.toLowerCase()];",
                    "lineNumber": 1208,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1209,
                    "isSignature": false
                  },
                  {
                    "text": "      getHeaders(): Record<string, string> {",
                    "lineNumber": 1210,
                    "isSignature": false
                  },
                  {
                    "text": "        return { ...headers };",
                    "lineNumber": 1211,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1212,
                    "isSignature": false
                  },
                  {
                    "text": "      getUri(): { path: string; host: string } {",
                    "lineNumber": 1213,
                    "isSignature": false
                  },
                  {
                    "text": "        return { path: pathWithoutQuery, host };",
                    "lineNumber": 1214,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1215,
                    "isSignature": false
                  },
                  {
                    "text": "      getSize(): number {",
                    "lineNumber": 1216,
                    "isSignature": false
                  },
                  {
                    "text": "        return Buffer.byteLength(body, \"utf8\");",
                    "lineNumber": 1217,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1218,
                    "isSignature": false
                  },
                  {
                    "text": "    };",
                    "lineNumber": 1219,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1220,
                    "isSignature": false
                  },
                  {
                    "text": "    return request;",
                    "lineNumber": 1221,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 1222,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1223,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 1224,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a mock HTTP connection for controller use",
                    "lineNumber": 1225,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1226,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns HTTP Connection object",
                    "lineNumber": 1227,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1228,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 1229,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 1230,
                    "isSignature": false
                  },
                  {
                    "text": "  private static createHttpConnection(): HttpConnection {",
                    "lineNumber": 1231,
                    "isSignature": false
                  },
                  {
                    "text": "    return new HttpConnection({",
                    "lineNumber": 1232,
                    "isSignature": false
                  },
                  {
                    "text": "      stream: Math.floor(Math.random() * 1000000),",
                    "lineNumber": 1233,
                    "isSignature": false
                  },
                  {
                    "text": "    });",
                    "lineNumber": 1234,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 1235,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1236,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 1237,
                    "isSignature": false
                  },
                  {
                    "text": "   * Convert controller Response to Bun Response",
                    "lineNumber": 1238,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1239,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param controllerResponse - The response from the controller",
                    "lineNumber": 1240,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns Bun Response object",
                    "lineNumber": 1241,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 1242,
                    "isSignature": false
                  },
                  {
                    "text": "   * @private",
                    "lineNumber": 1243,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 1244,
                    "isSignature": false
                  },
                  {
                    "text": "  private static convertToResponse(",
                    "lineNumber": 1245,
                    "isSignature": false
                  },
                  {
                    "text": "    controllerResponse:",
                    "lineNumber": 1246,
                    "isSignature": false
                  },
                  {
                    "text": "      | HttpResponse",
                    "lineNumber": 1247,
                    "isSignature": false
                  },
                  {
                    "text": "      | { status?: number; content?: string | Record<string, unknown> },",
                    "lineNumber": 1248,
                    "isSignature": false
                  },
                  {
                    "text": "  ): Response {",
                    "lineNumber": 1249,
                    "isSignature": false
                  },
                  {
                    "text": "    // Check if it's our custom HttpResponse class",
                    "lineNumber": 1250,
                    "isSignature": false
                  },
                  {
                    "text": "    if (controllerResponse instanceof HttpResponse) {",
                    "lineNumber": 1251,
                    "isSignature": false
                  },
                  {
                    "text": "      const status = controllerResponse.getStatusCode();",
                    "lineNumber": 1252,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 1278,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 1279,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.3630574941635132
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/contracts/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 100,
                    "column": 4
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Contracts;\n\nuse Laravel\\Reverb\\Application;\nuse Ratchet\\RFC6455\\Messaging\\Frame;\n\nabstract class Connection\n{\n    /**\n     * The last time the connection was seen.\n     */\n    protected ?int $lastSeenAt;\n\n    /**\n     * Stores the ping state of the connection.\n     */\n    protected $hasBeenPinged = false;\n\n    /**\n     * Indicates if the connection uses control frames.\n     */\n    protected $usesControlFrames = false;\n\n    /**\n     * Create a new connection instance.\n     */\n    public function __construct(protected WebSocketConnection $connection, protected Application $application, protected ?string $origin)\n    {\n        $this->lastSeenAt = time();\n    }\n\n    /**\n     * Get the raw socket connection identifier.\n     */\n    abstract public function identifier(): string;\n\n    /**\n     * Get the normalized socket ID.\n     */\n    abstract public function id(): string;\n\n    /**\n     * Send a message to the connection.\n     */\n    abstract public function send(string $message): void;\n\n    /**\n     * Send a control frame to the connection.\n     */\n    abstract public function control(string $type = Frame::OP_PING): void;\n\n    /**\n     * Terminate a connection.\n     */\n    abstract public function terminate(): void;\n\n    /**\n     * Get the application the connection belongs to.\n     */\n    public function app(): Application\n    {\n        return $this->application;\n    }\n\n    /**\n     * Get the origin of the connection.\n     */\n    public function origin(): ?string\n    {\n        return $this->origin;\n    }\n\n    /**\n     * Mark the connection as pinged.\n     */\n    public function ping(): void\n    {\n        $this->hasBeenPinged = true;\n    }\n\n    /**\n     * Mark the connection as ponged.\n     */\n    public function pong(): void\n    {\n        $this->hasBeenPinged = false;\n    }\n\n    /**\n     * Get the last time the connection was seen.\n     */\n    public function lastSeenAt(): ?int\n    {\n        return $this->lastSeenAt;\n    }\n\n    /**\n     * Set the connection last seen at timestamp.\n     */\n    ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Contracts;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Application;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\Frame;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "abstract class Connection",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "     * The last time the connection was seen.",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "    protected ?int $lastSeenAt;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "     * Stores the ping state of the connection.",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $hasBeenPinged = false;",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "     * Indicates if the connection uses control frames.",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $usesControlFrames = false;",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new connection instance.",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(protected WebSocketConnection $connection, protected Application $application, protected ?string $origin)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->lastSeenAt = time();",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the raw socket connection identifier.",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function identifier(): string;",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the normalized socket ID.",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function id(): string;",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function send(string $message): void;",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a control frame to the connection.",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function control(string $type = Frame::OP_PING): void;",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "     * Terminate a connection.",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "    abstract public function terminate(): void;",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the application the connection belongs to.",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "    public function app(): Application",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->application;",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the origin of the connection.",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "    public function origin(): ?string",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->origin;",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as pinged.",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    public function ping(): void",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->hasBeenPinged = true;",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "     * Mark the connection as ponged.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "    public function pong(): void",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->hasBeenPinged = false;",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "     * Get the last time the connection was seen.",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "    public function lastSeenAt(): ?int",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->lastSeenAt;",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "     * Set the connection last seen at timestamp.",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 101,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3596557378768921
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Http/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 110,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 128,
                    "column": 0
                  }
                },
                "contents": "    {\n        $this->connection->end();\n\n        return $this;\n    }\n\n    /**\n     * Dynamically proxy method calls to the underlying connection.\n     */\n    public function __call($method, $parameters)\n    {\n        if (! method_exists($this->connection, $method)) {\n            throw new BadMethodCallException(\"Method [{$method}] does not exist on [\".get_class($this->connection).'].');\n        }\n\n        return $this->connection->{$method}(...$parameters);\n    }\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    {",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->end();",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this;",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "     * Dynamically proxy method calls to the underlying connection.",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __call($method, $parameters)",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "        if (! method_exists($this->connection, $method)) {",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "            throw new BadMethodCallException(\"Method [{$method}] does not exist on [\".get_class($this->connection).'].');",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "        return $this->connection->{$method}(...$parameters);",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "}",
                    "lineNumber": 128,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3578290045261383
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/connection.ts",
                "range": {
                  "startPosition": {
                    "line": 77,
                    "column": 3
                  },
                  "endPosition": {
                    "line": 344,
                    "column": 0
                  }
                },
                "contents": "export abstract class Connection {\n  /**\n   * The last time the connection was seen (in seconds, not milliseconds).\n   *\n   * Initialized to current time when connection is created.\n   * Updated via touch() when activity is detected.\n   * Used to determine connection state (active/inactive/stale).\n   *\n   * @protected\n   */\n  protected lastSeenAt: number;\n\n  /**\n   * Stores the ping state of the connection.\n   *\n   * Set to true when a ping is sent to the connection.\n   * Set to false when a pong is received or activity is detected.\n   * Used to determine if connection is stale (inactive + pinged).\n   *\n   * @protected\n   */\n  protected hasBeenPinged = false;\n\n  /**\n   * Indicates if the connection uses control frames for activity tracking.\n   *\n   * When true, the connection uses PING/PONG frames to track activity.\n   * When false, the connection may use other mechanisms for activity tracking.\n   *\n   * @protected\n   */\n  protected _usesControlFrames = false;\n\n  /**\n   * Create a new connection instance.\n   *\n   * @param connection - The underlying WebSocket connection\n   * @param application - The application this connection belongs to\n   * @param origin - The origin of the connection (nullable)\n   */\n  constructor(\n    protected readonly connection: IWebSocketConnection,\n    protected readonly application: Application,\n    protected readonly origin: string | null,\n  ) {\n    // Initialize lastSeenAt with current time in SECONDS\n    this.lastSeenAt = Math.floor(Date.now() / 1000);\n  }\n\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * Returns the underlying WebSocket connection's identifier.\n   * This is typically a raw socket ID or resource identifier.\n   *\n   * @returns The raw connection identifier as a string\n   *\n   * @abstract\n   */",
                "signatures": {
                  "ranges": [
                    {
                      "startPosition": {
                        "line": 79,
                        "column": 1
                      },
                      "endPosition": {
                        "line": 79,
                        "column": 8
                      }
                    }
                  ]
                },
                "detailedLines": [
                  {
                    "text": "export abstract class Connection {",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "   * The last time the connection was seen (in seconds, not milliseconds).",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   * Initialized to current time when connection is created.",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * Updated via touch() when activity is detected.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * Used to determine connection state (active/inactive/stale).",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "  protected lastSeenAt: number;",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * Stores the ping state of the connection.",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * Set to true when a ping is sent to the connection.",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * Set to false when a pong is received or activity is detected.",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   * Used to determine if connection is stale (inactive + pinged).",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "  protected hasBeenPinged = false;",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * Indicates if the connection uses control frames for activity tracking.",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   * When true, the connection uses PING/PONG frames to track activity.",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * When false, the connection may use other mechanisms for activity tracking.",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   * @protected",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "  protected _usesControlFrames = false;",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   * Create a new connection instance.",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param connection - The underlying WebSocket connection",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param application - The application this connection belongs to",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param origin - The origin of the connection (nullable)",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "  constructor(",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly connection: IWebSocketConnection,",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly application: Application,",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "    protected readonly origin: string | null,",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "  ) {",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "    // Initialize lastSeenAt with current time in SECONDS",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "    this.lastSeenAt = Math.floor(Date.now() / 1000);",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "  }",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   * Returns the underlying WebSocket connection's identifier.",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": "   * This is typically a raw socket ID or resource identifier.",
                    "lineNumber": 132,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 133,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The raw connection identifier as a string",
                    "lineNumber": 134,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 135,
                    "isSignature": false
                  },
                  {
                    "text": "   * @abstract",
                    "lineNumber": 136,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 137,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.35402360558509827
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "src/contracts/websocket-connection.ts",
                "range": {
                  "startPosition": {
                    "line": 49,
                    "column": 1
                  },
                  "endPosition": {
                    "line": 167,
                    "column": 1
                  }
                },
                "contents": "/**\n * WebSocketConnection Interface\n *\n * Provides the low-level contract for WebSocket transport operations.\n * Implementations of this interface handle the raw WebSocket protocol,\n * including sending messages, control frames, and managing connection lifecycle.\n *\n * Key Responsibilities:\n * - Provide unique connection identification\n * - Send text/binary messages over the WebSocket\n * - Send control frames (PING, PONG, CLOSE)\n * - Close connections gracefully\n *\n * @example\n * ```typescript\n * // Sending a message\n * connection.send(\"Hello, WebSocket!\");\n *\n * // Sending a control frame\n * connection.send({ payload: \"\", opcode: FrameOpcode.PING, getContents: () => Buffer.from(\"\") });\n *\n * // Closing with a message\n * connection.close({ payload: \"Goodbye\", opcode: FrameOpcode.CLOSE, getContents: () => Buffer.from(\"Goodbye\") });\n *\n * // Getting connection ID\n * const connectionId = connection.id();\n * ```\n */\nexport interface IWebSocketConnection {\n  /**\n   * Get the raw socket connection identifier.\n   *\n   * This identifier is used internally to track and manage connections.\n   * In the PHP implementation (Ratchet), this returns an integer based on the\n   * socket stream resource. In Bun, this could be based on the WebSocket object's\n   * unique identifier or a generated ID.\n   *\n   * @returns The unique connection identifier (number for efficiency, string for flexibility)\n   *\n   * @example\n   * ```typescript\n   * const id = connection.id();\n   * console.log(`Connection ID: ${id}`);\n   * ```\n   */\n  id(): number | string;\n\n  /**\n   * Send a message or frame to the connection.\n   *\n   * This method handles both regular messages (strings/buffers) and control frames.\n   * When sending a Frame object, the implementation should extract the frame contents\n   * and transmit them according to the WebSocket protocol.\n   *\n   * For regular messages, the implementation may wrap them in appropriate WebSocket\n   * frames (TEXT or BINARY) based on the content type.\n   *\n   * @param message - The message to send. Can be:\n   *   - string: Text message (will be sent as TEXT frame)\n   *   - Buffer: Binary message (will be sent as BINARY frame)\n   *   - Frame: Control frame (PING, PONG, CLOSE)\n   *\n   * @throws Error if the connection is closed or invalid\n   *\n   * @example\n   * ```typescript\n   * // Send a text message\n   * connection.send(\"Hello, client!\");\n   *\n   * // Send a binary message\n   * connection.send(Buffer.from([0x01, 0x02, 0x03]));\n   *\n   * // Send a PING frame\n   * connection.send({\n   *   payload: \"\",\n   *   opcode: FrameOpcode.PING,\n   *   getContents: () => Buffer.from(\"\")\n   * });\n   * ```\n   */\n;\n}",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "/**",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": " * WebSocketConnection Interface",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": " * Provides the low-level contract for WebSocket transport operations.",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": " * Implementations of this interface handle the raw WebSocket protocol,",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": " * including sending messages, control frames, and managing connection lifecycle.",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": " * Key Responsibilities:",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": " * - Provide unique connection identification",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send text/binary messages over the WebSocket",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": " * - Send control frames (PING, PONG, CLOSE)",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": " * - Close connections gracefully",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": " * @example",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": " * ```typescript",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sending a message",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.send(\"Hello, WebSocket!\");",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": " * // Sending a control frame",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.send({ payload: \"\", opcode: FrameOpcode.PING, getContents: () => Buffer.from(\"\") });",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": " * // Closing with a message",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": " * connection.close({ payload: \"Goodbye\", opcode: FrameOpcode.CLOSE, getContents: () => Buffer.from(\"Goodbye\") });",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": " *",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": " * // Getting connection ID",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": " * const connectionId = connection.id();",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": " * ```",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": " */",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "export interface IWebSocketConnection {",
                    "lineNumber": 80,
                    "isSignature": true
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "   * Get the raw socket connection identifier.",
                    "lineNumber": 82,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 83,
                    "isSignature": false
                  },
                  {
                    "text": "   * This identifier is used internally to track and manage connections.",
                    "lineNumber": 84,
                    "isSignature": false
                  },
                  {
                    "text": "   * In the PHP implementation (Ratchet), this returns an integer based on the",
                    "lineNumber": 85,
                    "isSignature": false
                  },
                  {
                    "text": "   * socket stream resource. In Bun, this could be based on the WebSocket object's",
                    "lineNumber": 86,
                    "isSignature": false
                  },
                  {
                    "text": "   * unique identifier or a generated ID.",
                    "lineNumber": 87,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 88,
                    "isSignature": false
                  },
                  {
                    "text": "   * @returns The unique connection identifier (number for efficiency, string for flexibility)",
                    "lineNumber": 89,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 90,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 91,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 92,
                    "isSignature": false
                  },
                  {
                    "text": "   * const id = connection.id();",
                    "lineNumber": 93,
                    "isSignature": false
                  },
                  {
                    "text": "   * console.log(`Connection ID: ${id}`);",
                    "lineNumber": 94,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 95,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 96,
                    "isSignature": false
                  },
                  {
                    "text": "  id(): number | string;",
                    "lineNumber": 97,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 98,
                    "isSignature": false
                  },
                  {
                    "text": "  /**",
                    "lineNumber": 99,
                    "isSignature": false
                  },
                  {
                    "text": "   * Send a message or frame to the connection.",
                    "lineNumber": 100,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 101,
                    "isSignature": false
                  },
                  {
                    "text": "   * This method handles both regular messages (strings/buffers) and control frames.",
                    "lineNumber": 102,
                    "isSignature": false
                  },
                  {
                    "text": "   * When sending a Frame object, the implementation should extract the frame contents",
                    "lineNumber": 103,
                    "isSignature": false
                  },
                  {
                    "text": "   * and transmit them according to the WebSocket protocol.",
                    "lineNumber": 104,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 105,
                    "isSignature": false
                  },
                  {
                    "text": "   * For regular messages, the implementation may wrap them in appropriate WebSocket",
                    "lineNumber": 106,
                    "isSignature": false
                  },
                  {
                    "text": "   * frames (TEXT or BINARY) based on the content type.",
                    "lineNumber": 107,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 108,
                    "isSignature": false
                  },
                  {
                    "text": "   * @param message - The message to send. Can be:",
                    "lineNumber": 109,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - string: Text message (will be sent as TEXT frame)",
                    "lineNumber": 110,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Buffer: Binary message (will be sent as BINARY frame)",
                    "lineNumber": 111,
                    "isSignature": false
                  },
                  {
                    "text": "   *   - Frame: Control frame (PING, PONG, CLOSE)",
                    "lineNumber": 112,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 113,
                    "isSignature": false
                  },
                  {
                    "text": "   * @throws Error if the connection is closed or invalid",
                    "lineNumber": 114,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 115,
                    "isSignature": false
                  },
                  {
                    "text": "   * @example",
                    "lineNumber": 116,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```typescript",
                    "lineNumber": 117,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a text message",
                    "lineNumber": 118,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(\"Hello, client!\");",
                    "lineNumber": 119,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 120,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a binary message",
                    "lineNumber": 121,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send(Buffer.from([0x01, 0x02, 0x03]));",
                    "lineNumber": 122,
                    "isSignature": false
                  },
                  {
                    "text": "   *",
                    "lineNumber": 123,
                    "isSignature": false
                  },
                  {
                    "text": "   * // Send a PING frame",
                    "lineNumber": 124,
                    "isSignature": false
                  },
                  {
                    "text": "   * connection.send({",
                    "lineNumber": 125,
                    "isSignature": false
                  },
                  {
                    "text": "   *   payload: \"\",",
                    "lineNumber": 126,
                    "isSignature": false
                  },
                  {
                    "text": "   *   opcode: FrameOpcode.PING,",
                    "lineNumber": 127,
                    "isSignature": false
                  },
                  {
                    "text": "   *   getContents: () => Buffer.from(\"\")",
                    "lineNumber": 128,
                    "isSignature": false
                  },
                  {
                    "text": "   * });",
                    "lineNumber": 129,
                    "isSignature": false
                  },
                  {
                    "text": "   * ```",
                    "lineNumber": 130,
                    "isSignature": false
                  },
                  {
                    "text": "   */",
                    "lineNumber": 131,
                    "isSignature": false
                  },
                  {
                    "text": ";",
                    "lineNumber": 167,
                    "isSignature": true
                  },
                  {
                    "text": "}",
                    "lineNumber": 168,
                    "isSignature": true
                  }
                ]
              },
              "score": 0.34433409571647644
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Connection.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 81,
                    "column": 12
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Servers\\Reverb;\n\nuse Evenement\\EventEmitter;\nuse Laravel\\Reverb\\Contracts\\WebSocketConnection;\nuse Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection as HttpConnection;\nuse Ratchet\\RFC6455\\Messaging\\CloseFrameChecker;\nuse Ratchet\\RFC6455\\Messaging\\DataInterface;\nuse Ratchet\\RFC6455\\Messaging\\Frame;\nuse Ratchet\\RFC6455\\Messaging\\FrameInterface;\nuse Ratchet\\RFC6455\\Messaging\\MessageBuffer;\n\nclass Connection extends EventEmitter implements WebSocketConnection\n{\n    /**\n     * The message buffer.\n     *\n     * @var \\Ratchet\\RFC6455\\Messaging\\MessageBuffer\n     */\n    protected $buffer;\n\n    /**\n     * The message handler.\n     *\n     * @var ?callable\n     */\n    protected $onMessage;\n\n    /**\n     * The control frame handler.\n     *\n     * @var ?callable\n     */\n    protected $onControl;\n\n    /**\n     * The connection close handler.\n     *\n     * @var ?callable\n     */\n    protected $onClose;\n\n    /**\n     * The maximum number of allowed bytes for each message.\n     *\n     * @var int\n     */\n    protected $maxMessageSize;\n\n    /**\n     * Create a new websocket connection instance.\n     */\n    public function __construct(public HttpConnection $connection)\n    {\n        //\n    }\n\n    /**\n     * Undocumented function\n     */\n    public function openBuffer(): void\n    {\n        $this->buffer = new MessageBuffer(\n            new CloseFrameChecker,\n            maxMessagePayloadSize: $this->maxMessageSize,\n            onMessage: $this->onMessage ?: fn () => null,\n            onControl: fn (FrameInterface $message) => $this->control($message),\n            sender: [$this->connection, 'send']\n        );\n\n        $this->connection->on('data', [$this->buffer, 'onData']);\n        $this->connection->on('close', $this->onClose ?: fn () => null);\n    }\n\n    /**\n     * Send a message to the connection.\n     */\n    public function send(mixed $message): void\n    {\n        $this->connection->send(\n            ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Servers\\Reverb;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Evenement\\EventEmitter;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Contracts\\WebSocketConnection;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Servers\\Reverb\\Http\\Connection as HttpConnection;",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\CloseFrameChecker;",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\DataInterface;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\Frame;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\FrameInterface;",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "use Ratchet\\RFC6455\\Messaging\\MessageBuffer;",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "class Connection extends EventEmitter implements WebSocketConnection",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "     * The message buffer.",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var \\Ratchet\\RFC6455\\Messaging\\MessageBuffer",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $buffer;",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "     * The message handler.",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onMessage;",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "     * The control frame handler.",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onControl;",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "     * The connection close handler.",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var ?callable",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $onClose;",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "     * The maximum number of allowed bytes for each message.",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "     * @var int",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "    protected $maxMessageSize;",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new websocket connection instance.",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(public HttpConnection $connection)",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "        //",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "     * Undocumented function",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "    public function openBuffer(): void",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->buffer = new MessageBuffer(",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "            new CloseFrameChecker,",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "            maxMessagePayloadSize: $this->maxMessageSize,",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "            onMessage: $this->onMessage ?: fn () => null,",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "            onControl: fn (FrameInterface $message) => $this->control($message),",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "            sender: [$this->connection, 'send']",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        );",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->on('data', [$this->buffer, 'onData']);",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->on('close', $this->onClose ?: fn () => null);",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "     * Send a message to the connection.",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "    public function send(mixed $message): void",
                    "lineNumber": 79,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 80,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->connection->send(",
                    "lineNumber": 81,
                    "isSignature": false
                  },
                  {
                    "text": "            ",
                    "lineNumber": 82,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.34211671352386475
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "reverb/src/Servers/Reverb/Http/Server.php",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 79,
                    "column": 0
                  }
                },
                "contents": "<?php\n\nnamespace Laravel\\Reverb\\Servers\\Reverb\\Http;\n\nuse Illuminate\\Support\\Str;\nuse Laravel\\Reverb\\Loggers\\Log;\nuse Laravel\\Reverb\\Servers\\Reverb\\Concerns\\ClosesConnections;\nuse OverflowException;\nuse Psr\\Http\\Message\\RequestInterface;\nuse React\\EventLoop\\Loop;\nuse React\\EventLoop\\LoopInterface;\nuse React\\Socket\\ConnectionInterface;\nuse React\\Socket\\ServerInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\nuse Throwable;\n\nclass Server\n{\n    use ClosesConnections;\n\n    /**\n     * Create a new Http server instance.\n     */\n    public function __construct(protected ServerInterface $socket, protected Router $router, protected int $maxRequestSize, protected ?LoopInterface $loop = null)\n    {\n        gc_disable();\n\n        $this->loop = $loop ?: Loop::get();\n\n        $this->loop->addPeriodicTimer(30, fn () => gc_collect_cycles());\n\n        // Register __invoke handler for this class to receive new connections...\n        $socket->on('connection', $this);\n    }\n\n    /**\n     * Start the Http server\n     */\n    public function start(): void\n    {\n        try {\n            $this->loop->run();\n        } catch (Throwable $e) {\n            Log::error($e->getMessage());\n        }\n    }\n\n    /**\n     * Handle an incoming request.\n     */\n    protected function handleRequest(string $message, Connection $connection): void\n    {\n        if ($connection->isConnected()) {\n            return;\n        }\n\n        if (($request = $this->createRequest($message, $connection)) === null) {\n            return;\n        }\n\n        $connection->connect();\n\n        try {\n            $this->router->dispatch($request, $connection);\n        } catch (HttpException $e) {\n            $this->close($connection, $e->getStatusCode(), $e->getMessage());\n        } catch (Throwable $e) {\n            Log::error($e->getMessage());\n            $this->close($connection, 500, 'Internal server error.');\n        }\n    }\n\n    /**\n     * Create a Psr7 request from the incoming message.\n     */\n    protected function createRequest(string $message, Connection $connection): ?RequestInterface\n    {\n        try {\n            $request = Request::from($message, $connection, $this->maxRequestSize);",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "<?php",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "namespace Laravel\\Reverb\\Servers\\Reverb\\Http;",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "use Illuminate\\Support\\Str;",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Loggers\\Log;",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "use Laravel\\Reverb\\Servers\\Reverb\\Concerns\\ClosesConnections;",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "use OverflowException;",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "use Psr\\Http\\Message\\RequestInterface;",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\EventLoop\\Loop;",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\EventLoop\\LoopInterface;",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\Socket\\ConnectionInterface;",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "use React\\Socket\\ServerInterface;",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "use Symfony\\Component\\HttpKernel\\Exception\\HttpException;",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "use Throwable;",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "class Server",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "{",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "    use ClosesConnections;",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a new Http server instance.",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "    public function __construct(protected ServerInterface $socket, protected Router $router, protected int $maxRequestSize, protected ?LoopInterface $loop = null)",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "        gc_disable();",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->loop = $loop ?: Loop::get();",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "        $this->loop->addPeriodicTimer(30, fn () => gc_collect_cycles());",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "        // Register __invoke handler for this class to receive new connections...",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "        $socket->on('connection', $this);",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "     * Start the Http server",
                    "lineNumber": 37,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 38,
                    "isSignature": false
                  },
                  {
                    "text": "    public function start(): void",
                    "lineNumber": 39,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 40,
                    "isSignature": false
                  },
                  {
                    "text": "        try {",
                    "lineNumber": 41,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->loop->run();",
                    "lineNumber": 42,
                    "isSignature": false
                  },
                  {
                    "text": "        } catch (Throwable $e) {",
                    "lineNumber": 43,
                    "isSignature": false
                  },
                  {
                    "text": "            Log::error($e->getMessage());",
                    "lineNumber": 44,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 45,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 46,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 47,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 48,
                    "isSignature": false
                  },
                  {
                    "text": "     * Handle an incoming request.",
                    "lineNumber": 49,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 50,
                    "isSignature": false
                  },
                  {
                    "text": "    protected function handleRequest(string $message, Connection $connection): void",
                    "lineNumber": 51,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 52,
                    "isSignature": false
                  },
                  {
                    "text": "        if ($connection->isConnected()) {",
                    "lineNumber": 53,
                    "isSignature": false
                  },
                  {
                    "text": "            return;",
                    "lineNumber": 54,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 55,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 56,
                    "isSignature": false
                  },
                  {
                    "text": "        if (($request = $this->createRequest($message, $connection)) === null) {",
                    "lineNumber": 57,
                    "isSignature": false
                  },
                  {
                    "text": "            return;",
                    "lineNumber": 58,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 59,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 60,
                    "isSignature": false
                  },
                  {
                    "text": "        $connection->connect();",
                    "lineNumber": 61,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 62,
                    "isSignature": false
                  },
                  {
                    "text": "        try {",
                    "lineNumber": 63,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->router->dispatch($request, $connection);",
                    "lineNumber": 64,
                    "isSignature": false
                  },
                  {
                    "text": "        } catch (HttpException $e) {",
                    "lineNumber": 65,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->close($connection, $e->getStatusCode(), $e->getMessage());",
                    "lineNumber": 66,
                    "isSignature": false
                  },
                  {
                    "text": "        } catch (Throwable $e) {",
                    "lineNumber": 67,
                    "isSignature": false
                  },
                  {
                    "text": "            Log::error($e->getMessage());",
                    "lineNumber": 68,
                    "isSignature": false
                  },
                  {
                    "text": "            $this->close($connection, 500, 'Internal server error.');",
                    "lineNumber": 69,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 70,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 71,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 72,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 73,
                    "isSignature": false
                  },
                  {
                    "text": "     * Create a Psr7 request from the incoming message.",
                    "lineNumber": 74,
                    "isSignature": false
                  },
                  {
                    "text": "     */",
                    "lineNumber": 75,
                    "isSignature": false
                  },
                  {
                    "text": "    protected function createRequest(string $message, Connection $connection): ?RequestInterface",
                    "lineNumber": 76,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 77,
                    "isSignature": false
                  },
                  {
                    "text": "        try {",
                    "lineNumber": 78,
                    "isSignature": false
                  },
                  {
                    "text": "            $request = Request::from($message, $connection, $this->maxRequestSize);",
                    "lineNumber": 79,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.34172123670578003
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "notes/2025-11-13-1300-review-fixes.md",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 37,
                    "column": 0
                  }
                },
                "contents": "# Review Fixes - 2025-11-13\n\n## Status: ✅ All Issues Resolved\n\nFixed all review feedback from `specs/review.md`:\n\n### 1. Fixed Factory.createHttpConnection() Type Issues\n- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface\n- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 2. Fixed Factory.convertToHttpRequest() Headers Property\n- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)\n- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)\n- **Files**: `src/servers/reverb/factory.ts`\n\n### 3. Fixed EventsBatchController Connection Type\n- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)\n- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers\n- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`\n\n### 4. Fixed All `any` Type Violations in Tests\n- **Problem**: 9 `noExplicitAny` lint violations across test suite\n- **Solution**: Replaced all `any` types with proper types:\n  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)\n  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`\n  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)\n  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)\n- **Files**: \n  - `tests/unit/channels/channel.test.ts`\n  - `tests/e2e/websocket-connection.test.ts`\n  - `tests/feature/health-check-controller.test.ts`\n  - `tests/unit/events/event-dispatcher.test.ts`\n\n## Verification\n- ✅ `bun run typecheck` - Passes\n- ✅ `bun run lint` - No violations",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "# Review Fixes - 2025-11-13",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "## Status: ✅ All Issues Resolved",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "Fixed all review feedback from `specs/review.md`:",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 6,
                    "isSignature": false
                  },
                  {
                    "text": "### 1. Fixed Factory.createHttpConnection() Type Issues",
                    "lineNumber": 7,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Mock returned by `Factory.createHttpConnection()` did not satisfy `contracts/connection.Connection` interface",
                    "lineNumber": 8,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed to properly instantiate `HttpConnection` class from `./http/connection` instead of creating a plain object literal",
                    "lineNumber": 9,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 10,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 11,
                    "isSignature": false
                  },
                  {
                    "text": "### 2. Fixed Factory.convertToHttpRequest() Headers Property",
                    "lineNumber": 12,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Returned object included `headers` property that `IHttpRequest` interface does not declare (TS2353)",
                    "lineNumber": 13,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Removed `headers` property from return object (headers are accessible via `getHeaders()` method)",
                    "lineNumber": 14,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/servers/reverb/factory.ts`",
                    "lineNumber": 15,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 16,
                    "isSignature": false
                  },
                  {
                    "text": "### 3. Fixed EventsBatchController Connection Type",
                    "lineNumber": 17,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: Imported `Connection` from `contracts/connection` (abstract class) instead of `http/connection` (HttpConnection class)",
                    "lineNumber": 18,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Changed import to use `HttpConnection` from `servers/reverb/http/connection` to match other HTTP controllers",
                    "lineNumber": 19,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: `src/protocols/pusher/http/controllers/events-batch-controller.ts`",
                    "lineNumber": 20,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 21,
                    "isSignature": false
                  },
                  {
                    "text": "### 4. Fixed All `any` Type Violations in Tests",
                    "lineNumber": 22,
                    "isSignature": false
                  },
                  {
                    "text": "- **Problem**: 9 `noExplicitAny` lint violations across test suite",
                    "lineNumber": 23,
                    "isSignature": false
                  },
                  {
                    "text": "- **Solution**: Replaced all `any` types with proper types:",
                    "lineNumber": 24,
                    "isSignature": false
                  },
                  {
                    "text": "  - `channel.test.ts`: Changed `data: any` to `Map<string, unknown>` (matches `ChannelConnection.data()` return type)",
                    "lineNumber": 25,
                    "isSignature": false
                  },
                  {
                    "text": "  - `websocket-connection.test.ts`: Changed `Promise<any>` to `Promise<unknown>`",
                    "lineNumber": 26,
                    "isSignature": false
                  },
                  {
                    "text": "  - `health-check-controller.test.ts`: Changed `server: any` to `server: Server` (from bun)",
                    "lineNumber": 27,
                    "isSignature": false
                  },
                  {
                    "text": "  - `event-dispatcher.test.ts`: Changed `data: any` to `data: unknown` (matches `EventListener<T = unknown>`)",
                    "lineNumber": 28,
                    "isSignature": false
                  },
                  {
                    "text": "- **Files**: ",
                    "lineNumber": 29,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/channels/channel.test.ts`",
                    "lineNumber": 30,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/e2e/websocket-connection.test.ts`",
                    "lineNumber": 31,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/feature/health-check-controller.test.ts`",
                    "lineNumber": 32,
                    "isSignature": false
                  },
                  {
                    "text": "  - `tests/unit/events/event-dispatcher.test.ts`",
                    "lineNumber": 33,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 34,
                    "isSignature": false
                  },
                  {
                    "text": "## Verification",
                    "lineNumber": 35,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run typecheck` - Passes",
                    "lineNumber": 36,
                    "isSignature": false
                  },
                  {
                    "text": "- ✅ `bun run lint` - No violations",
                    "lineNumber": 37,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.3352693021297455
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/review.md",
                "range": {
                  "startPosition": {
                    "line": 0,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 6,
                    "column": 0
                  }
                },
                "contents": "last commit: deb78c1\nstatus: not ok\nreview comments:\n- `bun run typecheck` still fails because the mock returned by `Factory.createHttpConnection()` does not satisfy either interface it claims to implement. `EventsBatchController.handle` expects a `contracts/connection.Connection`, but `Factory.handleBatchEvents` passes `HttpConnection` from `./http/connection` at `src/servers/reverb/factory.ts:847`, so TypeScript raises `TS2345` (the mock lacks `lastSeenAt`, `hasBeenPinged`, etc.). The same stub is also typed as `HttpConnection` yet omits required members (`connection`, `close`) and tries to access private fields, triggering the cluster of errors at `src/servers/reverb/factory.ts:1227-1255`. The HTTP controllers still cannot compile until this connection adapter is reworked to satisfy the actual contracts.\n- `Factory.convertToHttpRequest()` now returns an object literal typed as `IHttpRequest & { url: string; httpVersion: string; getSize(): number }`, but it also defines a top-level `headers` property that `IHttpRequest` does not declare. With excess-property checking enabled, TypeScript rejects this at `src/servers/reverb/factory.ts:1191 (TS2353)`, so the build never reaches runtime.\n- Objective 0 from `scripts/ralph/current.md` is unmet: `bun run lint` still reports nine `lint/suspicious/noExplicitAny` violations across the test suite (`tests/e2e/websocket-connection.test.ts:96`, `tests/feature/health-check-controller.test.ts:5`, `tests/unit/channels/channel.test.ts:25` & `61`, and `tests/unit/events/event-dispatcher.test.ts:22`, `75`, `307`, `311`, `315`). Husky will keep blocking commits until these `any` annotations are replaced with concrete types.",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "last commit: deb78c1",
                    "lineNumber": 1,
                    "isSignature": false
                  },
                  {
                    "text": "status: not ok",
                    "lineNumber": 2,
                    "isSignature": false
                  },
                  {
                    "text": "review comments:",
                    "lineNumber": 3,
                    "isSignature": false
                  },
                  {
                    "text": "- `bun run typecheck` still fails because the mock returned by `Factory.createHttpConnection()` does not satisfy either interface it claims to implement. `EventsBatchController.handle` expects a `contracts/connection.Connection`, but `Factory.handleBatchEvents` passes `HttpConnection` from `./http/connection` at `src/servers/reverb/factory.ts:847`, so TypeScript raises `TS2345` (the mock lacks `lastSeenAt`, `hasBeenPinged`, etc.). The same stub is also typed as `HttpConnection` yet omits required members (`connection`, `close`) and tries to access private fields, triggering the cluster of errors at `src/servers/reverb/factory.ts:1227-1255`. The HTTP controllers still cannot compile until this connection adapter is reworked to satisfy the actual contracts.",
                    "lineNumber": 4,
                    "isSignature": false
                  },
                  {
                    "text": "- `Factory.convertToHttpRequest()` now returns an object literal typed as `IHttpRequest & { url: string; httpVersion: string; getSize(): number }`, but it also defines a top-level `headers` property that `IHttpRequest` does not declare. With excess-property checking enabled, TypeScript rejects this at `src/servers/reverb/factory.ts:1191 (TS2353)`, so the build never reaches runtime.",
                    "lineNumber": 5,
                    "isSignature": false
                  },
                  {
                    "text": "- Objective 0 from `scripts/ralph/current.md` is unmet: `bun run lint` still reports nine `lint/suspicious/noExplicitAny` violations across the test suite (`tests/e2e/websocket-connection.test.ts:96`, `tests/feature/health-check-controller.test.ts:5`, `tests/unit/channels/channel.test.ts:25` & `61`, and `tests/unit/events/event-dispatcher.test.ts:22`, `75`, `307`, `311`, `315`). Husky will keep blocking commits until these `any` annotations are replaced with concrete types.",
                    "lineNumber": 6,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.2984972894191742
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 10291,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 10307,
                    "column": 16
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"revurb-ts/src/contracts/connection.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 0,\n                    \"column\": 50\n                  },\n                  \"endPosition\": {\n                    \"line\": 344,\n                    \"column\": 0\n                  }\n                },\n                \"contents\": \"import type { IWebSocketConnection, FrameOpcode } from './websocket-connection';\\n\\n/**\\n * Connection State Machine\\n *\\n * The Connection class tracks connection state using a timestamp-based state machine:\\n *\\n * State Transitions:\\n * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\\n * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\\n * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\\n *\\n * State Determination:\\n * - isActive(): time() < lastSeenAt + app.pingInterval()\\n * - isInactive(): !isActive()\\n * - isStale(): isInactive() && hasBeenPinged\\n *\\n * Lifecycle:\\n * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\\n * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\\n * 3. No activity for pingInterval → isInactive() = true\\n * 4. Ping sent → ping() → hasBeenPinged = true\\n * 5. Pong received → pong() → hasBeenPinged = false\\n * 6. No response after ping → isStale() = true → connection pruned\\n *\\n * Timestamps:\\n * - All timestamps use SECONDS (not milliseconds)\\n * - Use Math.floor(Date.now() / 1000) to get current time in seconds\\n * - This matches PHP's time() function behavior\\n */\\n\\n/**\\n * Connection Abstract Class\\n *\\n * Application-aware connection wrapper that manages WebSocket connection state,\\n * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\\n * activity tracking, and state management.\\n *\\n * Key Responsibilities:\\n * - Wrap WebSocketConnection with application context\\n * - Track connection activity via lastSeenAt timestamp\\n * - Implement state machine (Active/Inactive/Stale)\\n * - Manage ping/pong state for connection health\\n * - Generate normalized socket IDs\\n * - Provide connection lifecycle methods\\n *\\n * @abstract\\n *\\n * @example\\n * ```typescript\\n * class ReverbConnection extends Connection {\\n *   identifier(): string {\\n *     return String(this.connection.id());\\n *   }\\n *\\n *   id(): string {\\n *     if (!this._id) {\\n *       this._id = this.generateId();\\n *     }\\n *     return this._id;\\n *   }\\n *\\n *   send(message: string): void {\\n *     this.connection.send(message);\\n *     // Dispatch MessageSent event\\n *   }\\n *\\n *   control(type: FrameOpcode = FrameOpcode.PING): void {\\n *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\\n *   }\\n *\\n *   terminate(): void {\\n *     this.connection.close();\\n *   }\\n * }\\n * ```\\n */\\nexport abstract class Connection {\\n  /**\\n   * The last time the connection was seen (in seconds, not milliseconds).\\n   *\\n   * Initialized to current time when connection is created.\\n   * Updated via touch() when activity is detected.\\n   * Used to determine connection state (active/inactive/stale).\\n   *\\n   * @protected\\n   */\",\n                \"signatures\": {\n                  \"ranges\": []\n                ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 10292,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 10293,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"revurb-ts/src/contracts/connection.ts\",",
                    "lineNumber": 10294,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 10295,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 10296,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 0,",
                    "lineNumber": 10297,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 50",
                    "lineNumber": 10298,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10299,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 10300,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 344,",
                    "lineNumber": 10301,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 0",
                    "lineNumber": 10302,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 10303,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 10304,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"import type { IWebSocketConnection, FrameOpcode } from './websocket-connection';\\n\\n/**\\n * Connection State Machine\\n *\\n * The Connection class tracks connection state using a timestamp-based state machine:\\n *\\n * State Transitions:\\n * 1. ACTIVE: Connection is actively communicating (lastSeenAt within pingInterval)\\n * 2. INACTIVE: Connection has not been seen recently (lastSeenAt exceeds pingInterval)\\n * 3. STALE: Connection is INACTIVE and has been pinged but not responded (hasBeenPinged = true)\\n *\\n * State Determination:\\n * - isActive(): time() < lastSeenAt + app.pingInterval()\\n * - isInactive(): !isActive()\\n * - isStale(): isInactive() && hasBeenPinged\\n *\\n * Lifecycle:\\n * 1. Connection created → lastSeenAt = time(), hasBeenPinged = false\\n * 2. Activity detected → touch() → lastSeenAt = time(), hasBeenPinged = false\\n * 3. No activity for pingInterval → isInactive() = true\\n * 4. Ping sent → ping() → hasBeenPinged = true\\n * 5. Pong received → pong() → hasBeenPinged = false\\n * 6. No response after ping → isStale() = true → connection pruned\\n *\\n * Timestamps:\\n * - All timestamps use SECONDS (not milliseconds)\\n * - Use Math.floor(Date.now() / 1000) to get current time in seconds\\n * - This matches PHP's time() function behavior\\n */\\n\\n/**\\n * Connection Abstract Class\\n *\\n * Application-aware connection wrapper that manages WebSocket connection state,\\n * tracking, and lifecycle. Extends raw WebSocketConnection with application context,\\n * activity tracking, and state management.\\n *\\n * Key Responsibilities:\\n * - Wrap WebSocketConnection with application context\\n * - Track connection activity via lastSeenAt timestamp\\n * - Implement state machine (Active/Inactive/Stale)\\n * - Manage ping/pong state for connection health\\n * - Generate normalized socket IDs\\n * - Provide connection lifecycle methods\\n *\\n * @abstract\\n *\\n * @example\\n * ```typescript\\n * class ReverbConnection extends Connection {\\n *   identifier(): string {\\n *     return String(this.connection.id());\\n *   }\\n *\\n *   id(): string {\\n *     if (!this._id) {\\n *       this._id = this.generateId();\\n *     }\\n *     return this._id;\\n *   }\\n *\\n *   send(message: string): void {\\n *     this.connection.send(message);\\n *     // Dispatch MessageSent event\\n *   }\\n *\\n *   control(type: FrameOpcode = FrameOpcode.PING): void {\\n *     this.connection.send({ payload: '', opcode: type, getContents: () => '' });\\n *   }\\n *\\n *   terminate(): void {\\n *     this.connection.close();\\n *   }\\n * }\\n * ```\\n */\\nexport abstract class Connection {\\n  /**\\n   * The last time the connection was seen (in seconds, not milliseconds).\\n   *\\n   * Initialized to current time when connection is created.\\n   * Updated via touch() when activity is detected.\\n   * Used to determine connection state (active/inactive/stale).\\n   *\\n   * @protected\\n   */\",",
                    "lineNumber": 10305,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 10306,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": []",
                    "lineNumber": 10307,
                    "isSignature": false
                  },
                  {
                    "text": "                ",
                    "lineNumber": 10308,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.27857089042663574
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 15945,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 15961,
                    "column": 16
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"revurb-ts/src/connection.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 0,\n                    \"column\": 74\n                  },\n                  \"endPosition\": {\n                    \"line\": 118,\n                    \"column\": 1\n                  }\n                },\n                \"contents\": \"import type { IWebSocketConnection, FrameOpcode } from './contracts/websocket-connection';\\nimport type { Application } from './application';\\nimport { MessageSent } from './events/message-sent';\\nimport { FrameOpcode as FrameOpcodeEnum } from './contracts/websocket-connection';\\n\\n/**\\n * Connection Implementation\\n *\\n * Concrete implementation of the Connection contract that wraps a WebSocket\\n * connection with application context and state management.\\n *\\n * This class implements the Pusher-compatible connection wrapper, handling:\\n * - Connection identification and normalization\\n * - Message sending with event dispatching\\n * - Control frame management (PING/PONG)\\n * - Connection lifecycle and termination\\n *\\n * The connection maintains state through the abstract base class:\\n * - lastSeenAt: Timestamp tracking for activity monitoring\\n * - hasBeenPinged: Ping state for stale connection detection\\n * - usesControlFrames: Whether the connection uses control frames\\n *\\n * @see Connection contract for state machine documentation\\n */\\nexport class Connection extends ConnectionContract {\\n  /**\\n   * The normalized socket ID.\\n   *\\n   * Cached socket ID in Pusher format (\\\"number.number\\\").\\n   * Generated once on first access and reused for connection lifetime.\\n   *\\n   * @private\\n   */\\n  private _id: string | null = null;\\n\\n  /**\\n   * Create a new connection instance.\\n   *\\n   * @param connection - The underlying WebSocket connection\\n   * @param application - The application this connection belongs to\\n   * @param origin - The origin of the connection (nullable)\\n   */\\n  constructor(\\n    connection: IWebSocketConnection,\\n    application: Application,\\n    origin: string | null\\n  ) {\\n    super(connection, application, origin);\\n  }\\n\\n  /**\\n   * Get the raw socket connection identifier.\\n   *\\n   * Returns the underlying WebSocket connection's identifier as a string.\\n   * This is the raw transport-level identifier, not the normalized socket ID.\\n   *\\n   * @returns The raw connection identifier as a string\\n   */\\n}\",\n                \"signatures\": {\n                  \"ranges\": []\n                ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 15946,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 15947,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"revurb-ts/src/connection.ts\",",
                    "lineNumber": 15948,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 15949,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 15950,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 0,",
                    "lineNumber": 15951,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 74",
                    "lineNumber": 15952,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 15953,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 15954,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 118,",
                    "lineNumber": 15955,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 1",
                    "lineNumber": 15956,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 15957,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 15958,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"import type { IWebSocketConnection, FrameOpcode } from './contracts/websocket-connection';\\nimport type { Application } from './application';\\nimport { MessageSent } from './events/message-sent';\\nimport { FrameOpcode as FrameOpcodeEnum } from './contracts/websocket-connection';\\n\\n/**\\n * Connection Implementation\\n *\\n * Concrete implementation of the Connection contract that wraps a WebSocket\\n * connection with application context and state management.\\n *\\n * This class implements the Pusher-compatible connection wrapper, handling:\\n * - Connection identification and normalization\\n * - Message sending with event dispatching\\n * - Control frame management (PING/PONG)\\n * - Connection lifecycle and termination\\n *\\n * The connection maintains state through the abstract base class:\\n * - lastSeenAt: Timestamp tracking for activity monitoring\\n * - hasBeenPinged: Ping state for stale connection detection\\n * - usesControlFrames: Whether the connection uses control frames\\n *\\n * @see Connection contract for state machine documentation\\n */\\nexport class Connection extends ConnectionContract {\\n  /**\\n   * The normalized socket ID.\\n   *\\n   * Cached socket ID in Pusher format (\\\"number.number\\\").\\n   * Generated once on first access and reused for connection lifetime.\\n   *\\n   * @private\\n   */\\n  private _id: string | null = null;\\n\\n  /**\\n   * Create a new connection instance.\\n   *\\n   * @param connection - The underlying WebSocket connection\\n   * @param application - The application this connection belongs to\\n   * @param origin - The origin of the connection (nullable)\\n   */\\n  constructor(\\n    connection: IWebSocketConnection,\\n    application: Application,\\n    origin: string | null\\n  ) {\\n    super(connection, application, origin);\\n  }\\n\\n  /**\\n   * Get the raw socket connection identifier.\\n   *\\n   * Returns the underlying WebSocket connection's identifier as a string.\\n   * This is the raw transport-level identifier, not the normalized socket ID.\\n   *\\n   * @returns The raw connection identifier as a string\\n   */\\n}\",",
                    "lineNumber": 15959,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 15960,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": []",
                    "lineNumber": 15961,
                    "isSignature": false
                  },
                  {
                    "text": "                ",
                    "lineNumber": 15962,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.24129384756088257
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-1150.md",
                "range": {
                  "startPosition": {
                    "line": 5348,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 5384,
                    "column": 0
                  }
                },
                "contents": "        }\n      }\n    }\n\n### Assistant\n\nFixing router.ts to handle our Response class:\n\n### Tool · edit (started)\n\n    {\n      \"args\": {\n        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\"\n      }\n    }\n\n### Tool · edit (completed)\n\n    {\n      \"args\": {\n        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\"\n      },\n      \"result\": {\n        \"success\": {\n          \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\",\n          \"resultForModel\": \"\",\n          \"linesAdded\": 1,\n          \"linesRemoved\": 0,\n          \"diffString\": \"  import { createHash } from \\\"node:crypto\\\";\\n  import type { Connection } from \\\"./connection\\\";\\n+ import { Response as HttpResponse } from \\\"./response\\\";\\n  \\n  /**\",\n          \"beforeFullFileContent\": \"import { createHash } from \\\"node:crypto\\\";\\nimport type { Connection } from \\\"./connection\\\";\\n\\n/**\\n * HTTP Router for request dispatch and WebSocket upgrade handling\\n *\\n * The Router class handles:\\n * - Request routing and dispatch to controllers\\n * - WebSocket upgrade detection and handshake (RFC 6455)\\n * - Controller parameter resolution\\n * - HTTP error handling (404, 405, 500)\\n *\\n * Key Features:\\n * - dispatch() method matches request to route and calls controller\\n * - WebSocket upgrade detection via \\\"Upgrade: websocket\\\" header\\n * - RFC 6455 WebSocket handshake negotiation with proper key generation\\n * - Controller parameter resolution from route and request context\\n * - Graceful HTTP error responses (404, 405, 500)\\n *\\n * @example\\n * ```typescript\\n * const router = new Router(routeMatcher);\\n * const result = await router.dispatch(request, connection);\\n * ```\\n */\\nexport class Router {\\n  /**\\n   * WebSocket upgrade magic GUID as defined in RFC 6455\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3\\n   */\\n  private static readonly WS_GUID = \\\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\\\";\\n\\n  /**\\n   * Create a new Router instance\\n   *\\n   * @param matcher - The route matcher instance (implements IRouteMatcher)\\n   */\\n  constructor(private matcher: IRouteMatcher) {}\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, unknown>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          if (connection) {\\n            this.close(connection, 405, \\\"Method not allowed.\\\", {\\n              Allow: allowedMethods,\\n            });\\n          }\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          if (connection) {\\n            this.close(connection, 404, \\\"Not found.\\\");\\n          }\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n  private controller(route: Record<string, unknown>): ControllerCallback {\\n    const controller = route._controller;\\n    if (typeof controller === \\\"function\\\") {\\n      return controller as ControllerCallback;\\n    }\\n    throw new Error(\\\"Invalid controller in route\\\");\\n  }\\n\\n  /**\\n   * Determine whether the request is for a WebSocket connection\\n   *\\n   * Checks for the \\\"Upgrade: websocket\\\" header as defined in RFC 6455\\n   *\\n   * @param request - The HTTP request object\\n   * @returns true if the request is a WebSocket upgrade request\\n   *\\n   * @private\\n   */\\n  private isWebSocketRequest(request: IHttpRequest): boolean {\\n    const upgradeHeader = request.getHeader(\\\"upgrade\\\")?.toLowerCase();\\n    return upgradeHeader === \\\"websocket\\\";\\n  }\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(\\n    request: IHttpRequest,\\n    connection: Connection,\\n  ): Connection {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader(\\\"sec-websocket-key\\\");\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, \\\"Missing Sec-WebSocket-Key header.\\\");\\n      throw new Error(\\\"WebSocket upgrade failed: missing Sec-WebSocket-Key\\\");\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = \\\"HTTP/1.1 101 Switching Protocols\\\\r\\\\n\\\";\\n    const headers = [\\n      \\\"Upgrade: websocket\\\",\\n      \\\"Connection: Upgrade\\\",\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      \\\"X-Powered-By: Reverb\\\",\\n    ];\\n\\n    const responseHeaders = `${headers.join(\\\"\\\\r\\\\n\\\")}\\\\r\\\\n\\\\r\\\\n`;\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n  private generateAcceptKey(secWebSocketKey: string): string {\\n    const concatenated = secWebSocketKey + Router.WS_GUID;\\n    const hash = createHash(\\\"sha1\\\").update(concatenated).digest();\\n    return hash.toString(\\\"base64\\\");\\n  }\\n\\n  /**\\n   * Get the arguments for the controller\\n   *\\n   * Resolves controller parameters from the available route parameters.\\n   * Uses reflection to determine parameter names and matches them to\\n   * values from the route parameters object.\\n   *\\n   * @param controller - The controller function/callback\\n   * @param routeParameters - Object containing all available parameters\\n   * @returns Array of arguments in the correct order for the controller\\n   *\\n   * @private\\n   */\\n  private arguments(\\n    controller: ControllerCallback,\\n    routeParameters: Record<string, unknown>,\\n  ): unknown[] {\\n    const params = this.parameters(controller);\\n\\n    return params.map((param) => {\\n      return routeParameters[param.name] ?? null;\\n    });\\n  }\\n\\n  /**\\n   * Get the parameters for the controller function\\n   *\\n   * Uses JavaScript introspection to extract parameter names from the function.\\n   * Returns an array of parameter metadata.\\n   *\\n   * @param controller - The controller function/callback\\n   * @returns Array of parameter metadata objects with name, type, and position\\n   *\\n   * @private\\n   */\\n  private parameters(\\n    controller: ControllerCallback,\\n  ): Array<{ name: string; position: number }> {\\n    if (typeof controller !== \\\"function\\\") {\\n      return [];\\n    }\\n\\n    // Extract parameter names from function signature\\n    const functionStr = controller.toString();\\n\\n    // Match function parameters using regex\\n    const match = functionStr.match(/\\\\(([^)]*)\\\\)/);\\n    if (!match || !match[1]) {\\n      return [];\\n    }\\n\\n    const paramStr = match[1];\\n    if (!paramStr) {\\n      return [];\\n    }\\n\\n    const paramNames = paramStr\\n      .split(\\\",\\\")\\n      .map((param) => param.trim().split(\\\"=\\\")[0]?.split(\\\":\\\")[0]?.trim() || \\\"\\\")\\n      .filter((name) => name.length > 0);\\n\\n    return paramNames.map((name, index) => ({\\n      name,\\n      position: index,\\n    }));\\n  }\\n\\n  /**\\n   * Extract route parameters (excluding internal keys like _controller and _route)\\n   *\\n   * @param route - The matched route object\\n   * @returns Object containing only the route parameters\\n   *\\n   * @private\\n   */\\n  private extractRouteParams(\\n    route: Record<string, unknown>,\\n  ): Record<string, unknown> {\\n    const params: Record<string, unknown> = {};\\n\\n    Object.entries(route).forEach(([key, value]) => {\\n      if (!key.startsWith(\\\"_\\\")) {\\n        params[key] = value;\\n      }\\n    });\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Check if an error is a method not allowed exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a method not allowed exception\\n   *\\n   * @private\\n   */\\n  private isMethodNotAllowedException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"MethodNotAllowedException\\\") ||\\n        (\\\"code\\\" in error && error.code === 405)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Check if an error is a resource not found exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a resource not found exception\\n   *\\n   * @private\\n   */\\n  private isResourceNotFoundException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"ResourceNotFoundException\\\") ||\\n        (\\\"code\\\" in error && error.code === 404)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Get allowed methods from a method not allowed exception\\n   *\\n   * @param error - The method not allowed exception\\n   * @returns Comma-separated string of allowed methods\\n   *\\n   * @private\\n   */\\n  private getAllowedMethods(error: unknown): string {\\n    if (\\n      typeof error === \\\"object\\\" &&\\n      error !== null &&\\n      \\\"allowedMethods\\\" in error\\n    ) {\\n      const allowedMethods = (error as { allowedMethods?: unknown })\\n        .allowedMethods;\\n      if (Array.isArray(allowedMethods)) {\\n        return allowedMethods.join(\\\", \\\");\\n      }\\n      if (typeof allowedMethods === \\\"string\\\") {\\n        return allowedMethods;\\n      }\\n    }\\n    return \\\"OPTIONS, GET, POST, PUT, DELETE, PATCH\\\";\\n  }\\n\\n  /**\\n   * Send an HTTP response to the connection\\n   *\\n   * @param connection - The connection to send the response to\\n   * @param response - The response data\\n   * @returns The connection for chaining\\n   *\\n   * @private\\n   */\\n  private sendResponse(connection: Connection, response: unknown): Connection {\\n    if (response) {\\n      const responseData =\\n        typeof response === \\\"string\\\"\\n          ? response\\n          : response instanceof Uint8Array\\n            ? response\\n            : JSON.stringify(response);\\n      connection.send(responseData);\\n    }\\n    connection.close();\\n    return connection;\\n  }\\n\\n  /**\\n   * Close a connection with an HTTP error response\\n   *\\n   * Sends a properly formatted HTTP error response and closes the connection.\\n   *\\n   * @param connection - The connection to close\\n   * @param statusCode - The HTTP status code\\n   * @param message - The error message\\n   * @param additionalHeaders - Optional additional headers to include\\n   *\\n   * @private\\n   */\\n  private close(\\n    connection: Connection,\\n    statusCode: number,\\n    message: string,\\n    additionalHeaders: Record<string, string> = {},\\n  ): void {\\n    const statusText = this.getStatusText(statusCode);\\n    const body = JSON.stringify({ error: message });\\n    const bodyLength = Buffer.byteLength(body, \\\"utf8\\\");\\n\\n    const headers: Record<string, string> = {\\n      \\\"Content-Type\\\": \\\"application/json\\\",\\n      \\\"Content-Length\\\": String(bodyLength),\\n      ...additionalHeaders,\\n    };\\n\\n    const headerLines = Object.entries(headers)\\n      .map(([key, value]) => `${key}: ${value}`)\\n      .join(\\\"\\\\r\\\\n\\\");\\n\\n    const response = `HTTP/1.1 ${statusCode} ${statusText}\\\\r\\\\n${headerLines}\\\\r\\\\n\\\\r\\\\n${body}`;\\n\\n    try {\\n      connection.send(response);\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n\\n    try {\\n      connection.close();\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n  }\\n\\n  /**\\n   * Get the HTTP status text for a given status code\\n   *\\n   * @param statusCode - The HTTP status code\\n   * @returns The HTTP status reason phrase\\n   *\\n   * @private\\n   */\\n  private getStatusText(statusCode: number): string {\\n    const statusTexts: Record<number, string> = {\\n      400: \\\"Bad Request\\\",\\n      404: \\\"Not Found\\\",\\n      405: \\\"Method Not Allowed\\\",\\n      500: \\\"Internal Server Error\\\",\\n    };\\n\\n    return statusTexts[statusCode] ?? \\\"Unknown\\\";\\n  }\\n}\\n\\n/**\\n * HTTP Request interface\\n *\\n * Represents an HTTP request object with methods to access headers, method, path, etc.\\n */\\nexport interface IHttpRequest {\\n  /**\\n   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\\n   */\\n  method: string;\\n\\n  /**\\n   * Request path with query string - property for direct access\\n   */\\n  path: string;\\n\\n  /**\\n   * Request body content - property for direct access\\n   */\\n  body: string;\\n\\n  /**\\n   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\\n   */\\n  getMethod(): string;\\n\\n  /**\\n   * Get the request path\\n   */\\n  getPath(): string;\\n\\n  /**\\n   * Get the request host\\n   */\\n  getHost(): string;\\n\\n  /**\\n   * Get a specific header value\\n   */\\n  getHeader(name: string): string | undefined;\\n\\n  /**\\n   * Get all headers\\n   */\\n  getHeaders(): Record<string, string>;\\n\\n  /**\\n   * Get the request URI\\n   */\\n  getUri(): {\\n    path: string;\\n    host: string;\\n  };\\n}\\n\\n/**\\n * Route matcher interface\\n *\\n * Handles route matching and context management\\n */\\nexport interface IRouteMatcher {\\n  /**\\n   * Set the matcher context (method, host, etc.)\\n   */\\n  setContext(context: MatcherContext): void;\\n\\n  /**\\n   * Match a path to a route\\n   */\\n  match(path: string): Record<string, unknown>;\\n\\n  /**\\n   * Get the current context\\n   */\\n  getContext(): MatcherContext;\\n}\\n\\n/**\\n * Route matcher context\\n */\\nexport interface MatcherContext {\\n  method: string;\\n  host: string;\\n}\\n\\n/**\\n * Controller callback type\\n *\\n * Represents a controller function that can be called with request and route parameters\\n */\\nexport type ControllerCallback = (\\n  ...args: unknown[]\\n) => unknown | Promise<unknown>;\\n\",\n          \"afterFullFileContent\": \"import { createHash } from \\\"node:crypto\\\";\\nimport type { Connection } from \\\"./connection\\\";\\nimport { Response as HttpResponse } from \\\"./response\\\";\\n\\n/**\\n * HTTP Router for request dispatch and WebSocket upgrade handling\\n *\\n * The Router class handles:\\n * - Request routing and dispatch to controllers\\n * - WebSocket upgrade detection and handshake (RFC 6455)\\n * - Controller parameter resolution\\n * - HTTP error handling (404, 405, 500)\\n *\\n * Key Features:\\n * - dispatch() method matches request to route and calls controller\\n * - WebSocket upgrade detection via \\\"Upgrade: websocket\\\" header\\n * - RFC 6455 WebSocket handshake negotiation with proper key generation\\n * - Controller parameter resolution from route and request context\\n * - Graceful HTTP error responses (404, 405, 500)\\n *\\n * @example\\n * ```typescript\\n * const router = new Router(routeMatcher);\\n * const result = await router.dispatch(request, connection);\\n * ```\\n */\\nexport class Router {\\n  /**\\n   * WebSocket upgrade magic GUID as defined in RFC 6455\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3\\n   */\\n  private static readonly WS_GUID = \\\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\\\";\\n\\n  /**\\n   * Create a new Router instance\\n   *\\n   * @param matcher - The route matcher instance (implements IRouteMatcher)\\n   */\\n  constructor(private matcher: IRouteMatcher) {}\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, unknown>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          if (connection) {\\n            this.close(connection, 405, \\\"Method not allowed.\\\", {\\n              Allow: allowedMethods,\\n            });\\n          }\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          if (connection) {\\n            this.close(connection, 404, \\\"Not found.\\\");\\n          }\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n  private controller(route: Record<string, unknown>): ControllerCallback {\\n    const controller = route._controller;\\n    if (typeof controller === \\\"function\\\") {\\n      return controller as ControllerCallback;\\n    }\\n    throw new Error(\\\"Invalid controller in route\\\");\\n  }\\n\\n  /**\\n   * Determine whether the request is for a WebSocket connection\\n   *\\n   * Checks for the \\\"Upgrade: websocket\\\" header as defined in RFC 6455\\n   *\\n   * @param request - The HTTP request object\\n   * @returns true if the request is a WebSocket upgrade request\\n   *\\n   * @private\\n   */\\n  private isWebSocketRequest(request: IHttpRequest): boolean {\\n    const upgradeHeader = request.getHeader(\\\"upgrade\\\")?.toLowerCase();\\n    return upgradeHeader === \\\"websocket\\\";\\n  }\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(\\n    request: IHttpRequest,\\n    connection: Connection,\\n  ): Connection {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader(\\\"sec-websocket-key\\\");\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, \\\"Missing Sec-WebSocket-Key header.\\\");\\n      throw new Error(\\\"WebSocket upgrade failed: missing Sec-WebSocket-Key\\\");\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = \\\"HTTP/1.1 101 Switching Protocols\\\\r\\\\n\\\";\\n    const headers = [\\n      \\\"Upgrade: websocket\\\",\\n      \\\"Connection: Upgrade\\\",\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      \\\"X-Powered-By: Reverb\\\",\\n    ];\\n\\n    const responseHeaders = `${headers.join(\\\"\\\\r\\\\n\\\")}\\\\r\\\\n\\\\r\\\\n`;\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n  private generateAcceptKey(secWebSocketKey: string): string {\\n    const concatenated = secWebSocketKey + Router.WS_GUID;\\n    const hash = createHash(\\\"sha1\\\").update(concatenated).digest();\\n    return hash.toString(\\\"base64\\\");\\n  }\\n\\n  /**\\n   * Get the arguments for the controller\\n   *\\n   * Resolves controller parameters from the available route parameters.\\n   * Uses reflection to determine parameter names and matches them to\\n   * values from the route parameters object.\\n   *\\n   * @param controller - The controller function/callback\\n   * @param routeParameters - Object containing all available parameters\\n   * @returns Array of arguments in the correct order for the controller\\n   *\\n   * @private\\n   */\\n  private arguments(\\n    controller: ControllerCallback,\\n    routeParameters: Record<string, unknown>,\\n  ): unknown[] {\\n    const params = this.parameters(controller);\\n\\n    return params.map((param) => {\\n      return routeParameters[param.name] ?? null;\\n    });\\n  }\\n\\n  /**\\n   * Get the parameters for the controller function\\n   *\\n   * Uses JavaScript introspection to extract parameter names from the function.\\n   * Returns an array of parameter metadata.\\n   *\\n   * @param controller - The controller function/callback\\n   * @returns Array of parameter metadata objects with name, type, and position\\n   *\\n   * @private\\n   */\\n  private parameters(\\n    controller: ControllerCallback,\\n  ): Array<{ name: string; position: number }> {\\n    if (typeof controller !== \\\"function\\\") {\\n      return [];\\n    }\\n\\n    // Extract parameter names from function signature\\n    const functionStr = controller.toString();\\n\\n    // Match function parameters using regex\\n    const match = functionStr.match(/\\\\(([^)]*)\\\\)/);\\n    if (!match || !match[1]) {\\n      return [];\\n    }\\n\\n    const paramStr = match[1];\\n    if (!paramStr) {\\n      return [];\\n    }\\n\\n    const paramNames = paramStr\\n      .split(\\\",\\\")\\n      .map((param) => param.trim().split(\\\"=\\\")[0]?.split(\\\":\\\")[0]?.trim() || \\\"\\\")\\n      .filter((name) => name.length > 0);\\n\\n    return paramNames.map((name, index) => ({\\n      name,\\n      position: index,\\n    }));\\n  }\\n\\n  /**\\n   * Extract route parameters (excluding internal keys like _controller and _route)\\n   *\\n   * @param route - The matched route object\\n   * @returns Object containing only the route parameters\\n   *\\n   * @private\\n   */\\n  private extractRouteParams(\\n    route: Record<string, unknown>,\\n  ): Record<string, unknown> {\\n    const params: Record<string, unknown> = {};\\n\\n    Object.entries(route).forEach(([key, value]) => {\\n      if (!key.startsWith(\\\"_\\\")) {\\n        params[key] = value;\\n      }\\n    });\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Check if an error is a method not allowed exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a method not allowed exception\\n   *\\n   * @private\\n   */\\n  private isMethodNotAllowedException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"MethodNotAllowedException\\\") ||\\n        (\\\"code\\\" in error && error.code === 405)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Check if an error is a resource not found exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a resource not found exception\\n   *\\n   * @private\\n   */\\n  private isResourceNotFoundException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"ResourceNotFoundException\\\") ||\\n        (\\\"code\\\" in error && error.code === 404)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Get allowed methods from a method not allowed exception\\n   *\\n   * @param error - The method not allowed exception\\n   * @returns Comma-separated string of allowed methods\\n   *\\n   * @private\\n   */\\n  private getAllowedMethods(error: unknown): string {\\n    if (\\n      typeof error === \\\"object\\\" &&\\n      error !== null &&\\n      \\\"allowedMethods\\\" in error\\n    ) {\\n      const allowedMethods = (error as { allowedMethods?: unknown })\\n        .allowedMethods;\\n      if (Array.isArray(allowedMethods)) {\\n        return allowedMethods.join(\\\", \\\");\\n      }\\n      if (typeof allowedMethods === \\\"string\\\") {\\n        return allowedMethods;\\n      }\\n    }\\n    return \\\"OPTIONS, GET, POST, PUT, DELETE, PATCH\\\";\\n  }\\n\\n  /**\\n   * Send an HTTP response to the connection\\n   *\\n   * @param connection - The connection to send the response to\\n   * @param response - The response data\\n   * @returns The connection for chaining\\n   *\\n   * @private\\n   */\\n  private sendResponse(connection: Connection, response: unknown): Connection {\\n    if (response) {\\n      const responseData =\\n        typeof response === \\\"string\\\"\\n          ? response\\n          : response instanceof Uint8Array\\n            ? response\\n            : JSON.stringify(response);\\n      connection.send(responseData);\\n    }\\n    connection.close();\\n    return connection;\\n  }\\n\\n  /**\\n   * Close a connection with an HTTP error response\\n   *\\n   * Sends a properly formatted HTTP error response and closes the connection.\\n   *\\n   * @param connection - The connection to close\\n   * @param statusCode - The HTTP status code\\n   * @param message - The error message\\n   * @param additionalHeaders - Optional additional headers to include\\n   *\\n   * @private\\n   */\\n  private close(\\n    connection: Connection,\\n    statusCode: number,\\n    message: string,\\n    additionalHeaders: Record<string, string> = {},\\n  ): void {\\n    const statusText = this.getStatusText(statusCode);\\n    const body = JSON.stringify({ error: message });\\n    const bodyLength = Buffer.byteLength(body, \\\"utf8\\\");\\n\\n    const headers: Record<string, string> = {\\n      \\\"Content-Type\\\": \\\"application/json\\\",\\n      \\\"Content-Length\\\": String(bodyLength),\\n      ...additionalHeaders,\\n    };\\n\\n    const headerLines = Object.entries(headers)\\n      .map(([key, value]) => `${key}: ${value}`)\\n      .join(\\\"\\\\r\\\\n\\\");\\n\\n    const response = `HTTP/1.1 ${statusCode} ${statusText}\\\\r\\\\n${headerLines}\\\\r\\\\n\\\\r\\\\n${body}`;\\n\\n    try {\\n      connection.send(response);\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n\\n    try {\\n      connection.close();\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n  }\\n\\n  /**\\n   * Get the HTTP status text for a given status code\\n   *\\n   * @param statusCode - The HTTP status code\\n   * @returns The HTTP status reason phrase\\n   *\\n   * @private\\n   */\\n  private getStatusText(statusCode: number): string {\\n    const statusTexts: Record<number, string> = {\\n      400: \\\"Bad Request\\\",\\n      404: \\\"Not Found\\\",\\n      405: \\\"Method Not Allowed\\\",\\n      500: \\\"Internal Server Error\\\",\\n    };\\n\\n    return statusTexts[statusCode] ?? \\\"Unknown\\\";\\n  }\\n}\\n\\n/**\\n * HTTP Request interface\\n *\\n * Represents an HTTP request object with methods to access headers, method, path, etc.\\n */\\nexport interface IHttpRequest {\\n  /**\\n   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\\n   */\\n  method: string;\\n\\n  /**\\n   * Request path with query string - property for direct access\\n   */\\n  path: string;\\n\\n  /**\\n   * Request body content - property for direct access\\n   */\\n  body: string;\\n\\n  /**\\n   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\\n   */\\n  getMethod(): string;\\n\\n  /**\\n   * Get the request path\\n   */\\n  getPath(): string;\\n\\n  /**\\n   * Get the request host\\n   */\\n  getHost(): string;\\n\\n  /**\\n   * Get a specific header value\\n   */\\n  getHeader(name: string): string | undefined;\\n\\n  /**\\n   * Get all headers\\n   */\\n  getHeaders(): Record<string, string>;\\n\\n  /**\\n   * Get the request URI\\n   */\\n  getUri(): {\\n    path: string;\\n    host: string;\\n  };\\n}\\n\\n/**\\n * Route matcher interface\\n *\\n * Handles route matching and context management\\n */\\nexport interface IRouteMatcher {\\n  /**\\n   * Set the matcher context (method, host, etc.)\\n   */\\n  setContext(context: MatcherContext): void;\\n\\n  /**\\n   * Match a path to a route\\n   */\\n  match(path: string): Record<string, unknown>;\\n\\n  /**\\n   * Get the current context\\n   */\\n  getContext(): MatcherContext;\\n}\\n\\n/**\\n * Route matcher context\\n */\\nexport interface MatcherContext {\\n  method: string;\\n  host: string;\\n}\\n\\n/**\\n * Controller callback type\\n *\\n * Represents a controller function that can be called with request and route parameters\\n */\\nexport type ControllerCallback = (\\n  ...args: unknown[]\\n) => unknown | Promise<unknown>;\\n\"\n        }\n      }\n    }\n\n### Tool · edit (started)",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "        }",
                    "lineNumber": 5349,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5350,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 5351,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5352,
                    "isSignature": false
                  },
                  {
                    "text": "### Assistant",
                    "lineNumber": 5353,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5354,
                    "isSignature": false
                  },
                  {
                    "text": "Fixing router.ts to handle our Response class:",
                    "lineNumber": 5355,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5356,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (started)",
                    "lineNumber": 5357,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5358,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 5359,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 5360,
                    "isSignature": false
                  },
                  {
                    "text": "        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\"",
                    "lineNumber": 5361,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5362,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 5363,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5364,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (completed)",
                    "lineNumber": 5365,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5366,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 5367,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 5368,
                    "isSignature": false
                  },
                  {
                    "text": "        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\"",
                    "lineNumber": 5369,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 5370,
                    "isSignature": false
                  },
                  {
                    "text": "      \"result\": {",
                    "lineNumber": 5371,
                    "isSignature": false
                  },
                  {
                    "text": "        \"success\": {",
                    "lineNumber": 5372,
                    "isSignature": false
                  },
                  {
                    "text": "          \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/router.ts\",",
                    "lineNumber": 5373,
                    "isSignature": false
                  },
                  {
                    "text": "          \"resultForModel\": \"\",",
                    "lineNumber": 5374,
                    "isSignature": false
                  },
                  {
                    "text": "          \"linesAdded\": 1,",
                    "lineNumber": 5375,
                    "isSignature": false
                  },
                  {
                    "text": "          \"linesRemoved\": 0,",
                    "lineNumber": 5376,
                    "isSignature": false
                  },
                  {
                    "text": "          \"diffString\": \"  import { createHash } from \\\"node:crypto\\\";\\n  import type { Connection } from \\\"./connection\\\";\\n+ import { Response as HttpResponse } from \\\"./response\\\";\\n  \\n  /**\",",
                    "lineNumber": 5377,
                    "isSignature": false
                  },
                  {
                    "text": "          \"beforeFullFileContent\": \"import { createHash } from \\\"node:crypto\\\";\\nimport type { Connection } from \\\"./connection\\\";\\n\\n/**\\n * HTTP Router for request dispatch and WebSocket upgrade handling\\n *\\n * The Router class handles:\\n * - Request routing and dispatch to controllers\\n * - WebSocket upgrade detection and handshake (RFC 6455)\\n * - Controller parameter resolution\\n * - HTTP error handling (404, 405, 500)\\n *\\n * Key Features:\\n * - dispatch() method matches request to route and calls controller\\n * - WebSocket upgrade detection via \\\"Upgrade: websocket\\\" header\\n * - RFC 6455 WebSocket handshake negotiation with proper key generation\\n * - Controller parameter resolution from route and request context\\n * - Graceful HTTP error responses (404, 405, 500)\\n *\\n * @example\\n * ```typescript\\n * const router = new Router(routeMatcher);\\n * const result = await router.dispatch(request, connection);\\n * ```\\n */\\nexport class Router {\\n  /**\\n   * WebSocket upgrade magic GUID as defined in RFC 6455\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3\\n   */\\n  private static readonly WS_GUID = \\\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\\\";\\n\\n  /**\\n   * Create a new Router instance\\n   *\\n   * @param matcher - The route matcher instance (implements IRouteMatcher)\\n   */\\n  constructor(private matcher: IRouteMatcher) {}\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, unknown>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          if (connection) {\\n            this.close(connection, 405, \\\"Method not allowed.\\\", {\\n              Allow: allowedMethods,\\n            });\\n          }\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          if (connection) {\\n            this.close(connection, 404, \\\"Not found.\\\");\\n          }\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n  private controller(route: Record<string, unknown>): ControllerCallback {\\n    const controller = route._controller;\\n    if (typeof controller === \\\"function\\\") {\\n      return controller as ControllerCallback;\\n    }\\n    throw new Error(\\\"Invalid controller in route\\\");\\n  }\\n\\n  /**\\n   * Determine whether the request is for a WebSocket connection\\n   *\\n   * Checks for the \\\"Upgrade: websocket\\\" header as defined in RFC 6455\\n   *\\n   * @param request - The HTTP request object\\n   * @returns true if the request is a WebSocket upgrade request\\n   *\\n   * @private\\n   */\\n  private isWebSocketRequest(request: IHttpRequest): boolean {\\n    const upgradeHeader = request.getHeader(\\\"upgrade\\\")?.toLowerCase();\\n    return upgradeHeader === \\\"websocket\\\";\\n  }\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(\\n    request: IHttpRequest,\\n    connection: Connection,\\n  ): Connection {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader(\\\"sec-websocket-key\\\");\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, \\\"Missing Sec-WebSocket-Key header.\\\");\\n      throw new Error(\\\"WebSocket upgrade failed: missing Sec-WebSocket-Key\\\");\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = \\\"HTTP/1.1 101 Switching Protocols\\\\r\\\\n\\\";\\n    const headers = [\\n      \\\"Upgrade: websocket\\\",\\n      \\\"Connection: Upgrade\\\",\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      \\\"X-Powered-By: Reverb\\\",\\n    ];\\n\\n    const responseHeaders = `${headers.join(\\\"\\\\r\\\\n\\\")}\\\\r\\\\n\\\\r\\\\n`;\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n  private generateAcceptKey(secWebSocketKey: string): string {\\n    const concatenated = secWebSocketKey + Router.WS_GUID;\\n    const hash = createHash(\\\"sha1\\\").update(concatenated).digest();\\n    return hash.toString(\\\"base64\\\");\\n  }\\n\\n  /**\\n   * Get the arguments for the controller\\n   *\\n   * Resolves controller parameters from the available route parameters.\\n   * Uses reflection to determine parameter names and matches them to\\n   * values from the route parameters object.\\n   *\\n   * @param controller - The controller function/callback\\n   * @param routeParameters - Object containing all available parameters\\n   * @returns Array of arguments in the correct order for the controller\\n   *\\n   * @private\\n   */\\n  private arguments(\\n    controller: ControllerCallback,\\n    routeParameters: Record<string, unknown>,\\n  ): unknown[] {\\n    const params = this.parameters(controller);\\n\\n    return params.map((param) => {\\n      return routeParameters[param.name] ?? null;\\n    });\\n  }\\n\\n  /**\\n   * Get the parameters for the controller function\\n   *\\n   * Uses JavaScript introspection to extract parameter names from the function.\\n   * Returns an array of parameter metadata.\\n   *\\n   * @param controller - The controller function/callback\\n   * @returns Array of parameter metadata objects with name, type, and position\\n   *\\n   * @private\\n   */\\n  private parameters(\\n    controller: ControllerCallback,\\n  ): Array<{ name: string; position: number }> {\\n    if (typeof controller !== \\\"function\\\") {\\n      return [];\\n    }\\n\\n    // Extract parameter names from function signature\\n    const functionStr = controller.toString();\\n\\n    // Match function parameters using regex\\n    const match = functionStr.match(/\\\\(([^)]*)\\\\)/);\\n    if (!match || !match[1]) {\\n      return [];\\n    }\\n\\n    const paramStr = match[1];\\n    if (!paramStr) {\\n      return [];\\n    }\\n\\n    const paramNames = paramStr\\n      .split(\\\",\\\")\\n      .map((param) => param.trim().split(\\\"=\\\")[0]?.split(\\\":\\\")[0]?.trim() || \\\"\\\")\\n      .filter((name) => name.length > 0);\\n\\n    return paramNames.map((name, index) => ({\\n      name,\\n      position: index,\\n    }));\\n  }\\n\\n  /**\\n   * Extract route parameters (excluding internal keys like _controller and _route)\\n   *\\n   * @param route - The matched route object\\n   * @returns Object containing only the route parameters\\n   *\\n   * @private\\n   */\\n  private extractRouteParams(\\n    route: Record<string, unknown>,\\n  ): Record<string, unknown> {\\n    const params: Record<string, unknown> = {};\\n\\n    Object.entries(route).forEach(([key, value]) => {\\n      if (!key.startsWith(\\\"_\\\")) {\\n        params[key] = value;\\n      }\\n    });\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Check if an error is a method not allowed exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a method not allowed exception\\n   *\\n   * @private\\n   */\\n  private isMethodNotAllowedException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"MethodNotAllowedException\\\") ||\\n        (\\\"code\\\" in error && error.code === 405)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Check if an error is a resource not found exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a resource not found exception\\n   *\\n   * @private\\n   */\\n  private isResourceNotFoundException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"ResourceNotFoundException\\\") ||\\n        (\\\"code\\\" in error && error.code === 404)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Get allowed methods from a method not allowed exception\\n   *\\n   * @param error - The method not allowed exception\\n   * @returns Comma-separated string of allowed methods\\n   *\\n   * @private\\n   */\\n  private getAllowedMethods(error: unknown): string {\\n    if (\\n      typeof error === \\\"object\\\" &&\\n      error !== null &&\\n      \\\"allowedMethods\\\" in error\\n    ) {\\n      const allowedMethods = (error as { allowedMethods?: unknown })\\n        .allowedMethods;\\n      if (Array.isArray(allowedMethods)) {\\n        return allowedMethods.join(\\\", \\\");\\n      }\\n      if (typeof allowedMethods === \\\"string\\\") {\\n        return allowedMethods;\\n      }\\n    }\\n    return \\\"OPTIONS, GET, POST, PUT, DELETE, PATCH\\\";\\n  }\\n\\n  /**\\n   * Send an HTTP response to the connection\\n   *\\n   * @param connection - The connection to send the response to\\n   * @param response - The response data\\n   * @returns The connection for chaining\\n   *\\n   * @private\\n   */\\n  private sendResponse(connection: Connection, response: unknown): Connection {\\n    if (response) {\\n      const responseData =\\n        typeof response === \\\"string\\\"\\n          ? response\\n          : response instanceof Uint8Array\\n            ? response\\n            : JSON.stringify(response);\\n      connection.send(responseData);\\n    }\\n    connection.close();\\n    return connection;\\n  }\\n\\n  /**\\n   * Close a connection with an HTTP error response\\n   *\\n   * Sends a properly formatted HTTP error response and closes the connection.\\n   *\\n   * @param connection - The connection to close\\n   * @param statusCode - The HTTP status code\\n   * @param message - The error message\\n   * @param additionalHeaders - Optional additional headers to include\\n   *\\n   * @private\\n   */\\n  private close(\\n    connection: Connection,\\n    statusCode: number,\\n    message: string,\\n    additionalHeaders: Record<string, string> = {},\\n  ): void {\\n    const statusText = this.getStatusText(statusCode);\\n    const body = JSON.stringify({ error: message });\\n    const bodyLength = Buffer.byteLength(body, \\\"utf8\\\");\\n\\n    const headers: Record<string, string> = {\\n      \\\"Content-Type\\\": \\\"application/json\\\",\\n      \\\"Content-Length\\\": String(bodyLength),\\n      ...additionalHeaders,\\n    };\\n\\n    const headerLines = Object.entries(headers)\\n      .map(([key, value]) => `${key}: ${value}`)\\n      .join(\\\"\\\\r\\\\n\\\");\\n\\n    const response = `HTTP/1.1 ${statusCode} ${statusText}\\\\r\\\\n${headerLines}\\\\r\\\\n\\\\r\\\\n${body}`;\\n\\n    try {\\n      connection.send(response);\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n\\n    try {\\n      connection.close();\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n  }\\n\\n  /**\\n   * Get the HTTP status text for a given status code\\n   *\\n   * @param statusCode - The HTTP status code\\n   * @returns The HTTP status reason phrase\\n   *\\n   * @private\\n   */\\n  private getStatusText(statusCode: number): string {\\n    const statusTexts: Record<number, string> = {\\n      400: \\\"Bad Request\\\",\\n      404: \\\"Not Found\\\",\\n      405: \\\"Method Not Allowed\\\",\\n      500: \\\"Internal Server Error\\\",\\n    };\\n\\n    return statusTexts[statusCode] ?? \\\"Unknown\\\";\\n  }\\n}\\n\\n/**\\n * HTTP Request interface\\n *\\n * Represents an HTTP request object with methods to access headers, method, path, etc.\\n */\\nexport interface IHttpRequest {\\n  /**\\n   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\\n   */\\n  method: string;\\n\\n  /**\\n   * Request path with query string - property for direct access\\n   */\\n  path: string;\\n\\n  /**\\n   * Request body content - property for direct access\\n   */\\n  body: string;\\n\\n  /**\\n   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\\n   */\\n  getMethod(): string;\\n\\n  /**\\n   * Get the request path\\n   */\\n  getPath(): string;\\n\\n  /**\\n   * Get the request host\\n   */\\n  getHost(): string;\\n\\n  /**\\n   * Get a specific header value\\n   */\\n  getHeader(name: string): string | undefined;\\n\\n  /**\\n   * Get all headers\\n   */\\n  getHeaders(): Record<string, string>;\\n\\n  /**\\n   * Get the request URI\\n   */\\n  getUri(): {\\n    path: string;\\n    host: string;\\n  };\\n}\\n\\n/**\\n * Route matcher interface\\n *\\n * Handles route matching and context management\\n */\\nexport interface IRouteMatcher {\\n  /**\\n   * Set the matcher context (method, host, etc.)\\n   */\\n  setContext(context: MatcherContext): void;\\n\\n  /**\\n   * Match a path to a route\\n   */\\n  match(path: string): Record<string, unknown>;\\n\\n  /**\\n   * Get the current context\\n   */\\n  getContext(): MatcherContext;\\n}\\n\\n/**\\n * Route matcher context\\n */\\nexport interface MatcherContext {\\n  method: string;\\n  host: string;\\n}\\n\\n/**\\n * Controller callback type\\n *\\n * Represents a controller function that can be called with request and route parameters\\n */\\nexport type ControllerCallback = (\\n  ...args: unknown[]\\n) => unknown | Promise<unknown>;\\n\",",
                    "lineNumber": 5378,
                    "isSignature": false
                  },
                  {
                    "text": "          \"afterFullFileContent\": \"import { createHash } from \\\"node:crypto\\\";\\nimport type { Connection } from \\\"./connection\\\";\\nimport { Response as HttpResponse } from \\\"./response\\\";\\n\\n/**\\n * HTTP Router for request dispatch and WebSocket upgrade handling\\n *\\n * The Router class handles:\\n * - Request routing and dispatch to controllers\\n * - WebSocket upgrade detection and handshake (RFC 6455)\\n * - Controller parameter resolution\\n * - HTTP error handling (404, 405, 500)\\n *\\n * Key Features:\\n * - dispatch() method matches request to route and calls controller\\n * - WebSocket upgrade detection via \\\"Upgrade: websocket\\\" header\\n * - RFC 6455 WebSocket handshake negotiation with proper key generation\\n * - Controller parameter resolution from route and request context\\n * - Graceful HTTP error responses (404, 405, 500)\\n *\\n * @example\\n * ```typescript\\n * const router = new Router(routeMatcher);\\n * const result = await router.dispatch(request, connection);\\n * ```\\n */\\nexport class Router {\\n  /**\\n   * WebSocket upgrade magic GUID as defined in RFC 6455\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-1.3\\n   */\\n  private static readonly WS_GUID = \\\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\\\";\\n\\n  /**\\n   * Create a new Router instance\\n   *\\n   * @param matcher - The route matcher instance (implements IRouteMatcher)\\n   */\\n  constructor(private matcher: IRouteMatcher) {}\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, unknown>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          if (connection) {\\n            this.close(connection, 405, \\\"Method not allowed.\\\", {\\n              Allow: allowedMethods,\\n            });\\n          }\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          if (connection) {\\n            this.close(connection, 404, \\\"Not found.\\\");\\n          }\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n  private controller(route: Record<string, unknown>): ControllerCallback {\\n    const controller = route._controller;\\n    if (typeof controller === \\\"function\\\") {\\n      return controller as ControllerCallback;\\n    }\\n    throw new Error(\\\"Invalid controller in route\\\");\\n  }\\n\\n  /**\\n   * Determine whether the request is for a WebSocket connection\\n   *\\n   * Checks for the \\\"Upgrade: websocket\\\" header as defined in RFC 6455\\n   *\\n   * @param request - The HTTP request object\\n   * @returns true if the request is a WebSocket upgrade request\\n   *\\n   * @private\\n   */\\n  private isWebSocketRequest(request: IHttpRequest): boolean {\\n    const upgradeHeader = request.getHeader(\\\"upgrade\\\")?.toLowerCase();\\n    return upgradeHeader === \\\"websocket\\\";\\n  }\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(\\n    request: IHttpRequest,\\n    connection: Connection,\\n  ): Connection {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader(\\\"sec-websocket-key\\\");\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, \\\"Missing Sec-WebSocket-Key header.\\\");\\n      throw new Error(\\\"WebSocket upgrade failed: missing Sec-WebSocket-Key\\\");\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = \\\"HTTP/1.1 101 Switching Protocols\\\\r\\\\n\\\";\\n    const headers = [\\n      \\\"Upgrade: websocket\\\",\\n      \\\"Connection: Upgrade\\\",\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      \\\"X-Powered-By: Reverb\\\",\\n    ];\\n\\n    const responseHeaders = `${headers.join(\\\"\\\\r\\\\n\\\")}\\\\r\\\\n\\\\r\\\\n`;\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n  private generateAcceptKey(secWebSocketKey: string): string {\\n    const concatenated = secWebSocketKey + Router.WS_GUID;\\n    const hash = createHash(\\\"sha1\\\").update(concatenated).digest();\\n    return hash.toString(\\\"base64\\\");\\n  }\\n\\n  /**\\n   * Get the arguments for the controller\\n   *\\n   * Resolves controller parameters from the available route parameters.\\n   * Uses reflection to determine parameter names and matches them to\\n   * values from the route parameters object.\\n   *\\n   * @param controller - The controller function/callback\\n   * @param routeParameters - Object containing all available parameters\\n   * @returns Array of arguments in the correct order for the controller\\n   *\\n   * @private\\n   */\\n  private arguments(\\n    controller: ControllerCallback,\\n    routeParameters: Record<string, unknown>,\\n  ): unknown[] {\\n    const params = this.parameters(controller);\\n\\n    return params.map((param) => {\\n      return routeParameters[param.name] ?? null;\\n    });\\n  }\\n\\n  /**\\n   * Get the parameters for the controller function\\n   *\\n   * Uses JavaScript introspection to extract parameter names from the function.\\n   * Returns an array of parameter metadata.\\n   *\\n   * @param controller - The controller function/callback\\n   * @returns Array of parameter metadata objects with name, type, and position\\n   *\\n   * @private\\n   */\\n  private parameters(\\n    controller: ControllerCallback,\\n  ): Array<{ name: string; position: number }> {\\n    if (typeof controller !== \\\"function\\\") {\\n      return [];\\n    }\\n\\n    // Extract parameter names from function signature\\n    const functionStr = controller.toString();\\n\\n    // Match function parameters using regex\\n    const match = functionStr.match(/\\\\(([^)]*)\\\\)/);\\n    if (!match || !match[1]) {\\n      return [];\\n    }\\n\\n    const paramStr = match[1];\\n    if (!paramStr) {\\n      return [];\\n    }\\n\\n    const paramNames = paramStr\\n      .split(\\\",\\\")\\n      .map((param) => param.trim().split(\\\"=\\\")[0]?.split(\\\":\\\")[0]?.trim() || \\\"\\\")\\n      .filter((name) => name.length > 0);\\n\\n    return paramNames.map((name, index) => ({\\n      name,\\n      position: index,\\n    }));\\n  }\\n\\n  /**\\n   * Extract route parameters (excluding internal keys like _controller and _route)\\n   *\\n   * @param route - The matched route object\\n   * @returns Object containing only the route parameters\\n   *\\n   * @private\\n   */\\n  private extractRouteParams(\\n    route: Record<string, unknown>,\\n  ): Record<string, unknown> {\\n    const params: Record<string, unknown> = {};\\n\\n    Object.entries(route).forEach(([key, value]) => {\\n      if (!key.startsWith(\\\"_\\\")) {\\n        params[key] = value;\\n      }\\n    });\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Check if an error is a method not allowed exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a method not allowed exception\\n   *\\n   * @private\\n   */\\n  private isMethodNotAllowedException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"MethodNotAllowedException\\\") ||\\n        (\\\"code\\\" in error && error.code === 405)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Check if an error is a resource not found exception\\n   *\\n   * @param error - The error to check\\n   * @returns true if the error is a resource not found exception\\n   *\\n   * @private\\n   */\\n  private isResourceNotFoundException(error: unknown): boolean {\\n    if (typeof error === \\\"object\\\" && error !== null) {\\n      return (\\n        (\\\"name\\\" in error && error.name === \\\"ResourceNotFoundException\\\") ||\\n        (\\\"code\\\" in error && error.code === 404)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Get allowed methods from a method not allowed exception\\n   *\\n   * @param error - The method not allowed exception\\n   * @returns Comma-separated string of allowed methods\\n   *\\n   * @private\\n   */\\n  private getAllowedMethods(error: unknown): string {\\n    if (\\n      typeof error === \\\"object\\\" &&\\n      error !== null &&\\n      \\\"allowedMethods\\\" in error\\n    ) {\\n      const allowedMethods = (error as { allowedMethods?: unknown })\\n        .allowedMethods;\\n      if (Array.isArray(allowedMethods)) {\\n        return allowedMethods.join(\\\", \\\");\\n      }\\n      if (typeof allowedMethods === \\\"string\\\") {\\n        return allowedMethods;\\n      }\\n    }\\n    return \\\"OPTIONS, GET, POST, PUT, DELETE, PATCH\\\";\\n  }\\n\\n  /**\\n   * Send an HTTP response to the connection\\n   *\\n   * @param connection - The connection to send the response to\\n   * @param response - The response data\\n   * @returns The connection for chaining\\n   *\\n   * @private\\n   */\\n  private sendResponse(connection: Connection, response: unknown): Connection {\\n    if (response) {\\n      const responseData =\\n        typeof response === \\\"string\\\"\\n          ? response\\n          : response instanceof Uint8Array\\n            ? response\\n            : JSON.stringify(response);\\n      connection.send(responseData);\\n    }\\n    connection.close();\\n    return connection;\\n  }\\n\\n  /**\\n   * Close a connection with an HTTP error response\\n   *\\n   * Sends a properly formatted HTTP error response and closes the connection.\\n   *\\n   * @param connection - The connection to close\\n   * @param statusCode - The HTTP status code\\n   * @param message - The error message\\n   * @param additionalHeaders - Optional additional headers to include\\n   *\\n   * @private\\n   */\\n  private close(\\n    connection: Connection,\\n    statusCode: number,\\n    message: string,\\n    additionalHeaders: Record<string, string> = {},\\n  ): void {\\n    const statusText = this.getStatusText(statusCode);\\n    const body = JSON.stringify({ error: message });\\n    const bodyLength = Buffer.byteLength(body, \\\"utf8\\\");\\n\\n    const headers: Record<string, string> = {\\n      \\\"Content-Type\\\": \\\"application/json\\\",\\n      \\\"Content-Length\\\": String(bodyLength),\\n      ...additionalHeaders,\\n    };\\n\\n    const headerLines = Object.entries(headers)\\n      .map(([key, value]) => `${key}: ${value}`)\\n      .join(\\\"\\\\r\\\\n\\\");\\n\\n    const response = `HTTP/1.1 ${statusCode} ${statusText}\\\\r\\\\n${headerLines}\\\\r\\\\n\\\\r\\\\n${body}`;\\n\\n    try {\\n      connection.send(response);\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n\\n    try {\\n      connection.close();\\n    } catch (_error) {\\n      // Connection may already be closed\\n    }\\n  }\\n\\n  /**\\n   * Get the HTTP status text for a given status code\\n   *\\n   * @param statusCode - The HTTP status code\\n   * @returns The HTTP status reason phrase\\n   *\\n   * @private\\n   */\\n  private getStatusText(statusCode: number): string {\\n    const statusTexts: Record<number, string> = {\\n      400: \\\"Bad Request\\\",\\n      404: \\\"Not Found\\\",\\n      405: \\\"Method Not Allowed\\\",\\n      500: \\\"Internal Server Error\\\",\\n    };\\n\\n    return statusTexts[statusCode] ?? \\\"Unknown\\\";\\n  }\\n}\\n\\n/**\\n * HTTP Request interface\\n *\\n * Represents an HTTP request object with methods to access headers, method, path, etc.\\n */\\nexport interface IHttpRequest {\\n  /**\\n   * HTTP method (GET, POST, PUT, DELETE, etc.) - property for direct access\\n   */\\n  method: string;\\n\\n  /**\\n   * Request path with query string - property for direct access\\n   */\\n  path: string;\\n\\n  /**\\n   * Request body content - property for direct access\\n   */\\n  body: string;\\n\\n  /**\\n   * Get the HTTP method (GET, POST, PUT, DELETE, etc.)\\n   */\\n  getMethod(): string;\\n\\n  /**\\n   * Get the request path\\n   */\\n  getPath(): string;\\n\\n  /**\\n   * Get the request host\\n   */\\n  getHost(): string;\\n\\n  /**\\n   * Get a specific header value\\n   */\\n  getHeader(name: string): string | undefined;\\n\\n  /**\\n   * Get all headers\\n   */\\n  getHeaders(): Record<string, string>;\\n\\n  /**\\n   * Get the request URI\\n   */\\n  getUri(): {\\n    path: string;\\n    host: string;\\n  };\\n}\\n\\n/**\\n * Route matcher interface\\n *\\n * Handles route matching and context management\\n */\\nexport interface IRouteMatcher {\\n  /**\\n   * Set the matcher context (method, host, etc.)\\n   */\\n  setContext(context: MatcherContext): void;\\n\\n  /**\\n   * Match a path to a route\\n   */\\n  match(path: string): Record<string, unknown>;\\n\\n  /**\\n   * Get the current context\\n   */\\n  getContext(): MatcherContext;\\n}\\n\\n/**\\n * Route matcher context\\n */\\nexport interface MatcherContext {\\n  method: string;\\n  host: string;\\n}\\n\\n/**\\n * Controller callback type\\n *\\n * Represents a controller function that can be called with request and route parameters\\n */\\nexport type ControllerCallback = (\\n  ...args: unknown[]\\n) => unknown | Promise<unknown>;\\n\"",
                    "lineNumber": 5379,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 5380,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5381,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 5382,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5383,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (started)",
                    "lineNumber": 5384,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.23719939589500427
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 10956,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 10972,
                    "column": 16
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/connection.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 0,\n                    \"column\": 0\n                  },\n                  \"endPosition\": {\n                    \"line\": 256,\n                    \"column\": 1\n                  }\n                },\n                \"contents\": \"import type { WebSocket } from \\\"bun\\\";\\nimport type { IWebSocketConnection, Frame } from \\\"../../contracts/websocket-connection\\\";\\n\\n/**\\n * WebSocket Connection Implementation\\n *\\n * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\\n * This class handles WebSocket frame operations, message buffering for fragmented messages,\\n * and control frame handling according to RFC 6455.\\n *\\n * Key responsibilities:\\n * - Provide unique connection identification\\n * - Send text/binary messages over the WebSocket\\n * - Send and handle control frames (PING, PONG, CLOSE)\\n * - Manage connection lifecycle with proper cleanup\\n *\\n * Note: Bun's WebSocket handles frame framing automatically, so we focus on\\n * providing a consistent API for message handling and control frames.\\n */\\nexport class Connection implements IWebSocketConnection {\\n  /**\\n   * Handler for complete messages.\\n   */\\n  private onMessageHandler?: (message: string | Buffer) => void;\\n\\n  /**\\n   * Handler for connection close.\\n   */\\n  // @ts-expect-error - Reserved for future use\\n  private _onCloseHandler?: () => void;\\n\\n  /**\\n   * Maximum allowed message payload size in bytes.\\n   */\\n  private maxMessageSize?: number;\\n\\n  /**\\n   * Unique connection identifier.\\n   */\\n  private connectionId: string;\\n\\n  /**\\n   * Create a new WebSocket connection instance.\\n   *\\n   * @param socket - The Bun WebSocket instance\\n   */\\n  constructor(private socket: WebSocket) {\\n    // Generate a unique connection ID using the socket's internal data\\n    this.connectionId = this.generateConnectionId();\\n    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\\n    // not on individual socket objects. We don't need setupHandlers() here.\\n  }\\n\\n  /**\\n   * Generate a unique connection identifier.\\n   * Uses the socket's remoteAddress and a timestamp for uniqueness.\\n   */\\n}\",\n                \"signatures\": {\n                  \"ranges\": []\n                ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 10957,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 10958,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/connection.ts\",",
                    "lineNumber": 10959,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 10960,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 10961,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 0,",
                    "lineNumber": 10962,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 0",
                    "lineNumber": 10963,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10964,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 10965,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 256,",
                    "lineNumber": 10966,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 1",
                    "lineNumber": 10967,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 10968,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 10969,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"import type { WebSocket } from \\\"bun\\\";\\nimport type { IWebSocketConnection, Frame } from \\\"../../contracts/websocket-connection\\\";\\n\\n/**\\n * WebSocket Connection Implementation\\n *\\n * Wraps Bun's native WebSocket to provide the IWebSocketConnection interface.\\n * This class handles WebSocket frame operations, message buffering for fragmented messages,\\n * and control frame handling according to RFC 6455.\\n *\\n * Key responsibilities:\\n * - Provide unique connection identification\\n * - Send text/binary messages over the WebSocket\\n * - Send and handle control frames (PING, PONG, CLOSE)\\n * - Manage connection lifecycle with proper cleanup\\n *\\n * Note: Bun's WebSocket handles frame framing automatically, so we focus on\\n * providing a consistent API for message handling and control frames.\\n */\\nexport class Connection implements IWebSocketConnection {\\n  /**\\n   * Handler for complete messages.\\n   */\\n  private onMessageHandler?: (message: string | Buffer) => void;\\n\\n  /**\\n   * Handler for connection close.\\n   */\\n  // @ts-expect-error - Reserved for future use\\n  private _onCloseHandler?: () => void;\\n\\n  /**\\n   * Maximum allowed message payload size in bytes.\\n   */\\n  private maxMessageSize?: number;\\n\\n  /**\\n   * Unique connection identifier.\\n   */\\n  private connectionId: string;\\n\\n  /**\\n   * Create a new WebSocket connection instance.\\n   *\\n   * @param socket - The Bun WebSocket instance\\n   */\\n  constructor(private socket: WebSocket) {\\n    // Generate a unique connection ID using the socket's internal data\\n    this.connectionId = this.generateConnectionId();\\n    // Note: For Bun's server-side WebSockets, handlers are set in serve() options,\\n    // not on individual socket objects. We don't need setupHandlers() here.\\n  }\\n\\n  /**\\n   * Generate a unique connection identifier.\\n   * Uses the socket's remoteAddress and a timestamp for uniqueness.\\n   */\\n}\",",
                    "lineNumber": 10970,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 10971,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": []",
                    "lineNumber": 10972,
                    "isSignature": false
                  },
                  {
                    "text": "                ",
                    "lineNumber": 10973,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.23593664169311523
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-1150.md",
                "range": {
                  "startPosition": {
                    "line": 5307,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 5326,
                    "column": 0
                  }
                },
                "contents": "    {\n      \"args\": {\n        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/server.ts\"\n      },\n      \"result\": {\n        \"success\": {\n          \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/server.ts\",\n          \"resultForModel\": \"\",\n          \"linesAdded\": 1,\n          \"linesRemoved\": 0,\n          \"diffString\": \"  import type { ILogger } from \\\"../../../contracts/logger\\\";\\n  import type { IHttpRequest, Router } from \\\"./router\\\";\\n+ import { Response as HttpResponse } from \\\"./response\\\";\\n  \\n  /**\",\n          \"beforeFullFileContent\": \"import type { ServerWebSocket } from \\\"bun\\\";\\nimport type { ILogger } from \\\"../../../contracts/logger\\\";\\nimport type { IHttpRequest, Router } from \\\"./router\\\";\\n\\n/**\\n * HTTP Server Implementation\\n *\\n * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\\n * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\\n *\\n * Key features:\\n * - Accepts incoming TCP connections via Bun.serve()\\n * - HTTP request parsing and routing\\n * - WebSocket upgrade handling with full lifecycle management\\n * - Periodic garbage collection (every 30 seconds)\\n * - Graceful start/stop lifecycle management\\n * - TLS support detection\\n *\\n * The server uses Bun's native WebSocket API for efficient connection handling\\n * and automatic binary/text frame management.\\n *\\n * @example\\n * ```typescript\\n * const server = new Server({\\n *   port: 8080,\\n *   host: 'localhost',\\n *   logger,\\n *   router,\\n *   maxRequestSize: 1024 * 1024,\\n *   tls: null,\\n * });\\n *\\n * server.start();\\n * // Server is now accepting connections...\\n *\\n * // Later, to stop:\\n * server.stop();\\n * ```\\n */\\nexport class Server {\\n  /**\\n   * The underlying Bun server instance.\\n   *\\n   * @private\\n   */\\n  private bunServer: ReturnType<typeof Bun.serve> | null = null;\\n\\n  /**\\n   * Periodic timer for garbage collection.\\n   *\\n   * @private\\n   */\\n  private gcTimer: Timer | null = null;\\n\\n  /**\\n   * Indicates whether the server is running.\\n   *\\n   * @private\\n   */\\n  private isRunning = false;\\n\\n  /**\\n   * Server configuration options.\\n   *\\n   * @private\\n   */\\n  private readonly config: ServerConfig;\\n\\n  /**\\n   * Create a new HTTP server instance.\\n   *\\n   * Initializes the server with configuration, logger, and router.\\n   * Disables automatic garbage collection and sets up periodic manual GC.\\n   *\\n   * @param config - Server configuration object\\n   */\\n  constructor(config: ServerConfig) {\\n    this.config = config;\\n\\n    // Disable automatic garbage collection; we'll do it manually\\n    if (typeof gc !== \\\"undefined\\\") {\\n      // Note: gc.disable() may not be available in all Bun versions\\n      (gc as { disable?: () => void }).disable?.();\\n    }\\n  }\\n\\n  /**\\n   * Start the HTTP server.\\n   *\\n   * Initializes Bun.serve() with the configured port, host, and handlers.\\n   * Sets up periodic garbage collection and error handling.\\n   * The server will accept both HTTP and WebSocket connections.\\n   *\\n   * @throws Will log errors but not throw directly; error handling is done\\n   *         through the logger interface\\n   */\\n  start(): void {\\n    try {\\n      const config: {\\n        port: number;\\n        hostname: string;\\n        fetch: (\\n          req: Request,\\n          server: ReturnType<typeof Bun.serve>,\\n        ) => Promise<Response | undefined>;\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => void;\\n          message: (\\n            ws: ServerWebSocket<unknown>,\\n            message: string | Buffer,\\n          ) => void;\\n          close: (\\n            ws: ServerWebSocket<unknown>,\\n            code: number,\\n            reason: string,\\n          ) => void;\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n        };\\n        tls?: BunTLSOptions;\\n      } = {\\n        port: this.config.port,\\n        hostname: this.config.host,\\n        fetch: (req: Request, server: ReturnType<typeof Bun.serve>) =>\\n          this.handleRequest(req, server),\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => this.handleWebSocketOpen(ws),\\n          message: (ws: ServerWebSocket<unknown>, message: string | Buffer) =>\\n            this.handleWebSocketMessage(ws, message),\\n          close: (ws: ServerWebSocket<unknown>, code: number, reason: string) =>\\n            this.handleWebSocketClose(ws, code, reason),\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPing(ws, data),\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPong(ws, data),\\n        },\\n      };\\n\\n      // Only add TLS if it's defined (not null or undefined)\\n      if (this.config.tls) {\\n        config.tls = this.config.tls;\\n      }\\n\\n      this.bunServer = Bun.serve(config);\\n\\n      this.isRunning = true;\\n\\n      // Set up periodic garbage collection every 30 seconds\\n      this.gcTimer = setInterval(() => {\\n        if (typeof gc !== \\\"undefined\\\") {\\n          // Note: gc.collect() may not be available in all Bun versions\\n          (gc as { collect?: () => void }).collect?.();\\n        }\\n      }, 30_000);\\n\\n      this.config.logger.info(\\n        \\\"Server started\\\",\\n        `Listening on ${this.config.host}:${this.config.port}`,\\n      );\\n    } catch (error) {\\n      const message = error instanceof Error ? error.message : String(error);\\n      this.config.logger.error(message);\\n      this.isRunning = false;\\n    }\\n  }\\n\\n  /**\\n   * Stop the HTTP server.\\n   *\\n   * Gracefully shuts down the server, stops garbage collection,\\n   * and closes all connections.\\n   */\\n  stop(): void {\\n    this.isRunning = false;\\n\\n    // Stop garbage collection timer\\n    if (this.gcTimer) {\\n      clearInterval(this.gcTimer);\\n      this.gcTimer = null;\\n    }\\n\\n    // Close the Bun server\\n    if (this.bunServer) {\\n      this.bunServer.stop();\\n      this.bunServer = null;\\n    }\\n\\n    this.config.logger.info(\\\"Server stopped\\\");\\n  }\\n\\n  /**\\n   * Handle incoming HTTP requests.\\n   *\\n   * Routes HTTP requests and handles WebSocket upgrades.\\n   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.\\n   * For regular HTTP requests, this routes to the router for application logic.\\n   *\\n   * @param req - The incoming HTTP request\\n   * @param server - The Bun server instance (used for WebSocket upgrades)\\n   * @returns A Response object for the request\\n   *\\n   * @private\\n   */\\n  private async handleRequest(\\n    req: Request,\\n    server: ReturnType<typeof Bun.serve>,\\n  ): Promise<Response | undefined> {\\n    const url = new URL(req.url);\\n    const pathname = url.pathname;\\n\\n    // Attempt WebSocket upgrade for specific paths\\n    if (this.shouldUpgradeToWebSocket(pathname, req)) {\\n      if (server.upgrade(req, { data: null })) {\\n        return undefined;\\n      }\\n    }\\n\\n    // Route HTTP requests\\n    try {\\n      // Convert Bun Request to IHttpRequest\\n      const httpRequest = await this.convertToHttpRequest(req);\\n      // For HTTP requests, pass null as connection since we don't have a Connection object yet\\n      const result = await this.config.router.dispatch(httpRequest, null);\\n\\n      // If result is already a Response, return it\\n      if (result instanceof Response) {\\n        return result;\\n      }\\n\\n      // Otherwise, wrap result in a Response\\n      return new Response(JSON.stringify(result), {\\n        status: 200,\\n        headers: { \\\"content-type\\\": \\\"application/json\\\" },\\n      });\\n    } catch (error) {\\n      if (error instanceof HttpException) {\\n        return new Response(error.message, {\\n          status: error.statusCode,\\n          headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n        });\\n      }\\n\\n      const message =\\n        error instanceof Error ? error.message : \\\"Internal server error\\\";\\n      this.config.logger.error(message);\\n\\n      return new Response(\\\"Internal server error\\\", {\\n        status: 500,\\n        headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n      });\\n    }\\n  }\\n\\n  /**\\n   * Determine if a request should be upgraded to WebSocket.\\n   *\\n   * Checks if the request is a WebSocket upgrade request and if the path\\n   * is one that should be handled as a WebSocket connection.\\n   *\\n   * @param pathname - The request path\\n   * @param req - The incoming HTTP request\\n   * @returns true if the request should be upgraded to WebSocket\\n   *\\n   * @private\\n   */\\n  private shouldUpgradeToWebSocket(pathname: string, req: Request): boolean {\\n    // Check if this is a WebSocket upgrade request\\n    const upgrade = req.headers.get(\\\"upgrade\\\")?.toLowerCase();\\n    if (upgrade !== \\\"websocket\\\") {\\n      return false;\\n    }\\n\\n    // WebSocket connections typically use these paths\\n    return pathname === \\\"/app\\\" || pathname.startsWith(\\\"/app/\\\");\\n  }\\n\\n  /**\\n   * Handle WebSocket connection opened event.\\n   *\\n   * Called when a new WebSocket connection is successfully established.\\n   * This is where application-level connection setup would occur.\\n   *\\n   * @param ws - The WebSocket connection\\n   *\\n   * @private\\n   */\\n  private handleWebSocketOpen(_ws: ServerWebSocket<unknown>): void {\\n    // Application-level WebSocket handling would be done here\\n    // For now, this is a placeholder for lifecycle management\\n  }\\n\\n  /**\\n   * Handle WebSocket message received event.\\n   *\\n   * Routes incoming WebSocket messages to the application router\\n   * for processing.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param message - The message data (string or buffer)\\n   *\\n   * @private\\n   */\\n  private handleWebSocketMessage(\\n    _ws: ServerWebSocket<unknown>,\\n    _message: string | Buffer,\\n  ): void {\\n    // Application-level message routing would occur here\\n    // This delegates to the router or message handler\\n  }\\n\\n  /**\\n   * Handle WebSocket connection closed event.\\n   *\\n   * Called when a WebSocket connection is closed, either by the client,\\n   * server, or due to network issues.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param code - The WebSocket close code\\n   * @param reason - The reason for closing\\n   *\\n   * @private\\n   */\\n  private handleWebSocketClose(\\n    _ws: ServerWebSocket<unknown>,\\n    _code: number,\\n    _reason: string,\\n  ): void {\\n    // Application-level cleanup would occur here\\n    // This would handle connection state cleanup, event dispatching, etc.\\n  }\\n\\n  /**\\n   * Handle WebSocket ping frame received event.\\n   *\\n   * Automatically responds with a pong frame. This is typically\\n   * handled automatically by Bun, but can be customized for monitoring.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The ping frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPing(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Bun automatically sends a pong response, but we can log or monitor here\\n  }\\n\\n  /**\\n   * Handle WebSocket pong frame received event.\\n   *\\n   * Called when a pong response is received from the client.\\n   * Used to verify connection health and update activity tracking.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The pong frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPong(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Application-level pong handling would occur here\\n    // This would update connection state, mark as active, etc.\\n  }\\n\\n  /**\\n   * Convert Bun Request to IHttpRequest.\\n   *\\n   * @param req - The Bun Request object\\n   * @returns IHttpRequest interface\\n   *\\n   * @private\\n   */\\n  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {\\n    const url = new URL(req.url);\\n    const body =\\n      req.method !== \\\"GET\\\" && req.method !== \\\"HEAD\\\" ? await req.text() : \\\"\\\";\\n    const method = req.method;\\n    const pathWithQuery = url.pathname + url.search;\\n    const pathWithoutQuery = url.pathname;\\n    const host = url.host;\\n\\n    // Convert Headers to Record<string, string>\\n    const headers: Record<string, string> = {};\\n    req.headers.forEach((value, key) => {\\n      headers[key.toLowerCase()] = value;\\n    });\\n\\n    return {\\n      method,\\n      path: pathWithQuery,\\n      body,\\n      getMethod(): string {\\n        return method;\\n      },\\n      getPath(): string {\\n        return pathWithoutQuery;\\n      },\\n      getHost(): string {\\n        return host;\\n      },\\n      getHeader(name: string): string | undefined {\\n        return headers[name.toLowerCase()];\\n      },\\n      getHeaders(): Record<string, string> {\\n        return { ...headers };\\n      },\\n      getUri(): { path: string; host: string } {\\n        return { path: pathWithoutQuery, host };\\n      },\\n    };\\n  }\\n\\n  /**\\n   * Determine whether the server has TLS support.\\n   *\\n   * Checks if the server was configured with TLS certificates.\\n   *\\n   * @returns true if TLS is configured, false otherwise\\n   */\\n  isSecure(): boolean {\\n    return this.config.tls !== null && this.config.tls !== undefined;\\n  }\\n\\n  /**\\n   * Determine if the server is currently running.\\n   *\\n   * @returns true if the server is running, false otherwise\\n   */\\n  running(): boolean {\\n    return this.isRunning;\\n  }\\n}\\n\\n/**\\n * Server Configuration\\n *\\n * Configuration object for the HTTP server, including port, host,\\n * logger, router, and optional TLS settings.\\n */\\nexport interface ServerConfig {\\n  /**\\n   * The port to listen on (e.g., 8080)\\n   */\\n  port: number;\\n\\n  /**\\n   * The hostname to bind to (e.g., 'localhost' or '0.0.0.0')\\n   */\\n  host: string;\\n\\n  /**\\n   * The logger instance for output\\n   */\\n  logger: ILogger;\\n\\n  /**\\n   * The router for handling HTTP requests\\n   */\\n  router: Router;\\n\\n  /**\\n   * Maximum allowed request size in bytes\\n   */\\n  maxRequestSize: number;\\n\\n  /**\\n   * Optional TLS configuration for HTTPS/WSS support\\n   */\\n  tls?: BunTLSOptions | null;\\n}\\n\\n/**\\n * Bun TLS Options\\n *\\n * Configuration for TLS/HTTPS support in Bun.serve()\\n */\\nexport interface BunTLSOptions {\\n  /**\\n   * Path to the TLS certificate file\\n   */\\n  cert?: string | Buffer;\\n\\n  /**\\n   * Path to the TLS key file\\n   */\\n  key?: string | Buffer;\\n\\n  /**\\n   * Path to the CA certificate file (for client validation)\\n   */\\n  ca?: string | Buffer;\\n\\n  /**\\n   * Path to the PKCS#12 file (alternative to separate cert/key)\\n   */\\n  pkcs12?: Buffer;\\n\\n  /**\\n   * Passphrase for the key file\\n   */\\n  passphrase?: string;\\n}\\n\\n/**\\n * HTTP Exception\\n *\\n * Represents an HTTP error with a status code and message.\\n * Used for routing errors and validation failures.\\n */\\nexport class HttpException extends Error {\\n  /**\\n   * Create a new HTTP exception.\\n   *\\n   * @param statusCode - The HTTP status code (e.g., 404, 500)\\n   * @param message - The error message\\n   */\\n  constructor(\\n    public readonly statusCode: number,\\n    message: string,\\n  ) {\\n    super(message);\\n    this.name = \\\"HttpException\\\";\\n  }\\n}\\n\",\n          \"afterFullFileContent\": \"import type { ServerWebSocket } from \\\"bun\\\";\\nimport type { ILogger } from \\\"../../../contracts/logger\\\";\\nimport type { IHttpRequest, Router } from \\\"./router\\\";\\nimport { Response as HttpResponse } from \\\"./response\\\";\\n\\n/**\\n * HTTP Server Implementation\\n *\\n * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\\n * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\\n *\\n * Key features:\\n * - Accepts incoming TCP connections via Bun.serve()\\n * - HTTP request parsing and routing\\n * - WebSocket upgrade handling with full lifecycle management\\n * - Periodic garbage collection (every 30 seconds)\\n * - Graceful start/stop lifecycle management\\n * - TLS support detection\\n *\\n * The server uses Bun's native WebSocket API for efficient connection handling\\n * and automatic binary/text frame management.\\n *\\n * @example\\n * ```typescript\\n * const server = new Server({\\n *   port: 8080,\\n *   host: 'localhost',\\n *   logger,\\n *   router,\\n *   maxRequestSize: 1024 * 1024,\\n *   tls: null,\\n * });\\n *\\n * server.start();\\n * // Server is now accepting connections...\\n *\\n * // Later, to stop:\\n * server.stop();\\n * ```\\n */\\nexport class Server {\\n  /**\\n   * The underlying Bun server instance.\\n   *\\n   * @private\\n   */\\n  private bunServer: ReturnType<typeof Bun.serve> | null = null;\\n\\n  /**\\n   * Periodic timer for garbage collection.\\n   *\\n   * @private\\n   */\\n  private gcTimer: Timer | null = null;\\n\\n  /**\\n   * Indicates whether the server is running.\\n   *\\n   * @private\\n   */\\n  private isRunning = false;\\n\\n  /**\\n   * Server configuration options.\\n   *\\n   * @private\\n   */\\n  private readonly config: ServerConfig;\\n\\n  /**\\n   * Create a new HTTP server instance.\\n   *\\n   * Initializes the server with configuration, logger, and router.\\n   * Disables automatic garbage collection and sets up periodic manual GC.\\n   *\\n   * @param config - Server configuration object\\n   */\\n  constructor(config: ServerConfig) {\\n    this.config = config;\\n\\n    // Disable automatic garbage collection; we'll do it manually\\n    if (typeof gc !== \\\"undefined\\\") {\\n      // Note: gc.disable() may not be available in all Bun versions\\n      (gc as { disable?: () => void }).disable?.();\\n    }\\n  }\\n\\n  /**\\n   * Start the HTTP server.\\n   *\\n   * Initializes Bun.serve() with the configured port, host, and handlers.\\n   * Sets up periodic garbage collection and error handling.\\n   * The server will accept both HTTP and WebSocket connections.\\n   *\\n   * @throws Will log errors but not throw directly; error handling is done\\n   *         through the logger interface\\n   */\\n  start(): void {\\n    try {\\n      const config: {\\n        port: number;\\n        hostname: string;\\n        fetch: (\\n          req: Request,\\n          server: ReturnType<typeof Bun.serve>,\\n        ) => Promise<Response | undefined>;\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => void;\\n          message: (\\n            ws: ServerWebSocket<unknown>,\\n            message: string | Buffer,\\n          ) => void;\\n          close: (\\n            ws: ServerWebSocket<unknown>,\\n            code: number,\\n            reason: string,\\n          ) => void;\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n        };\\n        tls?: BunTLSOptions;\\n      } = {\\n        port: this.config.port,\\n        hostname: this.config.host,\\n        fetch: (req: Request, server: ReturnType<typeof Bun.serve>) =>\\n          this.handleRequest(req, server),\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => this.handleWebSocketOpen(ws),\\n          message: (ws: ServerWebSocket<unknown>, message: string | Buffer) =>\\n            this.handleWebSocketMessage(ws, message),\\n          close: (ws: ServerWebSocket<unknown>, code: number, reason: string) =>\\n            this.handleWebSocketClose(ws, code, reason),\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPing(ws, data),\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPong(ws, data),\\n        },\\n      };\\n\\n      // Only add TLS if it's defined (not null or undefined)\\n      if (this.config.tls) {\\n        config.tls = this.config.tls;\\n      }\\n\\n      this.bunServer = Bun.serve(config);\\n\\n      this.isRunning = true;\\n\\n      // Set up periodic garbage collection every 30 seconds\\n      this.gcTimer = setInterval(() => {\\n        if (typeof gc !== \\\"undefined\\\") {\\n          // Note: gc.collect() may not be available in all Bun versions\\n          (gc as { collect?: () => void }).collect?.();\\n        }\\n      }, 30_000);\\n\\n      this.config.logger.info(\\n        \\\"Server started\\\",\\n        `Listening on ${this.config.host}:${this.config.port}`,\\n      );\\n    } catch (error) {\\n      const message = error instanceof Error ? error.message : String(error);\\n      this.config.logger.error(message);\\n      this.isRunning = false;\\n    }\\n  }\\n\\n  /**\\n   * Stop the HTTP server.\\n   *\\n   * Gracefully shuts down the server, stops garbage collection,\\n   * and closes all connections.\\n   */\\n  stop(): void {\\n    this.isRunning = false;\\n\\n    // Stop garbage collection timer\\n    if (this.gcTimer) {\\n      clearInterval(this.gcTimer);\\n      this.gcTimer = null;\\n    }\\n\\n    // Close the Bun server\\n    if (this.bunServer) {\\n      this.bunServer.stop();\\n      this.bunServer = null;\\n    }\\n\\n    this.config.logger.info(\\\"Server stopped\\\");\\n  }\\n\\n  /**\\n   * Handle incoming HTTP requests.\\n   *\\n   * Routes HTTP requests and handles WebSocket upgrades.\\n   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.\\n   * For regular HTTP requests, this routes to the router for application logic.\\n   *\\n   * @param req - The incoming HTTP request\\n   * @param server - The Bun server instance (used for WebSocket upgrades)\\n   * @returns A Response object for the request\\n   *\\n   * @private\\n   */\\n  private async handleRequest(\\n    req: Request,\\n    server: ReturnType<typeof Bun.serve>,\\n  ): Promise<Response | undefined> {\\n    const url = new URL(req.url);\\n    const pathname = url.pathname;\\n\\n    // Attempt WebSocket upgrade for specific paths\\n    if (this.shouldUpgradeToWebSocket(pathname, req)) {\\n      if (server.upgrade(req, { data: null })) {\\n        return undefined;\\n      }\\n    }\\n\\n    // Route HTTP requests\\n    try {\\n      // Convert Bun Request to IHttpRequest\\n      const httpRequest = await this.convertToHttpRequest(req);\\n      // For HTTP requests, pass null as connection since we don't have a Connection object yet\\n      const result = await this.config.router.dispatch(httpRequest, null);\\n\\n      // If result is already a Response, return it\\n      if (result instanceof Response) {\\n        return result;\\n      }\\n\\n      // Otherwise, wrap result in a Response\\n      return new Response(JSON.stringify(result), {\\n        status: 200,\\n        headers: { \\\"content-type\\\": \\\"application/json\\\" },\\n      });\\n    } catch (error) {\\n      if (error instanceof HttpException) {\\n        return new Response(error.message, {\\n          status: error.statusCode,\\n          headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n        });\\n      }\\n\\n      const message =\\n        error instanceof Error ? error.message : \\\"Internal server error\\\";\\n      this.config.logger.error(message);\\n\\n      return new Response(\\\"Internal server error\\\", {\\n        status: 500,\\n        headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n      });\\n    }\\n  }\\n\\n  /**\\n   * Determine if a request should be upgraded to WebSocket.\\n   *\\n   * Checks if the request is a WebSocket upgrade request and if the path\\n   * is one that should be handled as a WebSocket connection.\\n   *\\n   * @param pathname - The request path\\n   * @param req - The incoming HTTP request\\n   * @returns true if the request should be upgraded to WebSocket\\n   *\\n   * @private\\n   */\\n  private shouldUpgradeToWebSocket(pathname: string, req: Request): boolean {\\n    // Check if this is a WebSocket upgrade request\\n    const upgrade = req.headers.get(\\\"upgrade\\\")?.toLowerCase();\\n    if (upgrade !== \\\"websocket\\\") {\\n      return false;\\n    }\\n\\n    // WebSocket connections typically use these paths\\n    return pathname === \\\"/app\\\" || pathname.startsWith(\\\"/app/\\\");\\n  }\\n\\n  /**\\n   * Handle WebSocket connection opened event.\\n   *\\n   * Called when a new WebSocket connection is successfully established.\\n   * This is where application-level connection setup would occur.\\n   *\\n   * @param ws - The WebSocket connection\\n   *\\n   * @private\\n   */\\n  private handleWebSocketOpen(_ws: ServerWebSocket<unknown>): void {\\n    // Application-level WebSocket handling would be done here\\n    // For now, this is a placeholder for lifecycle management\\n  }\\n\\n  /**\\n   * Handle WebSocket message received event.\\n   *\\n   * Routes incoming WebSocket messages to the application router\\n   * for processing.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param message - The message data (string or buffer)\\n   *\\n   * @private\\n   */\\n  private handleWebSocketMessage(\\n    _ws: ServerWebSocket<unknown>,\\n    _message: string | Buffer,\\n  ): void {\\n    // Application-level message routing would occur here\\n    // This delegates to the router or message handler\\n  }\\n\\n  /**\\n   * Handle WebSocket connection closed event.\\n   *\\n   * Called when a WebSocket connection is closed, either by the client,\\n   * server, or due to network issues.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param code - The WebSocket close code\\n   * @param reason - The reason for closing\\n   *\\n   * @private\\n   */\\n  private handleWebSocketClose(\\n    _ws: ServerWebSocket<unknown>,\\n    _code: number,\\n    _reason: string,\\n  ): void {\\n    // Application-level cleanup would occur here\\n    // This would handle connection state cleanup, event dispatching, etc.\\n  }\\n\\n  /**\\n   * Handle WebSocket ping frame received event.\\n   *\\n   * Automatically responds with a pong frame. This is typically\\n   * handled automatically by Bun, but can be customized for monitoring.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The ping frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPing(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Bun automatically sends a pong response, but we can log or monitor here\\n  }\\n\\n  /**\\n   * Handle WebSocket pong frame received event.\\n   *\\n   * Called when a pong response is received from the client.\\n   * Used to verify connection health and update activity tracking.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The pong frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPong(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Application-level pong handling would occur here\\n    // This would update connection state, mark as active, etc.\\n  }\\n\\n  /**\\n   * Convert Bun Request to IHttpRequest.\\n   *\\n   * @param req - The Bun Request object\\n   * @returns IHttpRequest interface\\n   *\\n   * @private\\n   */\\n  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {\\n    const url = new URL(req.url);\\n    const body =\\n      req.method !== \\\"GET\\\" && req.method !== \\\"HEAD\\\" ? await req.text() : \\\"\\\";\\n    const method = req.method;\\n    const pathWithQuery = url.pathname + url.search;\\n    const pathWithoutQuery = url.pathname;\\n    const host = url.host;\\n\\n    // Convert Headers to Record<string, string>\\n    const headers: Record<string, string> = {};\\n    req.headers.forEach((value, key) => {\\n      headers[key.toLowerCase()] = value;\\n    });\\n\\n    return {\\n      method,\\n      path: pathWithQuery,\\n      body,\\n      getMethod(): string {\\n        return method;\\n      },\\n      getPath(): string {\\n        return pathWithoutQuery;\\n      },\\n      getHost(): string {\\n        return host;\\n      },\\n      getHeader(name: string): string | undefined {\\n        return headers[name.toLowerCase()];\\n      },\\n      getHeaders(): Record<string, string> {\\n        return { ...headers };\\n      },\\n      getUri(): { path: string; host: string } {\\n        return { path: pathWithoutQuery, host };\\n      },\\n    };\\n  }\\n\\n  /**\\n   * Determine whether the server has TLS support.\\n   *\\n   * Checks if the server was configured with TLS certificates.\\n   *\\n   * @returns true if TLS is configured, false otherwise\\n   */\\n  isSecure(): boolean {\\n    return this.config.tls !== null && this.config.tls !== undefined;\\n  }\\n\\n  /**\\n   * Determine if the server is currently running.\\n   *\\n   * @returns true if the server is running, false otherwise\\n   */\\n  running(): boolean {\\n    return this.isRunning;\\n  }\\n}\\n\\n/**\\n * Server Configuration\\n *\\n * Configuration object for the HTTP server, including port, host,\\n * logger, router, and optional TLS settings.\\n */\\nexport interface ServerConfig {\\n  /**\\n   * The port to listen on (e.g., 8080)\\n   */\\n  port: number;\\n\\n  /**\\n   * The hostname to bind to (e.g., 'localhost' or '0.0.0.0')\\n   */\\n  host: string;\\n\\n  /**\\n   * The logger instance for output\\n   */\\n  logger: ILogger;\\n\\n  /**\\n   * The router for handling HTTP requests\\n   */\\n  router: Router;\\n\\n  /**\\n   * Maximum allowed request size in bytes\\n   */\\n  maxRequestSize: number;\\n\\n  /**\\n   * Optional TLS configuration for HTTPS/WSS support\\n   */\\n  tls?: BunTLSOptions | null;\\n}\\n\\n/**\\n * Bun TLS Options\\n *\\n * Configuration for TLS/HTTPS support in Bun.serve()\\n */\\nexport interface BunTLSOptions {\\n  /**\\n   * Path to the TLS certificate file\\n   */\\n  cert?: string | Buffer;\\n\\n  /**\\n   * Path to the TLS key file\\n   */\\n  key?: string | Buffer;\\n\\n  /**\\n   * Path to the CA certificate file (for client validation)\\n   */\\n  ca?: string | Buffer;\\n\\n  /**\\n   * Path to the PKCS#12 file (alternative to separate cert/key)\\n   */\\n  pkcs12?: Buffer;\\n\\n  /**\\n   * Passphrase for the key file\\n   */\\n  passphrase?: string;\\n}\\n\\n/**\\n * HTTP Exception\\n *\\n * Represents an HTTP error with a status code and message.\\n * Used for routing errors and validation failures.\\n */\\nexport class HttpException extends Error {\\n  /**\\n   * Create a new HTTP exception.\\n   *\\n   * @param statusCode - The HTTP status code (e.g., 404, 500)\\n   * @param message - The error message\\n   */\\n  constructor(\\n    public readonly statusCode: number,\\n    message: string,\\n  ) {\\n    super(message);\\n    this.name = \\\"HttpException\\\";\\n  }\\n}\\n\"\n        }\n      }\n    }\n\n### Tool · edit (started)",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    {",
                    "lineNumber": 5309,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 5310,
                    "isSignature": false
                  },
                  {
                    "text": "        \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/server.ts\"",
                    "lineNumber": 5311,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 5312,
                    "isSignature": false
                  },
                  {
                    "text": "      \"result\": {",
                    "lineNumber": 5313,
                    "isSignature": false
                  },
                  {
                    "text": "        \"success\": {",
                    "lineNumber": 5314,
                    "isSignature": false
                  },
                  {
                    "text": "          \"path\": \"/Users/tom/personal/revurb/src/servers/reverb/http/server.ts\",",
                    "lineNumber": 5315,
                    "isSignature": false
                  },
                  {
                    "text": "          \"resultForModel\": \"\",",
                    "lineNumber": 5316,
                    "isSignature": false
                  },
                  {
                    "text": "          \"linesAdded\": 1,",
                    "lineNumber": 5317,
                    "isSignature": false
                  },
                  {
                    "text": "          \"linesRemoved\": 0,",
                    "lineNumber": 5318,
                    "isSignature": false
                  },
                  {
                    "text": "          \"diffString\": \"  import type { ILogger } from \\\"../../../contracts/logger\\\";\\n  import type { IHttpRequest, Router } from \\\"./router\\\";\\n+ import { Response as HttpResponse } from \\\"./response\\\";\\n  \\n  /**\",",
                    "lineNumber": 5319,
                    "isSignature": false
                  },
                  {
                    "text": "          \"beforeFullFileContent\": \"import type { ServerWebSocket } from \\\"bun\\\";\\nimport type { ILogger } from \\\"../../../contracts/logger\\\";\\nimport type { IHttpRequest, Router } from \\\"./router\\\";\\n\\n/**\\n * HTTP Server Implementation\\n *\\n * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\\n * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\\n *\\n * Key features:\\n * - Accepts incoming TCP connections via Bun.serve()\\n * - HTTP request parsing and routing\\n * - WebSocket upgrade handling with full lifecycle management\\n * - Periodic garbage collection (every 30 seconds)\\n * - Graceful start/stop lifecycle management\\n * - TLS support detection\\n *\\n * The server uses Bun's native WebSocket API for efficient connection handling\\n * and automatic binary/text frame management.\\n *\\n * @example\\n * ```typescript\\n * const server = new Server({\\n *   port: 8080,\\n *   host: 'localhost',\\n *   logger,\\n *   router,\\n *   maxRequestSize: 1024 * 1024,\\n *   tls: null,\\n * });\\n *\\n * server.start();\\n * // Server is now accepting connections...\\n *\\n * // Later, to stop:\\n * server.stop();\\n * ```\\n */\\nexport class Server {\\n  /**\\n   * The underlying Bun server instance.\\n   *\\n   * @private\\n   */\\n  private bunServer: ReturnType<typeof Bun.serve> | null = null;\\n\\n  /**\\n   * Periodic timer for garbage collection.\\n   *\\n   * @private\\n   */\\n  private gcTimer: Timer | null = null;\\n\\n  /**\\n   * Indicates whether the server is running.\\n   *\\n   * @private\\n   */\\n  private isRunning = false;\\n\\n  /**\\n   * Server configuration options.\\n   *\\n   * @private\\n   */\\n  private readonly config: ServerConfig;\\n\\n  /**\\n   * Create a new HTTP server instance.\\n   *\\n   * Initializes the server with configuration, logger, and router.\\n   * Disables automatic garbage collection and sets up periodic manual GC.\\n   *\\n   * @param config - Server configuration object\\n   */\\n  constructor(config: ServerConfig) {\\n    this.config = config;\\n\\n    // Disable automatic garbage collection; we'll do it manually\\n    if (typeof gc !== \\\"undefined\\\") {\\n      // Note: gc.disable() may not be available in all Bun versions\\n      (gc as { disable?: () => void }).disable?.();\\n    }\\n  }\\n\\n  /**\\n   * Start the HTTP server.\\n   *\\n   * Initializes Bun.serve() with the configured port, host, and handlers.\\n   * Sets up periodic garbage collection and error handling.\\n   * The server will accept both HTTP and WebSocket connections.\\n   *\\n   * @throws Will log errors but not throw directly; error handling is done\\n   *         through the logger interface\\n   */\\n  start(): void {\\n    try {\\n      const config: {\\n        port: number;\\n        hostname: string;\\n        fetch: (\\n          req: Request,\\n          server: ReturnType<typeof Bun.serve>,\\n        ) => Promise<Response | undefined>;\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => void;\\n          message: (\\n            ws: ServerWebSocket<unknown>,\\n            message: string | Buffer,\\n          ) => void;\\n          close: (\\n            ws: ServerWebSocket<unknown>,\\n            code: number,\\n            reason: string,\\n          ) => void;\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n        };\\n        tls?: BunTLSOptions;\\n      } = {\\n        port: this.config.port,\\n        hostname: this.config.host,\\n        fetch: (req: Request, server: ReturnType<typeof Bun.serve>) =>\\n          this.handleRequest(req, server),\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => this.handleWebSocketOpen(ws),\\n          message: (ws: ServerWebSocket<unknown>, message: string | Buffer) =>\\n            this.handleWebSocketMessage(ws, message),\\n          close: (ws: ServerWebSocket<unknown>, code: number, reason: string) =>\\n            this.handleWebSocketClose(ws, code, reason),\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPing(ws, data),\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPong(ws, data),\\n        },\\n      };\\n\\n      // Only add TLS if it's defined (not null or undefined)\\n      if (this.config.tls) {\\n        config.tls = this.config.tls;\\n      }\\n\\n      this.bunServer = Bun.serve(config);\\n\\n      this.isRunning = true;\\n\\n      // Set up periodic garbage collection every 30 seconds\\n      this.gcTimer = setInterval(() => {\\n        if (typeof gc !== \\\"undefined\\\") {\\n          // Note: gc.collect() may not be available in all Bun versions\\n          (gc as { collect?: () => void }).collect?.();\\n        }\\n      }, 30_000);\\n\\n      this.config.logger.info(\\n        \\\"Server started\\\",\\n        `Listening on ${this.config.host}:${this.config.port}`,\\n      );\\n    } catch (error) {\\n      const message = error instanceof Error ? error.message : String(error);\\n      this.config.logger.error(message);\\n      this.isRunning = false;\\n    }\\n  }\\n\\n  /**\\n   * Stop the HTTP server.\\n   *\\n   * Gracefully shuts down the server, stops garbage collection,\\n   * and closes all connections.\\n   */\\n  stop(): void {\\n    this.isRunning = false;\\n\\n    // Stop garbage collection timer\\n    if (this.gcTimer) {\\n      clearInterval(this.gcTimer);\\n      this.gcTimer = null;\\n    }\\n\\n    // Close the Bun server\\n    if (this.bunServer) {\\n      this.bunServer.stop();\\n      this.bunServer = null;\\n    }\\n\\n    this.config.logger.info(\\\"Server stopped\\\");\\n  }\\n\\n  /**\\n   * Handle incoming HTTP requests.\\n   *\\n   * Routes HTTP requests and handles WebSocket upgrades.\\n   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.\\n   * For regular HTTP requests, this routes to the router for application logic.\\n   *\\n   * @param req - The incoming HTTP request\\n   * @param server - The Bun server instance (used for WebSocket upgrades)\\n   * @returns A Response object for the request\\n   *\\n   * @private\\n   */\\n  private async handleRequest(\\n    req: Request,\\n    server: ReturnType<typeof Bun.serve>,\\n  ): Promise<Response | undefined> {\\n    const url = new URL(req.url);\\n    const pathname = url.pathname;\\n\\n    // Attempt WebSocket upgrade for specific paths\\n    if (this.shouldUpgradeToWebSocket(pathname, req)) {\\n      if (server.upgrade(req, { data: null })) {\\n        return undefined;\\n      }\\n    }\\n\\n    // Route HTTP requests\\n    try {\\n      // Convert Bun Request to IHttpRequest\\n      const httpRequest = await this.convertToHttpRequest(req);\\n      // For HTTP requests, pass null as connection since we don't have a Connection object yet\\n      const result = await this.config.router.dispatch(httpRequest, null);\\n\\n      // If result is already a Response, return it\\n      if (result instanceof Response) {\\n        return result;\\n      }\\n\\n      // Otherwise, wrap result in a Response\\n      return new Response(JSON.stringify(result), {\\n        status: 200,\\n        headers: { \\\"content-type\\\": \\\"application/json\\\" },\\n      });\\n    } catch (error) {\\n      if (error instanceof HttpException) {\\n        return new Response(error.message, {\\n          status: error.statusCode,\\n          headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n        });\\n      }\\n\\n      const message =\\n        error instanceof Error ? error.message : \\\"Internal server error\\\";\\n      this.config.logger.error(message);\\n\\n      return new Response(\\\"Internal server error\\\", {\\n        status: 500,\\n        headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n      });\\n    }\\n  }\\n\\n  /**\\n   * Determine if a request should be upgraded to WebSocket.\\n   *\\n   * Checks if the request is a WebSocket upgrade request and if the path\\n   * is one that should be handled as a WebSocket connection.\\n   *\\n   * @param pathname - The request path\\n   * @param req - The incoming HTTP request\\n   * @returns true if the request should be upgraded to WebSocket\\n   *\\n   * @private\\n   */\\n  private shouldUpgradeToWebSocket(pathname: string, req: Request): boolean {\\n    // Check if this is a WebSocket upgrade request\\n    const upgrade = req.headers.get(\\\"upgrade\\\")?.toLowerCase();\\n    if (upgrade !== \\\"websocket\\\") {\\n      return false;\\n    }\\n\\n    // WebSocket connections typically use these paths\\n    return pathname === \\\"/app\\\" || pathname.startsWith(\\\"/app/\\\");\\n  }\\n\\n  /**\\n   * Handle WebSocket connection opened event.\\n   *\\n   * Called when a new WebSocket connection is successfully established.\\n   * This is where application-level connection setup would occur.\\n   *\\n   * @param ws - The WebSocket connection\\n   *\\n   * @private\\n   */\\n  private handleWebSocketOpen(_ws: ServerWebSocket<unknown>): void {\\n    // Application-level WebSocket handling would be done here\\n    // For now, this is a placeholder for lifecycle management\\n  }\\n\\n  /**\\n   * Handle WebSocket message received event.\\n   *\\n   * Routes incoming WebSocket messages to the application router\\n   * for processing.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param message - The message data (string or buffer)\\n   *\\n   * @private\\n   */\\n  private handleWebSocketMessage(\\n    _ws: ServerWebSocket<unknown>,\\n    _message: string | Buffer,\\n  ): void {\\n    // Application-level message routing would occur here\\n    // This delegates to the router or message handler\\n  }\\n\\n  /**\\n   * Handle WebSocket connection closed event.\\n   *\\n   * Called when a WebSocket connection is closed, either by the client,\\n   * server, or due to network issues.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param code - The WebSocket close code\\n   * @param reason - The reason for closing\\n   *\\n   * @private\\n   */\\n  private handleWebSocketClose(\\n    _ws: ServerWebSocket<unknown>,\\n    _code: number,\\n    _reason: string,\\n  ): void {\\n    // Application-level cleanup would occur here\\n    // This would handle connection state cleanup, event dispatching, etc.\\n  }\\n\\n  /**\\n   * Handle WebSocket ping frame received event.\\n   *\\n   * Automatically responds with a pong frame. This is typically\\n   * handled automatically by Bun, but can be customized for monitoring.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The ping frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPing(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Bun automatically sends a pong response, but we can log or monitor here\\n  }\\n\\n  /**\\n   * Handle WebSocket pong frame received event.\\n   *\\n   * Called when a pong response is received from the client.\\n   * Used to verify connection health and update activity tracking.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The pong frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPong(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Application-level pong handling would occur here\\n    // This would update connection state, mark as active, etc.\\n  }\\n\\n  /**\\n   * Convert Bun Request to IHttpRequest.\\n   *\\n   * @param req - The Bun Request object\\n   * @returns IHttpRequest interface\\n   *\\n   * @private\\n   */\\n  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {\\n    const url = new URL(req.url);\\n    const body =\\n      req.method !== \\\"GET\\\" && req.method !== \\\"HEAD\\\" ? await req.text() : \\\"\\\";\\n    const method = req.method;\\n    const pathWithQuery = url.pathname + url.search;\\n    const pathWithoutQuery = url.pathname;\\n    const host = url.host;\\n\\n    // Convert Headers to Record<string, string>\\n    const headers: Record<string, string> = {};\\n    req.headers.forEach((value, key) => {\\n      headers[key.toLowerCase()] = value;\\n    });\\n\\n    return {\\n      method,\\n      path: pathWithQuery,\\n      body,\\n      getMethod(): string {\\n        return method;\\n      },\\n      getPath(): string {\\n        return pathWithoutQuery;\\n      },\\n      getHost(): string {\\n        return host;\\n      },\\n      getHeader(name: string): string | undefined {\\n        return headers[name.toLowerCase()];\\n      },\\n      getHeaders(): Record<string, string> {\\n        return { ...headers };\\n      },\\n      getUri(): { path: string; host: string } {\\n        return { path: pathWithoutQuery, host };\\n      },\\n    };\\n  }\\n\\n  /**\\n   * Determine whether the server has TLS support.\\n   *\\n   * Checks if the server was configured with TLS certificates.\\n   *\\n   * @returns true if TLS is configured, false otherwise\\n   */\\n  isSecure(): boolean {\\n    return this.config.tls !== null && this.config.tls !== undefined;\\n  }\\n\\n  /**\\n   * Determine if the server is currently running.\\n   *\\n   * @returns true if the server is running, false otherwise\\n   */\\n  running(): boolean {\\n    return this.isRunning;\\n  }\\n}\\n\\n/**\\n * Server Configuration\\n *\\n * Configuration object for the HTTP server, including port, host,\\n * logger, router, and optional TLS settings.\\n */\\nexport interface ServerConfig {\\n  /**\\n   * The port to listen on (e.g., 8080)\\n   */\\n  port: number;\\n\\n  /**\\n   * The hostname to bind to (e.g., 'localhost' or '0.0.0.0')\\n   */\\n  host: string;\\n\\n  /**\\n   * The logger instance for output\\n   */\\n  logger: ILogger;\\n\\n  /**\\n   * The router for handling HTTP requests\\n   */\\n  router: Router;\\n\\n  /**\\n   * Maximum allowed request size in bytes\\n   */\\n  maxRequestSize: number;\\n\\n  /**\\n   * Optional TLS configuration for HTTPS/WSS support\\n   */\\n  tls?: BunTLSOptions | null;\\n}\\n\\n/**\\n * Bun TLS Options\\n *\\n * Configuration for TLS/HTTPS support in Bun.serve()\\n */\\nexport interface BunTLSOptions {\\n  /**\\n   * Path to the TLS certificate file\\n   */\\n  cert?: string | Buffer;\\n\\n  /**\\n   * Path to the TLS key file\\n   */\\n  key?: string | Buffer;\\n\\n  /**\\n   * Path to the CA certificate file (for client validation)\\n   */\\n  ca?: string | Buffer;\\n\\n  /**\\n   * Path to the PKCS#12 file (alternative to separate cert/key)\\n   */\\n  pkcs12?: Buffer;\\n\\n  /**\\n   * Passphrase for the key file\\n   */\\n  passphrase?: string;\\n}\\n\\n/**\\n * HTTP Exception\\n *\\n * Represents an HTTP error with a status code and message.\\n * Used for routing errors and validation failures.\\n */\\nexport class HttpException extends Error {\\n  /**\\n   * Create a new HTTP exception.\\n   *\\n   * @param statusCode - The HTTP status code (e.g., 404, 500)\\n   * @param message - The error message\\n   */\\n  constructor(\\n    public readonly statusCode: number,\\n    message: string,\\n  ) {\\n    super(message);\\n    this.name = \\\"HttpException\\\";\\n  }\\n}\\n\",",
                    "lineNumber": 5320,
                    "isSignature": false
                  },
                  {
                    "text": "          \"afterFullFileContent\": \"import type { ServerWebSocket } from \\\"bun\\\";\\nimport type { ILogger } from \\\"../../../contracts/logger\\\";\\nimport type { IHttpRequest, Router } from \\\"./router\\\";\\nimport { Response as HttpResponse } from \\\"./response\\\";\\n\\n/**\\n * HTTP Server Implementation\\n *\\n * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\\n * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\\n *\\n * Key features:\\n * - Accepts incoming TCP connections via Bun.serve()\\n * - HTTP request parsing and routing\\n * - WebSocket upgrade handling with full lifecycle management\\n * - Periodic garbage collection (every 30 seconds)\\n * - Graceful start/stop lifecycle management\\n * - TLS support detection\\n *\\n * The server uses Bun's native WebSocket API for efficient connection handling\\n * and automatic binary/text frame management.\\n *\\n * @example\\n * ```typescript\\n * const server = new Server({\\n *   port: 8080,\\n *   host: 'localhost',\\n *   logger,\\n *   router,\\n *   maxRequestSize: 1024 * 1024,\\n *   tls: null,\\n * });\\n *\\n * server.start();\\n * // Server is now accepting connections...\\n *\\n * // Later, to stop:\\n * server.stop();\\n * ```\\n */\\nexport class Server {\\n  /**\\n   * The underlying Bun server instance.\\n   *\\n   * @private\\n   */\\n  private bunServer: ReturnType<typeof Bun.serve> | null = null;\\n\\n  /**\\n   * Periodic timer for garbage collection.\\n   *\\n   * @private\\n   */\\n  private gcTimer: Timer | null = null;\\n\\n  /**\\n   * Indicates whether the server is running.\\n   *\\n   * @private\\n   */\\n  private isRunning = false;\\n\\n  /**\\n   * Server configuration options.\\n   *\\n   * @private\\n   */\\n  private readonly config: ServerConfig;\\n\\n  /**\\n   * Create a new HTTP server instance.\\n   *\\n   * Initializes the server with configuration, logger, and router.\\n   * Disables automatic garbage collection and sets up periodic manual GC.\\n   *\\n   * @param config - Server configuration object\\n   */\\n  constructor(config: ServerConfig) {\\n    this.config = config;\\n\\n    // Disable automatic garbage collection; we'll do it manually\\n    if (typeof gc !== \\\"undefined\\\") {\\n      // Note: gc.disable() may not be available in all Bun versions\\n      (gc as { disable?: () => void }).disable?.();\\n    }\\n  }\\n\\n  /**\\n   * Start the HTTP server.\\n   *\\n   * Initializes Bun.serve() with the configured port, host, and handlers.\\n   * Sets up periodic garbage collection and error handling.\\n   * The server will accept both HTTP and WebSocket connections.\\n   *\\n   * @throws Will log errors but not throw directly; error handling is done\\n   *         through the logger interface\\n   */\\n  start(): void {\\n    try {\\n      const config: {\\n        port: number;\\n        hostname: string;\\n        fetch: (\\n          req: Request,\\n          server: ReturnType<typeof Bun.serve>,\\n        ) => Promise<Response | undefined>;\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => void;\\n          message: (\\n            ws: ServerWebSocket<unknown>,\\n            message: string | Buffer,\\n          ) => void;\\n          close: (\\n            ws: ServerWebSocket<unknown>,\\n            code: number,\\n            reason: string,\\n          ) => void;\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) => void;\\n        };\\n        tls?: BunTLSOptions;\\n      } = {\\n        port: this.config.port,\\n        hostname: this.config.host,\\n        fetch: (req: Request, server: ReturnType<typeof Bun.serve>) =>\\n          this.handleRequest(req, server),\\n        websocket: {\\n          open: (ws: ServerWebSocket<unknown>) => this.handleWebSocketOpen(ws),\\n          message: (ws: ServerWebSocket<unknown>, message: string | Buffer) =>\\n            this.handleWebSocketMessage(ws, message),\\n          close: (ws: ServerWebSocket<unknown>, code: number, reason: string) =>\\n            this.handleWebSocketClose(ws, code, reason),\\n          ping: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPing(ws, data),\\n          pong: (ws: ServerWebSocket<unknown>, data: Buffer) =>\\n            this.handleWebSocketPong(ws, data),\\n        },\\n      };\\n\\n      // Only add TLS if it's defined (not null or undefined)\\n      if (this.config.tls) {\\n        config.tls = this.config.tls;\\n      }\\n\\n      this.bunServer = Bun.serve(config);\\n\\n      this.isRunning = true;\\n\\n      // Set up periodic garbage collection every 30 seconds\\n      this.gcTimer = setInterval(() => {\\n        if (typeof gc !== \\\"undefined\\\") {\\n          // Note: gc.collect() may not be available in all Bun versions\\n          (gc as { collect?: () => void }).collect?.();\\n        }\\n      }, 30_000);\\n\\n      this.config.logger.info(\\n        \\\"Server started\\\",\\n        `Listening on ${this.config.host}:${this.config.port}`,\\n      );\\n    } catch (error) {\\n      const message = error instanceof Error ? error.message : String(error);\\n      this.config.logger.error(message);\\n      this.isRunning = false;\\n    }\\n  }\\n\\n  /**\\n   * Stop the HTTP server.\\n   *\\n   * Gracefully shuts down the server, stops garbage collection,\\n   * and closes all connections.\\n   */\\n  stop(): void {\\n    this.isRunning = false;\\n\\n    // Stop garbage collection timer\\n    if (this.gcTimer) {\\n      clearInterval(this.gcTimer);\\n      this.gcTimer = null;\\n    }\\n\\n    // Close the Bun server\\n    if (this.bunServer) {\\n      this.bunServer.stop();\\n      this.bunServer = null;\\n    }\\n\\n    this.config.logger.info(\\\"Server stopped\\\");\\n  }\\n\\n  /**\\n   * Handle incoming HTTP requests.\\n   *\\n   * Routes HTTP requests and handles WebSocket upgrades.\\n   * For WebSocket upgrades, this delegates to Bun's upgrade mechanism.\\n   * For regular HTTP requests, this routes to the router for application logic.\\n   *\\n   * @param req - The incoming HTTP request\\n   * @param server - The Bun server instance (used for WebSocket upgrades)\\n   * @returns A Response object for the request\\n   *\\n   * @private\\n   */\\n  private async handleRequest(\\n    req: Request,\\n    server: ReturnType<typeof Bun.serve>,\\n  ): Promise<Response | undefined> {\\n    const url = new URL(req.url);\\n    const pathname = url.pathname;\\n\\n    // Attempt WebSocket upgrade for specific paths\\n    if (this.shouldUpgradeToWebSocket(pathname, req)) {\\n      if (server.upgrade(req, { data: null })) {\\n        return undefined;\\n      }\\n    }\\n\\n    // Route HTTP requests\\n    try {\\n      // Convert Bun Request to IHttpRequest\\n      const httpRequest = await this.convertToHttpRequest(req);\\n      // For HTTP requests, pass null as connection since we don't have a Connection object yet\\n      const result = await this.config.router.dispatch(httpRequest, null);\\n\\n      // If result is already a Response, return it\\n      if (result instanceof Response) {\\n        return result;\\n      }\\n\\n      // Otherwise, wrap result in a Response\\n      return new Response(JSON.stringify(result), {\\n        status: 200,\\n        headers: { \\\"content-type\\\": \\\"application/json\\\" },\\n      });\\n    } catch (error) {\\n      if (error instanceof HttpException) {\\n        return new Response(error.message, {\\n          status: error.statusCode,\\n          headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n        });\\n      }\\n\\n      const message =\\n        error instanceof Error ? error.message : \\\"Internal server error\\\";\\n      this.config.logger.error(message);\\n\\n      return new Response(\\\"Internal server error\\\", {\\n        status: 500,\\n        headers: { \\\"content-type\\\": \\\"text/plain\\\" },\\n      });\\n    }\\n  }\\n\\n  /**\\n   * Determine if a request should be upgraded to WebSocket.\\n   *\\n   * Checks if the request is a WebSocket upgrade request and if the path\\n   * is one that should be handled as a WebSocket connection.\\n   *\\n   * @param pathname - The request path\\n   * @param req - The incoming HTTP request\\n   * @returns true if the request should be upgraded to WebSocket\\n   *\\n   * @private\\n   */\\n  private shouldUpgradeToWebSocket(pathname: string, req: Request): boolean {\\n    // Check if this is a WebSocket upgrade request\\n    const upgrade = req.headers.get(\\\"upgrade\\\")?.toLowerCase();\\n    if (upgrade !== \\\"websocket\\\") {\\n      return false;\\n    }\\n\\n    // WebSocket connections typically use these paths\\n    return pathname === \\\"/app\\\" || pathname.startsWith(\\\"/app/\\\");\\n  }\\n\\n  /**\\n   * Handle WebSocket connection opened event.\\n   *\\n   * Called when a new WebSocket connection is successfully established.\\n   * This is where application-level connection setup would occur.\\n   *\\n   * @param ws - The WebSocket connection\\n   *\\n   * @private\\n   */\\n  private handleWebSocketOpen(_ws: ServerWebSocket<unknown>): void {\\n    // Application-level WebSocket handling would be done here\\n    // For now, this is a placeholder for lifecycle management\\n  }\\n\\n  /**\\n   * Handle WebSocket message received event.\\n   *\\n   * Routes incoming WebSocket messages to the application router\\n   * for processing.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param message - The message data (string or buffer)\\n   *\\n   * @private\\n   */\\n  private handleWebSocketMessage(\\n    _ws: ServerWebSocket<unknown>,\\n    _message: string | Buffer,\\n  ): void {\\n    // Application-level message routing would occur here\\n    // This delegates to the router or message handler\\n  }\\n\\n  /**\\n   * Handle WebSocket connection closed event.\\n   *\\n   * Called when a WebSocket connection is closed, either by the client,\\n   * server, or due to network issues.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param code - The WebSocket close code\\n   * @param reason - The reason for closing\\n   *\\n   * @private\\n   */\\n  private handleWebSocketClose(\\n    _ws: ServerWebSocket<unknown>,\\n    _code: number,\\n    _reason: string,\\n  ): void {\\n    // Application-level cleanup would occur here\\n    // This would handle connection state cleanup, event dispatching, etc.\\n  }\\n\\n  /**\\n   * Handle WebSocket ping frame received event.\\n   *\\n   * Automatically responds with a pong frame. This is typically\\n   * handled automatically by Bun, but can be customized for monitoring.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The ping frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPing(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Bun automatically sends a pong response, but we can log or monitor here\\n  }\\n\\n  /**\\n   * Handle WebSocket pong frame received event.\\n   *\\n   * Called when a pong response is received from the client.\\n   * Used to verify connection health and update activity tracking.\\n   *\\n   * @param ws - The WebSocket connection\\n   * @param data - The pong frame data\\n   *\\n   * @private\\n   */\\n  private handleWebSocketPong(\\n    _ws: ServerWebSocket<unknown>,\\n    _data: Buffer,\\n  ): void {\\n    // Application-level pong handling would occur here\\n    // This would update connection state, mark as active, etc.\\n  }\\n\\n  /**\\n   * Convert Bun Request to IHttpRequest.\\n   *\\n   * @param req - The Bun Request object\\n   * @returns IHttpRequest interface\\n   *\\n   * @private\\n   */\\n  private async convertToHttpRequest(req: Request): Promise<IHttpRequest> {\\n    const url = new URL(req.url);\\n    const body =\\n      req.method !== \\\"GET\\\" && req.method !== \\\"HEAD\\\" ? await req.text() : \\\"\\\";\\n    const method = req.method;\\n    const pathWithQuery = url.pathname + url.search;\\n    const pathWithoutQuery = url.pathname;\\n    const host = url.host;\\n\\n    // Convert Headers to Record<string, string>\\n    const headers: Record<string, string> = {};\\n    req.headers.forEach((value, key) => {\\n      headers[key.toLowerCase()] = value;\\n    });\\n\\n    return {\\n      method,\\n      path: pathWithQuery,\\n      body,\\n      getMethod(): string {\\n        return method;\\n      },\\n      getPath(): string {\\n        return pathWithoutQuery;\\n      },\\n      getHost(): string {\\n        return host;\\n      },\\n      getHeader(name: string): string | undefined {\\n        return headers[name.toLowerCase()];\\n      },\\n      getHeaders(): Record<string, string> {\\n        return { ...headers };\\n      },\\n      getUri(): { path: string; host: string } {\\n        return { path: pathWithoutQuery, host };\\n      },\\n    };\\n  }\\n\\n  /**\\n   * Determine whether the server has TLS support.\\n   *\\n   * Checks if the server was configured with TLS certificates.\\n   *\\n   * @returns true if TLS is configured, false otherwise\\n   */\\n  isSecure(): boolean {\\n    return this.config.tls !== null && this.config.tls !== undefined;\\n  }\\n\\n  /**\\n   * Determine if the server is currently running.\\n   *\\n   * @returns true if the server is running, false otherwise\\n   */\\n  running(): boolean {\\n    return this.isRunning;\\n  }\\n}\\n\\n/**\\n * Server Configuration\\n *\\n * Configuration object for the HTTP server, including port, host,\\n * logger, router, and optional TLS settings.\\n */\\nexport interface ServerConfig {\\n  /**\\n   * The port to listen on (e.g., 8080)\\n   */\\n  port: number;\\n\\n  /**\\n   * The hostname to bind to (e.g., 'localhost' or '0.0.0.0')\\n   */\\n  host: string;\\n\\n  /**\\n   * The logger instance for output\\n   */\\n  logger: ILogger;\\n\\n  /**\\n   * The router for handling HTTP requests\\n   */\\n  router: Router;\\n\\n  /**\\n   * Maximum allowed request size in bytes\\n   */\\n  maxRequestSize: number;\\n\\n  /**\\n   * Optional TLS configuration for HTTPS/WSS support\\n   */\\n  tls?: BunTLSOptions | null;\\n}\\n\\n/**\\n * Bun TLS Options\\n *\\n * Configuration for TLS/HTTPS support in Bun.serve()\\n */\\nexport interface BunTLSOptions {\\n  /**\\n   * Path to the TLS certificate file\\n   */\\n  cert?: string | Buffer;\\n\\n  /**\\n   * Path to the TLS key file\\n   */\\n  key?: string | Buffer;\\n\\n  /**\\n   * Path to the CA certificate file (for client validation)\\n   */\\n  ca?: string | Buffer;\\n\\n  /**\\n   * Path to the PKCS#12 file (alternative to separate cert/key)\\n   */\\n  pkcs12?: Buffer;\\n\\n  /**\\n   * Passphrase for the key file\\n   */\\n  passphrase?: string;\\n}\\n\\n/**\\n * HTTP Exception\\n *\\n * Represents an HTTP error with a status code and message.\\n * Used for routing errors and validation failures.\\n */\\nexport class HttpException extends Error {\\n  /**\\n   * Create a new HTTP exception.\\n   *\\n   * @param statusCode - The HTTP status code (e.g., 404, 500)\\n   * @param message - The error message\\n   */\\n  constructor(\\n    public readonly statusCode: number,\\n    message: string,\\n  ) {\\n    super(message);\\n    this.name = \\\"HttpException\\\";\\n  }\\n}\\n\"",
                    "lineNumber": 5321,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 5322,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5323,
                    "isSignature": false
                  },
                  {
                    "text": "    }",
                    "lineNumber": 5324,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 5325,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · edit (started)",
                    "lineNumber": 5326,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.23369430005550385
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 12846,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 12863,
                    "column": 22
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/Http/router.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 25,\n                    \"column\": 0\n                  },\n                  \"endPosition\": {\n                    \"line\": 419,\n                    \"column\": 1\n                  }\n                },\n                \"contents\": \"export class Router {\\n\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(request: IHttpRequest, connection: Connection): Promise<any> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, any>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          this.close(connection, 405, 'Method not allowed.', { Allow: allowedMethods });\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          this.close(connection, 404, 'Not found.');\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(request, wsConnection, ...Object.values(routeParams));\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection\\n      return this.sendResponse(connection, response);\\n    } catch (error) {\\n      // Handle unexpected errors\\n      this.close(connection, 500, 'Internal server error.');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n}\",\n                \"signatures\": {\n                  \"ranges\": [\n                    {\n                      ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 12847,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 12848,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/Http/router.ts\",",
                    "lineNumber": 12849,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 12850,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 12851,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 25,",
                    "lineNumber": 12852,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 0",
                    "lineNumber": 12853,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 12854,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 12855,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 419,",
                    "lineNumber": 12856,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 1",
                    "lineNumber": 12857,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 12858,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 12859,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"export class Router {\\n\\n\\n  /**\\n   * Dispatch the HTTP request to the appropriate controller\\n   *\\n   * This method:\\n   * 1. Matches the request URI to a route\\n   * 2. Extracts the controller and route parameters\\n   * 3. Handles WebSocket upgrades if requested\\n   * 4. Resolves controller parameters from route and request context\\n   * 5. Calls the controller with appropriate arguments\\n   * 6. Handles HTTP errors (404, 405, 500)\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The connection object\\n   * @returns The controller response (Promise, string, or any result)\\n   *\\n   * @throws Will close connection with appropriate HTTP error code if route matching fails\\n   */\\n  async dispatch(request: IHttpRequest, connection: Connection): Promise<any> {\\n    try {\\n      // Set up route matcher context\\n      this.matcher.setContext({\\n        method: request.getMethod(),\\n        host: request.getHost(),\\n      });\\n\\n      // Attempt to match the route\\n      let route: Record<string, any>;\\n      try {\\n        route = this.matcher.match(request.getPath());\\n      } catch (error) {\\n        if (this.isMethodNotAllowedException(error)) {\\n          const allowedMethods = this.getAllowedMethods(error);\\n          this.close(connection, 405, 'Method not allowed.', { Allow: allowedMethods });\\n          return null;\\n        }\\n\\n        if (this.isResourceNotFoundException(error)) {\\n          this.close(connection, 404, 'Not found.');\\n          return null;\\n        }\\n\\n        throw error;\\n      }\\n\\n      // Get the controller from the route\\n      const controller = this.controller(route);\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(request, wsConnection, ...Object.values(routeParams));\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection\\n      return this.sendResponse(connection, response);\\n    } catch (error) {\\n      // Handle unexpected errors\\n      this.close(connection, 500, 'Internal server error.');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n}\",",
                    "lineNumber": 12860,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 12861,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": [",
                    "lineNumber": 12862,
                    "isSignature": false
                  },
                  {
                    "text": "                    {",
                    "lineNumber": 12863,
                    "isSignature": false
                  },
                  {
                    "text": "                      ",
                    "lineNumber": 12864,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.21870863437652588
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-1150.md",
                "range": {
                  "startPosition": {
                    "line": 1384,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 1415,
                    "column": 14
                  }
                },
                "contents": "### Tool · read (completed)\n\n    * **path:** `src/servers/reverb/http/server.ts`\n    * **status:** success\n        * lines: 1-10\n    * **content:**\n\n    import type { ServerWebSocket } from \"bun\";\n    import type { ILogger } from \"../../../contracts/logger\";\n    import type { IHttpRequest, Router } from \"./router\";\n    \n    /**\n     * HTTP Server Implementation\n     *\n     * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming\n     * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.\n     *\n\n### Tool · sem Search (completed)\n\n    {\n      \"args\": {\n        \"query\": \"How is the Response class from response.ts used in controllers?\",\n        \"targetDirectories\": [],\n        \"explanation\": \"\"\n      },\n      \"result\": {\n        \"success\": {\n          \"results\": \"<search_result path=\\\"src/servers/reverb/factory.ts\\\" startLine=\\\"184\\\" endLine=\\\"1290\\\">\\n   184|export class Factory {\\n   ...\\n  1250|\\n  1251|\\n  1252|  /**\\n  1253|   * Convert controller Response to Bun Response\\n  1254|   *\\n  1255|   * @param controllerResponse - The response from the controller\\n  1256|   * @returns Bun Response object\\n  1257|   *\\n  1258|   * @private\\n  1259|   */\\n  1260|  private static convertToResponse(controllerResponse: any): Response {\\n  1261|    // Check if it's our custom HttpResponse class\\n  1262|    if (controllerResponse instanceof HttpResponse) {\\n  1263|      const status = controllerResponse.getStatusCode();\\n  1264|      const body = controllerResponse.getContent();\\n  1265|      const headers = controllerResponse.getHeaders();\\n  1266|\\n  1267|      return new Response(body, {\\n  1268|        status,\\n  1269|        headers,\\n  1270|      });\\n  1271|    }\\n  1272|\\n  1273|    // Fallback for other response types\\n  1274|    const status = controllerResponse.status || 200;\\n  1275|    const body =\\n  1276|      typeof controllerResponse.content === \\\"string\\\"\\n  1277|        ? controllerResponse.content\\n  1278|        : JSON.stringify(controllerResponse.content);\\n  1279|\\n  1280|    return new Response(body, {\\n  1281|      status,\\n  1282|      headers: {\\n  1283|        \\\"Content-Type\\\":\\n  1284|          typeof controllerResponse.content === \\\"string\\\"\\n  1285|            ? \\\"text/plain\\\"\\n  1286|            : \\\"application/json\\\",\\n  1287|      },\\n  1288|    });\\n  1289|  }\\n  1290|}\\n</search_result>\\n<search_result path=\\\"src/servers/reverb/http/response.ts\\\" startLine=\\\"1\\\" endLine=\\\"264\\\">\\n     1|/**\\n     2| * HTTP Response class for JSON responses\\n     3| *\\n     4| * Represents an HTTP JSON response with support for:\\n     5| * - Custom status codes\\n     6| * - Custom headers\\n     7| * - Automatic Content-Length calculation\\n     8| * - Serialization to HTTP response format\\n     9| */\\n    10|export class Response {\\n    11|  /**\\n    12|   * The response body content (stringified JSON)\\n    13|   */\\n    14|  private content: string;\\n    15|\\n    16|  /**\\n    17|   * HTTP status code (e.g., 200, 404, 500)\\n    18|   */\\n    19|  private statusCode: number;\\n    20|\\n    21|  /**\\n    22|   * HTTP response headers\\n    23|   */\\n    24|  private headers: Map<string, string>;\\n    25|\\n    26|  /**\\n    27|   * Create a new HTTP Response instance\\n    28|   *\\n    29|   * @param data - The response data (will be JSON stringified)\\n    30|   * @param statusCode - HTTP status code (default: 200)\\n    31|   * @param headers - Object containing response headers\\n    32|   * @param json - Whether the data is already JSON string (default: false)\\n    33|   *\\n    34|   * @example\\n    35|   * ```typescript\\n    36|   * const response = new Response({ message: 'Hello' }, 200);\\n    37|   * const response = new Response({ error: 'Not found' }, 404);\\n    38|   * ```\\n    39|   */\\n    40|  constructor(\\n    41|    data: unknown = null,\\n    42|    statusCode = 200,\\n    43|    headers: Record<string, string> = {},\\n    44|    json = false,\\n    45|  ) {\\n    46|    this.statusCode = statusCode;\\n    47|    this.headers = new Map();\\n    48|\\n    49|    // Initialize headers from the provided object\\n    50|    Object.entries(headers).forEach(([key, value]) => {\\n    51|      this.headers.set(key, value);\\n    52|    });\\n    53|\\n    54|    // Set default Content-Type header for JSON responses if not already set\\n    55|    // Use case-insensitive check to avoid duplicate headers\\n    56|    if (!this.hasHeaderCaseInsensitive(\\\"Content-Type\\\")) {\\n    57|      this.headers.set(\\\"Content-Type\\\", \\\"application/json\\\");\\n    58|    }\\n    59|\\n    60|    // Stringify the content\\n    61|    if (json && typeof data === \\\"string\\\") {\\n    62|      this.content = data;\\n    63|    } else {\\n    64|      this.content = JSON.stringify(data);\\n    65|    }\\n    66|\\n    67|    // Automatically set Content-Length header\\n    68|    this.setContentLength();\\n    69|  }\\n    70|\\n    71|  /**\\n    72|   * Check if a header exists (case-insensitive)\\n    73|   *\\n    74|   * @param key - The header key to check (case-insensitive)\\n    75|   * @returns true if the header exists, false otherwise\\n    76|   *\\n    77|   * @private\\n    78|   */\\n   ...\\n   264|}\\n</search_result>\\n<search_result path=\\\"reverb/src/Servers/Reverb/Http/Response.php\\\" startLine=\\\"1\\\" endLine=\\\"18\\\">\\n     1|<?php\\n     2|\\n     3|namespace Laravel\\\\Reverb\\\\Servers\\\\Reverb\\\\Http;\\n     4|\\n     5|use Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse;\\n     6|\\n     7|class Response extends JsonResponse\\n     8|{\\n     9|    /**\\n    10|     * Create a new Http response instance.\\n    11|     */\\n    12|    public function __construct(mixed $data = null, int $status = 200, array $headers = [], bool $json = false)\\n    13|    {\\n    14|        parent::__construct($data, $status, $headers, $json);\\n    15|\\n    16|        $this->headers->set('Content-Length', (string) strlen($this->content));\\n    17|    }\\n    18|}\\n</search_result>\\n<search_result path=\\\"src/servers/reverb/http/router.ts\\\" startLine=\\\"26\\\" endLine=\\\"481\\\">\\n    26|export class Router {\\n   ...\\n    57|async dispatch(\\n    58|    request: IHttpRequest,\\n    59|    connection: Connection | null,\\n    60|  ): Promise<unknown> {\\n   ...\\n    94|\\n    95|\\n    96|      // Check if this is a WebSocket upgrade request\\n    97|      if (this.isWebSocketRequest(request)) {\\n    98|        if (!connection) {\\n    99|          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n   100|        }\\n   101|        const wsConnection = this.attemptUpgrade(request, connection);\\n   102|\\n   103|        // Call the controller with websocket connection and route parameters\\n   104|        const routeParams = this.extractRouteParams(route);\\n   105|        return await controller(\\n   106|          request,\\n   107|          wsConnection,\\n   108|          ...Object.values(routeParams),\\n   109|        );\\n   110|      }\\n   111|\\n   112|      // For HTTP requests, resolve parameters and call controller\\n   113|      const routeParameters = {\\n   114|        ...this.extractRouteParams(route),\\n   115|        request,\\n   116|        connection,\\n   117|      };\\n   118|\\n   119|      const args = this.arguments(controller, routeParameters);\\n   120|      const response = await controller(...args);\\n   121|\\n   122|      // Send response and close connection if connection exists\\n   123|      if (connection) {\\n   124|        return this.sendResponse(connection, response);\\n   125|      }\\n   126|      return response;\\n   127|    } catch (error) {\\n   128|      // Handle unexpected errors\\n   129|      if (connection) {\\n   130|        this.close(connection, 500, \\\"Internal server error.\\\");\\n   131|      }\\n   132|      throw error;\\n   133|    }\\n   134|  }\\n   135|\\n   136|  /**\\n   137|   * Get the controller callable for the given route\\n   138|   *\\n   139|   * @param route - The matched route object\\n   140|   * @returns The controller function/callback\\n   141|   *\\n   142|   * @private\\n   143|   */\\n   ...\\n   481|}\\n</search_result>\\n<search_result path=\\\"src/protocols/pusher/http/controllers/health-check-controller.ts\\\" startLine=\\\"2\\\" endLine=\\\"33\\\">\\n     2|import { Response } from \\\"../../../../servers/reverb/http/response\\\";\\n     3|import type { IHttpRequest } from \\\"../../../../servers/reverb/http/router\\\";\\n     4|import { Controller } from \\\"./controller\\\";\\n     5|\\n     6|/**\\n     7| * Health Check Controller\\n     8| *\\n     9| * Simple health check endpoint that returns 200 OK.\\n    10| * This endpoint is used for monitoring and load balancer health checks.\\n    11| *\\n    12| * @example\\n    13| * ```typescript\\n    14| * const controller = new HealthCheckController();\\n    15| * const response = controller.__invoke(request, connection);\\n    16| * // Returns: Response with {health: 'OK'}\\n    17| * ```\\n    18| */\\n    19|export class HealthCheckController extends Controller {\\n    20|  /**\\n    21|   * Handle the health check request.\\n    22|   *\\n    23|   * Returns a simple JSON response indicating the server is healthy\\n    24|   * and able to accept requests.\\n    25|   *\\n    26|   * @param request - The HTTP request object\\n    27|   * @param connection - The connection object\\n    28|   * @returns Response with health status\\n    29|   */\\n    30|  __invoke(_request: IHttpRequest, _connection: Connection): Response {\\n    31|    return new Response({ health: \\\"OK\\\" });\\n    32|  }\\n    33|}\\n</search_result>\\n\\n<search_result path=\\\"src/protocols/pusher/http/controllers/controller.ts\\\" endLine=\\\"283\\\"></search_result>\\n<search_result path=\\\"src/servers/reverb/http/server.ts\\\" showSignaturesOnly=\\\"true\\\" startLine=\\\"39\\\" endLine=\\\"435\\\">\\n   40|export class Server {\\n</search_result>\\n<search_result path=\\\"reverb/src/Servers/Reverb/Http/Router.php\\\" startLine=\\\"41\\\" endLine=\\\"106\\\"></search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ChannelController.php\\\" endLine=\\\"25\\\"></search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ChannelsController.php\\\" endLine=\\\"25\\\"></search_result>\\n<search_result path=\\\"src/protocols/pusher/http/controllers/channel-controller.ts\\\" showSignaturesOnly=\\\"true\\\" startLine=\\\"22\\\" endLine=\\\"281\\\">\\n   23|export class ChannelController {\\n</search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ConnectionsController.php\\\" endLine=\\\"23\\\"></search_result>\",\n          \"codeResults\": [\n            {\n              ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "### Tool · read (completed)",
                    "lineNumber": 1385,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1386,
                    "isSignature": false
                  },
                  {
                    "text": "    * **path:** `src/servers/reverb/http/server.ts`",
                    "lineNumber": 1387,
                    "isSignature": false
                  },
                  {
                    "text": "    * **status:** success",
                    "lineNumber": 1388,
                    "isSignature": false
                  },
                  {
                    "text": "        * lines: 1-10",
                    "lineNumber": 1389,
                    "isSignature": false
                  },
                  {
                    "text": "    * **content:**",
                    "lineNumber": 1390,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1391,
                    "isSignature": false
                  },
                  {
                    "text": "    import type { ServerWebSocket } from \"bun\";",
                    "lineNumber": 1392,
                    "isSignature": false
                  },
                  {
                    "text": "    import type { ILogger } from \"../../../contracts/logger\";",
                    "lineNumber": 1393,
                    "isSignature": false
                  },
                  {
                    "text": "    import type { IHttpRequest, Router } from \"./router\";",
                    "lineNumber": 1394,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 1395,
                    "isSignature": false
                  },
                  {
                    "text": "    /**",
                    "lineNumber": 1396,
                    "isSignature": false
                  },
                  {
                    "text": "     * HTTP Server Implementation",
                    "lineNumber": 1397,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1398,
                    "isSignature": false
                  },
                  {
                    "text": "     * Main HTTP/WebSocket server that wraps Bun.serve() for handling incoming",
                    "lineNumber": 1399,
                    "isSignature": false
                  },
                  {
                    "text": "     * TCP connections, HTTP request parsing, routing, and WebSocket upgrades.",
                    "lineNumber": 1400,
                    "isSignature": false
                  },
                  {
                    "text": "     *",
                    "lineNumber": 1401,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1402,
                    "isSignature": false
                  },
                  {
                    "text": "### Tool · sem Search (completed)",
                    "lineNumber": 1403,
                    "isSignature": false
                  },
                  {
                    "text": "",
                    "lineNumber": 1404,
                    "isSignature": false
                  },
                  {
                    "text": "    {",
                    "lineNumber": 1405,
                    "isSignature": false
                  },
                  {
                    "text": "      \"args\": {",
                    "lineNumber": 1406,
                    "isSignature": false
                  },
                  {
                    "text": "        \"query\": \"How is the Response class from response.ts used in controllers?\",",
                    "lineNumber": 1407,
                    "isSignature": false
                  },
                  {
                    "text": "        \"targetDirectories\": [],",
                    "lineNumber": 1408,
                    "isSignature": false
                  },
                  {
                    "text": "        \"explanation\": \"\"",
                    "lineNumber": 1409,
                    "isSignature": false
                  },
                  {
                    "text": "      },",
                    "lineNumber": 1410,
                    "isSignature": false
                  },
                  {
                    "text": "      \"result\": {",
                    "lineNumber": 1411,
                    "isSignature": false
                  },
                  {
                    "text": "        \"success\": {",
                    "lineNumber": 1412,
                    "isSignature": false
                  },
                  {
                    "text": "          \"results\": \"<search_result path=\\\"src/servers/reverb/factory.ts\\\" startLine=\\\"184\\\" endLine=\\\"1290\\\">\\n   184|export class Factory {\\n   ...\\n  1250|\\n  1251|\\n  1252|  /**\\n  1253|   * Convert controller Response to Bun Response\\n  1254|   *\\n  1255|   * @param controllerResponse - The response from the controller\\n  1256|   * @returns Bun Response object\\n  1257|   *\\n  1258|   * @private\\n  1259|   */\\n  1260|  private static convertToResponse(controllerResponse: any): Response {\\n  1261|    // Check if it's our custom HttpResponse class\\n  1262|    if (controllerResponse instanceof HttpResponse) {\\n  1263|      const status = controllerResponse.getStatusCode();\\n  1264|      const body = controllerResponse.getContent();\\n  1265|      const headers = controllerResponse.getHeaders();\\n  1266|\\n  1267|      return new Response(body, {\\n  1268|        status,\\n  1269|        headers,\\n  1270|      });\\n  1271|    }\\n  1272|\\n  1273|    // Fallback for other response types\\n  1274|    const status = controllerResponse.status || 200;\\n  1275|    const body =\\n  1276|      typeof controllerResponse.content === \\\"string\\\"\\n  1277|        ? controllerResponse.content\\n  1278|        : JSON.stringify(controllerResponse.content);\\n  1279|\\n  1280|    return new Response(body, {\\n  1281|      status,\\n  1282|      headers: {\\n  1283|        \\\"Content-Type\\\":\\n  1284|          typeof controllerResponse.content === \\\"string\\\"\\n  1285|            ? \\\"text/plain\\\"\\n  1286|            : \\\"application/json\\\",\\n  1287|      },\\n  1288|    });\\n  1289|  }\\n  1290|}\\n</search_result>\\n<search_result path=\\\"src/servers/reverb/http/response.ts\\\" startLine=\\\"1\\\" endLine=\\\"264\\\">\\n     1|/**\\n     2| * HTTP Response class for JSON responses\\n     3| *\\n     4| * Represents an HTTP JSON response with support for:\\n     5| * - Custom status codes\\n     6| * - Custom headers\\n     7| * - Automatic Content-Length calculation\\n     8| * - Serialization to HTTP response format\\n     9| */\\n    10|export class Response {\\n    11|  /**\\n    12|   * The response body content (stringified JSON)\\n    13|   */\\n    14|  private content: string;\\n    15|\\n    16|  /**\\n    17|   * HTTP status code (e.g., 200, 404, 500)\\n    18|   */\\n    19|  private statusCode: number;\\n    20|\\n    21|  /**\\n    22|   * HTTP response headers\\n    23|   */\\n    24|  private headers: Map<string, string>;\\n    25|\\n    26|  /**\\n    27|   * Create a new HTTP Response instance\\n    28|   *\\n    29|   * @param data - The response data (will be JSON stringified)\\n    30|   * @param statusCode - HTTP status code (default: 200)\\n    31|   * @param headers - Object containing response headers\\n    32|   * @param json - Whether the data is already JSON string (default: false)\\n    33|   *\\n    34|   * @example\\n    35|   * ```typescript\\n    36|   * const response = new Response({ message: 'Hello' }, 200);\\n    37|   * const response = new Response({ error: 'Not found' }, 404);\\n    38|   * ```\\n    39|   */\\n    40|  constructor(\\n    41|    data: unknown = null,\\n    42|    statusCode = 200,\\n    43|    headers: Record<string, string> = {},\\n    44|    json = false,\\n    45|  ) {\\n    46|    this.statusCode = statusCode;\\n    47|    this.headers = new Map();\\n    48|\\n    49|    // Initialize headers from the provided object\\n    50|    Object.entries(headers).forEach(([key, value]) => {\\n    51|      this.headers.set(key, value);\\n    52|    });\\n    53|\\n    54|    // Set default Content-Type header for JSON responses if not already set\\n    55|    // Use case-insensitive check to avoid duplicate headers\\n    56|    if (!this.hasHeaderCaseInsensitive(\\\"Content-Type\\\")) {\\n    57|      this.headers.set(\\\"Content-Type\\\", \\\"application/json\\\");\\n    58|    }\\n    59|\\n    60|    // Stringify the content\\n    61|    if (json && typeof data === \\\"string\\\") {\\n    62|      this.content = data;\\n    63|    } else {\\n    64|      this.content = JSON.stringify(data);\\n    65|    }\\n    66|\\n    67|    // Automatically set Content-Length header\\n    68|    this.setContentLength();\\n    69|  }\\n    70|\\n    71|  /**\\n    72|   * Check if a header exists (case-insensitive)\\n    73|   *\\n    74|   * @param key - The header key to check (case-insensitive)\\n    75|   * @returns true if the header exists, false otherwise\\n    76|   *\\n    77|   * @private\\n    78|   */\\n   ...\\n   264|}\\n</search_result>\\n<search_result path=\\\"reverb/src/Servers/Reverb/Http/Response.php\\\" startLine=\\\"1\\\" endLine=\\\"18\\\">\\n     1|<?php\\n     2|\\n     3|namespace Laravel\\\\Reverb\\\\Servers\\\\Reverb\\\\Http;\\n     4|\\n     5|use Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse;\\n     6|\\n     7|class Response extends JsonResponse\\n     8|{\\n     9|    /**\\n    10|     * Create a new Http response instance.\\n    11|     */\\n    12|    public function __construct(mixed $data = null, int $status = 200, array $headers = [], bool $json = false)\\n    13|    {\\n    14|        parent::__construct($data, $status, $headers, $json);\\n    15|\\n    16|        $this->headers->set('Content-Length', (string) strlen($this->content));\\n    17|    }\\n    18|}\\n</search_result>\\n<search_result path=\\\"src/servers/reverb/http/router.ts\\\" startLine=\\\"26\\\" endLine=\\\"481\\\">\\n    26|export class Router {\\n   ...\\n    57|async dispatch(\\n    58|    request: IHttpRequest,\\n    59|    connection: Connection | null,\\n    60|  ): Promise<unknown> {\\n   ...\\n    94|\\n    95|\\n    96|      // Check if this is a WebSocket upgrade request\\n    97|      if (this.isWebSocketRequest(request)) {\\n    98|        if (!connection) {\\n    99|          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n   100|        }\\n   101|        const wsConnection = this.attemptUpgrade(request, connection);\\n   102|\\n   103|        // Call the controller with websocket connection and route parameters\\n   104|        const routeParams = this.extractRouteParams(route);\\n   105|        return await controller(\\n   106|          request,\\n   107|          wsConnection,\\n   108|          ...Object.values(routeParams),\\n   109|        );\\n   110|      }\\n   111|\\n   112|      // For HTTP requests, resolve parameters and call controller\\n   113|      const routeParameters = {\\n   114|        ...this.extractRouteParams(route),\\n   115|        request,\\n   116|        connection,\\n   117|      };\\n   118|\\n   119|      const args = this.arguments(controller, routeParameters);\\n   120|      const response = await controller(...args);\\n   121|\\n   122|      // Send response and close connection if connection exists\\n   123|      if (connection) {\\n   124|        return this.sendResponse(connection, response);\\n   125|      }\\n   126|      return response;\\n   127|    } catch (error) {\\n   128|      // Handle unexpected errors\\n   129|      if (connection) {\\n   130|        this.close(connection, 500, \\\"Internal server error.\\\");\\n   131|      }\\n   132|      throw error;\\n   133|    }\\n   134|  }\\n   135|\\n   136|  /**\\n   137|   * Get the controller callable for the given route\\n   138|   *\\n   139|   * @param route - The matched route object\\n   140|   * @returns The controller function/callback\\n   141|   *\\n   142|   * @private\\n   143|   */\\n   ...\\n   481|}\\n</search_result>\\n<search_result path=\\\"src/protocols/pusher/http/controllers/health-check-controller.ts\\\" startLine=\\\"2\\\" endLine=\\\"33\\\">\\n     2|import { Response } from \\\"../../../../servers/reverb/http/response\\\";\\n     3|import type { IHttpRequest } from \\\"../../../../servers/reverb/http/router\\\";\\n     4|import { Controller } from \\\"./controller\\\";\\n     5|\\n     6|/**\\n     7| * Health Check Controller\\n     8| *\\n     9| * Simple health check endpoint that returns 200 OK.\\n    10| * This endpoint is used for monitoring and load balancer health checks.\\n    11| *\\n    12| * @example\\n    13| * ```typescript\\n    14| * const controller = new HealthCheckController();\\n    15| * const response = controller.__invoke(request, connection);\\n    16| * // Returns: Response with {health: 'OK'}\\n    17| * ```\\n    18| */\\n    19|export class HealthCheckController extends Controller {\\n    20|  /**\\n    21|   * Handle the health check request.\\n    22|   *\\n    23|   * Returns a simple JSON response indicating the server is healthy\\n    24|   * and able to accept requests.\\n    25|   *\\n    26|   * @param request - The HTTP request object\\n    27|   * @param connection - The connection object\\n    28|   * @returns Response with health status\\n    29|   */\\n    30|  __invoke(_request: IHttpRequest, _connection: Connection): Response {\\n    31|    return new Response({ health: \\\"OK\\\" });\\n    32|  }\\n    33|}\\n</search_result>\\n\\n<search_result path=\\\"src/protocols/pusher/http/controllers/controller.ts\\\" endLine=\\\"283\\\"></search_result>\\n<search_result path=\\\"src/servers/reverb/http/server.ts\\\" showSignaturesOnly=\\\"true\\\" startLine=\\\"39\\\" endLine=\\\"435\\\">\\n   40|export class Server {\\n</search_result>\\n<search_result path=\\\"reverb/src/Servers/Reverb/Http/Router.php\\\" startLine=\\\"41\\\" endLine=\\\"106\\\"></search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ChannelController.php\\\" endLine=\\\"25\\\"></search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ChannelsController.php\\\" endLine=\\\"25\\\"></search_result>\\n<search_result path=\\\"src/protocols/pusher/http/controllers/channel-controller.ts\\\" showSignaturesOnly=\\\"true\\\" startLine=\\\"22\\\" endLine=\\\"281\\\">\\n   23|export class ChannelController {\\n</search_result>\\n<search_result path=\\\"reverb/src/Protocols/Pusher/Http/Controllers/ConnectionsController.php\\\" endLine=\\\"23\\\"></search_result>\",",
                    "lineNumber": 1413,
                    "isSignature": false
                  },
                  {
                    "text": "          \"codeResults\": [",
                    "lineNumber": 1414,
                    "isSignature": false
                  },
                  {
                    "text": "            {",
                    "lineNumber": 1415,
                    "isSignature": false
                  },
                  {
                    "text": "              ",
                    "lineNumber": 1416,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.21640175580978394
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-1150.md",
                "range": {
                  "startPosition": {
                    "line": 2196,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 2213,
                    "column": 22
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"src/servers/reverb/http/router.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 25,\n                    \"column\": 0\n                  },\n                  \"endPosition\": {\n                    \"line\": 480,\n                    \"column\": 1\n                  }\n                },\n                \"contents\": \"export class Router {\\nasync dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n}\",\n                \"signatures\": {\n                  \"ranges\": [\n                    {\n                      ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 2197,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 2198,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"src/servers/reverb/http/router.ts\",",
                    "lineNumber": 2199,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 2200,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 2201,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 25,",
                    "lineNumber": 2202,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 0",
                    "lineNumber": 2203,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 2204,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 2205,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 480,",
                    "lineNumber": 2206,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 1",
                    "lineNumber": 2207,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 2208,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 2209,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"export class Router {\\nasync dispatch(\\n    request: IHttpRequest,\\n    connection: Connection | null,\\n  ): Promise<unknown> {\\n\\n\\n      // Check if this is a WebSocket upgrade request\\n      if (this.isWebSocketRequest(request)) {\\n        if (!connection) {\\n          throw new Error(\\\"Connection required for WebSocket upgrade\\\");\\n        }\\n        const wsConnection = this.attemptUpgrade(request, connection);\\n\\n        // Call the controller with websocket connection and route parameters\\n        const routeParams = this.extractRouteParams(route);\\n        return await controller(\\n          request,\\n          wsConnection,\\n          ...Object.values(routeParams),\\n        );\\n      }\\n\\n      // For HTTP requests, resolve parameters and call controller\\n      const routeParameters = {\\n        ...this.extractRouteParams(route),\\n        request,\\n        connection,\\n      };\\n\\n      const args = this.arguments(controller, routeParameters);\\n      const response = await controller(...args);\\n\\n      // Send response and close connection if connection exists\\n      if (connection) {\\n        return this.sendResponse(connection, response);\\n      }\\n      return response;\\n    } catch (error) {\\n      // Handle unexpected errors\\n      if (connection) {\\n        this.close(connection, 500, \\\"Internal server error.\\\");\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get the controller callable for the given route\\n   *\\n   * @param route - The matched route object\\n   * @returns The controller function/callback\\n   *\\n   * @private\\n   */\\n}\",",
                    "lineNumber": 2210,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 2211,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": [",
                    "lineNumber": 2212,
                    "isSignature": false
                  },
                  {
                    "text": "                    {",
                    "lineNumber": 2213,
                    "isSignature": false
                  },
                  {
                    "text": "                      ",
                    "lineNumber": 2214,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.20955990254878998
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 13969,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 13986,
                    "column": 22
                  }
                },
                "contents": "            {\n              \"codeBlock\": {\n                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/Http/router.ts\",\n                \"range\": {\n                  \"startPosition\": {\n                    \"line\": 25,\n                    \"column\": 0\n                  },\n                  \"endPosition\": {\n                    \"line\": 419,\n                    \"column\": 1\n                  }\n                },\n                \"contents\": \"export class Router {\\n\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(request: IHttpRequest, connection: Connection): any {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader('sec-websocket-key');\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, 'Missing Sec-WebSocket-Key header.');\\n      throw new Error('WebSocket upgrade failed: missing Sec-WebSocket-Key');\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = 'HTTP/1.1 101 Switching Protocols\\\\r\\\\n';\\n    const headers = [\\n      'Upgrade: websocket',\\n      'Connection: Upgrade',\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      'X-Powered-By: Reverb',\\n    ];\\n\\n    const responseHeaders = headers.join('\\\\r\\\\n') + '\\\\r\\\\n\\\\r\\\\n';\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n}\",\n                \"signatures\": {\n                  \"ranges\": [\n                    {\n                      ",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "            {",
                    "lineNumber": 13970,
                    "isSignature": false
                  },
                  {
                    "text": "              \"codeBlock\": {",
                    "lineNumber": 13971,
                    "isSignature": false
                  },
                  {
                    "text": "                \"relativeWorkspacePath\": \"revurb-ts/src/Servers/Reverb/Http/router.ts\",",
                    "lineNumber": 13972,
                    "isSignature": false
                  },
                  {
                    "text": "                \"range\": {",
                    "lineNumber": 13973,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"startPosition\": {",
                    "lineNumber": 13974,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 25,",
                    "lineNumber": 13975,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 0",
                    "lineNumber": 13976,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 13977,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"endPosition\": {",
                    "lineNumber": 13978,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"line\": 419,",
                    "lineNumber": 13979,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"column\": 1",
                    "lineNumber": 13980,
                    "isSignature": false
                  },
                  {
                    "text": "                  }",
                    "lineNumber": 13981,
                    "isSignature": false
                  },
                  {
                    "text": "                },",
                    "lineNumber": 13982,
                    "isSignature": false
                  },
                  {
                    "text": "                \"contents\": \"export class Router {\\n\\n\\n  /**\\n   * Negotiate the WebSocket connection upgrade (RFC 6455 Handshake)\\n   *\\n   * This method implements the WebSocket opening handshake as defined in RFC 6455:\\n   * 1. Generates the Sec-WebSocket-Accept header using SHA-1 hash\\n   * 2. Creates the upgrade response with required headers\\n   * 3. Sends the response to the client\\n   * 4. Wraps the raw connection in a ReverbConnection\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4\\n   *\\n   * @param request - The HTTP request object\\n   * @param connection - The raw socket connection\\n   * @returns A new ReverbConnection instance for WebSocket communication\\n   *\\n   * @private\\n   */\\n  private attemptUpgrade(request: IHttpRequest, connection: Connection): any {\\n    // Get the Sec-WebSocket-Key from the request\\n    const secWebSocketKey = request.getHeader('sec-websocket-key');\\n\\n    if (!secWebSocketKey) {\\n      this.close(connection, 400, 'Missing Sec-WebSocket-Key header.');\\n      throw new Error('WebSocket upgrade failed: missing Sec-WebSocket-Key');\\n    }\\n\\n    // Generate the accept key using RFC 6455 algorithm\\n    const acceptKey = this.generateAcceptKey(secWebSocketKey);\\n\\n    // Build the upgrade response\\n    const statusLine = 'HTTP/1.1 101 Switching Protocols\\\\r\\\\n';\\n    const headers = [\\n      'Upgrade: websocket',\\n      'Connection: Upgrade',\\n      `Sec-WebSocket-Accept: ${acceptKey}`,\\n      'X-Powered-By: Reverb',\\n    ];\\n\\n    const responseHeaders = headers.join('\\\\r\\\\n') + '\\\\r\\\\n\\\\r\\\\n';\\n    const upgradeResponse = statusLine + responseHeaders;\\n\\n    // Send the upgrade response\\n    connection.send(upgradeResponse);\\n\\n    // Return the connection wrapped as a WebSocket connection\\n    // In a real implementation, this would wrap the raw connection\\n    // For now, return the connection as-is (the actual WebSocket upgrade\\n    // would be handled by the underlying socket layer)\\n    return connection;\\n  }\\n\\n  /**\\n   * Generate the Sec-WebSocket-Accept header value (RFC 6455)\\n   *\\n   * The accept key is generated by:\\n   * 1. Concatenating the client's Sec-WebSocket-Key with the magic GUID\\n   * 2. Generating a SHA-1 hash of the concatenated string\\n   * 3. Base64 encoding the hash\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-4.2.2\\n   *\\n   * @param secWebSocketKey - The client's Sec-WebSocket-Key header value\\n   * @returns The Sec-WebSocket-Accept header value\\n   *\\n   * @private\\n   */\\n}\",",
                    "lineNumber": 13983,
                    "isSignature": false
                  },
                  {
                    "text": "                \"signatures\": {",
                    "lineNumber": 13984,
                    "isSignature": false
                  },
                  {
                    "text": "                  \"ranges\": [",
                    "lineNumber": 13985,
                    "isSignature": false
                  },
                  {
                    "text": "                    {",
                    "lineNumber": 13986,
                    "isSignature": false
                  },
                  {
                    "text": "                      ",
                    "lineNumber": 13987,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.20430119335651398
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-12-2308.md",
                "range": {
                  "startPosition": {
                    "line": 10669,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 10726,
                    "column": 0
                  }
                },
                "contents": "                  {\n                    \"text\": \" *     this.connection.close();\",\n                    \"lineNumber\": 74,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \" *   }\",\n                    \"lineNumber\": 75,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \" * }\",\n                    \"lineNumber\": 76,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \" * ```\",\n                    \"lineNumber\": 77,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \" */\",\n                    \"lineNumber\": 78,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"export abstract class Connection {\",\n                    \"lineNumber\": 79,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"  /**\",\n                    \"lineNumber\": 80,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"   * The last time the connection was seen (in seconds, not milliseconds).\",\n                    \"lineNumber\": 81,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"   *\",\n                    \"lineNumber\": 82,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"   * Initialized to current time when connection is created.\",\n                    \"lineNumber\": 83,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"   * Updated via touch() when activity is detected.\",\n                    \"lineNumber\": 84,\n                    \"isSignature\": false\n                  },\n                  {\n                    \"text\": \"   * Used to determine connection state (active/inactive/stale).\",",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "                  {",
                    "lineNumber": 10670,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \" *     this.connection.close();\",",
                    "lineNumber": 10671,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 74,",
                    "lineNumber": 10672,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10673,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10674,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10675,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \" *   }\",",
                    "lineNumber": 10676,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 75,",
                    "lineNumber": 10677,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10678,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10679,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10680,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \" * }\",",
                    "lineNumber": 10681,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 76,",
                    "lineNumber": 10682,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10683,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10684,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10685,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \" * ```\",",
                    "lineNumber": 10686,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 77,",
                    "lineNumber": 10687,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10688,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10689,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10690,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \" */\",",
                    "lineNumber": 10691,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 78,",
                    "lineNumber": 10692,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10693,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10694,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10695,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"export abstract class Connection {\",",
                    "lineNumber": 10696,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 79,",
                    "lineNumber": 10697,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10698,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10699,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10700,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"  /**\",",
                    "lineNumber": 10701,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 80,",
                    "lineNumber": 10702,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10703,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10704,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10705,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"   * The last time the connection was seen (in seconds, not milliseconds).\",",
                    "lineNumber": 10706,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 81,",
                    "lineNumber": 10707,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10708,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10709,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10710,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"   *\",",
                    "lineNumber": 10711,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 82,",
                    "lineNumber": 10712,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10713,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10714,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10715,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"   * Initialized to current time when connection is created.\",",
                    "lineNumber": 10716,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 83,",
                    "lineNumber": 10717,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10718,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10719,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10720,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"   * Updated via touch() when activity is detected.\",",
                    "lineNumber": 10721,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"lineNumber\": 84,",
                    "lineNumber": 10722,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"isSignature\": false",
                    "lineNumber": 10723,
                    "isSignature": false
                  },
                  {
                    "text": "                  },",
                    "lineNumber": 10724,
                    "isSignature": false
                  },
                  {
                    "text": "                  {",
                    "lineNumber": 10725,
                    "isSignature": false
                  },
                  {
                    "text": "                    \"text\": \"   * Used to determine connection state (active/inactive/stale).\",",
                    "lineNumber": 10726,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.1980198621749878
            },
            {
              "codeBlock": {
                "relativeWorkspacePath": "specs/logs/composer-2025-11-13-1150.md",
                "range": {
                  "startPosition": {
                    "line": 5703,
                    "column": 0
                  },
                  "endPosition": {
                    "line": 5766,
                    "column": 0
                  }
                },
                "contents": "    \n      /**\n       * Create a new instance of the Redis client\n       *\n       * @param logger - Logger instance for connection events\n       * @param clientFactory - Factory for creating Redis client connections\n       * @param channel - The Redis channel name (for logging/identification)\n       * @param server - Redis server configuration\n       * @param onConnect - Optional callback invoked when connection is established\n       */\n      constructor(\n        protected logger: ILogger,\n        protected clientFactory: RedisClientFactory,\n        protected channel: string,\n        protected server: RedisServerConfig,\n        protected onConnect?: ((client: IRedisClient) => void) | null,\n      ) {\n        super();\n      }\n    \n      /**\n       * Create a new connection to the Redis server\n       */\n      public async connect(): Promise<void> {\n        try {\n          const client = await this.clientFactory.make(this.redisUrl());\n          this.onConnection(client);\n        } catch (exception) {\n          this.onFailedConnection(exception as Error);\n        }\n      }\n    \n      /**\n       * Attempt to reconnect to the Redis server\n       *\n       * Schedules a reconnection attempt after 1 second if retries are enabled\n       */\n      public reconnect(): void {\n        if (!this.shouldRetry) {\n          return;\n        }\n    \n        this.reconnectTimer = setTimeout(() => this.attemptReconnection(), 1000);\n      }\n    \n      /**\n       * Disconnect from the Redis server\n       *\n       * Disables auto-reconnection and closes the client connection\n       */\n      public disconnect(): void {\n        this.shouldRetry = false;\n    \n        if (this.reconnectTimer) {\n          clearTimeout(this.reconnectTimer);\n          this.reconnectTimer = null;\n        }\n    \n        this.client?.quit();\n      }\n    \n      /**\n       * Listen for a given event from the Redis client",
                "signatures": {
                  "ranges": []
                },
                "detailedLines": [
                  {
                    "text": "    ",
                    "lineNumber": 5704,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 5705,
                    "isSignature": false
                  },
                  {
                    "text": "       * Create a new instance of the Redis client",
                    "lineNumber": 5706,
                    "isSignature": false
                  },
                  {
                    "text": "       *",
                    "lineNumber": 5707,
                    "isSignature": false
                  },
                  {
                    "text": "       * @param logger - Logger instance for connection events",
                    "lineNumber": 5708,
                    "isSignature": false
                  },
                  {
                    "text": "       * @param clientFactory - Factory for creating Redis client connections",
                    "lineNumber": 5709,
                    "isSignature": false
                  },
                  {
                    "text": "       * @param channel - The Redis channel name (for logging/identification)",
                    "lineNumber": 5710,
                    "isSignature": false
                  },
                  {
                    "text": "       * @param server - Redis server configuration",
                    "lineNumber": 5711,
                    "isSignature": false
                  },
                  {
                    "text": "       * @param onConnect - Optional callback invoked when connection is established",
                    "lineNumber": 5712,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 5713,
                    "isSignature": false
                  },
                  {
                    "text": "      constructor(",
                    "lineNumber": 5714,
                    "isSignature": false
                  },
                  {
                    "text": "        protected logger: ILogger,",
                    "lineNumber": 5715,
                    "isSignature": false
                  },
                  {
                    "text": "        protected clientFactory: RedisClientFactory,",
                    "lineNumber": 5716,
                    "isSignature": false
                  },
                  {
                    "text": "        protected channel: string,",
                    "lineNumber": 5717,
                    "isSignature": false
                  },
                  {
                    "text": "        protected server: RedisServerConfig,",
                    "lineNumber": 5718,
                    "isSignature": false
                  },
                  {
                    "text": "        protected onConnect?: ((client: IRedisClient) => void) | null,",
                    "lineNumber": 5719,
                    "isSignature": false
                  },
                  {
                    "text": "      ) {",
                    "lineNumber": 5720,
                    "isSignature": false
                  },
                  {
                    "text": "        super();",
                    "lineNumber": 5721,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5722,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5723,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 5724,
                    "isSignature": false
                  },
                  {
                    "text": "       * Create a new connection to the Redis server",
                    "lineNumber": 5725,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 5726,
                    "isSignature": false
                  },
                  {
                    "text": "      public async connect(): Promise<void> {",
                    "lineNumber": 5727,
                    "isSignature": false
                  },
                  {
                    "text": "        try {",
                    "lineNumber": 5728,
                    "isSignature": false
                  },
                  {
                    "text": "          const client = await this.clientFactory.make(this.redisUrl());",
                    "lineNumber": 5729,
                    "isSignature": false
                  },
                  {
                    "text": "          this.onConnection(client);",
                    "lineNumber": 5730,
                    "isSignature": false
                  },
                  {
                    "text": "        } catch (exception) {",
                    "lineNumber": 5731,
                    "isSignature": false
                  },
                  {
                    "text": "          this.onFailedConnection(exception as Error);",
                    "lineNumber": 5732,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 5733,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5734,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5735,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 5736,
                    "isSignature": false
                  },
                  {
                    "text": "       * Attempt to reconnect to the Redis server",
                    "lineNumber": 5737,
                    "isSignature": false
                  },
                  {
                    "text": "       *",
                    "lineNumber": 5738,
                    "isSignature": false
                  },
                  {
                    "text": "       * Schedules a reconnection attempt after 1 second if retries are enabled",
                    "lineNumber": 5739,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 5740,
                    "isSignature": false
                  },
                  {
                    "text": "      public reconnect(): void {",
                    "lineNumber": 5741,
                    "isSignature": false
                  },
                  {
                    "text": "        if (!this.shouldRetry) {",
                    "lineNumber": 5742,
                    "isSignature": false
                  },
                  {
                    "text": "          return;",
                    "lineNumber": 5743,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 5744,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5745,
                    "isSignature": false
                  },
                  {
                    "text": "        this.reconnectTimer = setTimeout(() => this.attemptReconnection(), 1000);",
                    "lineNumber": 5746,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5747,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5748,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 5749,
                    "isSignature": false
                  },
                  {
                    "text": "       * Disconnect from the Redis server",
                    "lineNumber": 5750,
                    "isSignature": false
                  },
                  {
                    "text": "       *",
                    "lineNumber": 5751,
                    "isSignature": false
                  },
                  {
                    "text": "       * Disables auto-reconnection and closes the client connection",
                    "lineNumber": 5752,
                    "isSignature": false
                  },
                  {
                    "text": "       */",
                    "lineNumber": 5753,
                    "isSignature": false
                  },
                  {
                    "text": "      public disconnect(): void {",
                    "lineNumber": 5754,
                    "isSignature": false
                  },
                  {
                    "text": "        this.shouldRetry = false;",
                    "lineNumber": 5755,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5756,
                    "isSignature": false
                  },
                  {
                    "text": "        if (this.reconnectTimer) {",
                    "lineNumber": 5757,
                    "isSignature": false
                  },
                  {
                    "text": "          clearTimeout(this.reconnectTimer);",
                    "lineNumber": 5758,
                    "isSignature": false
                  },
                  {
                    "text": "          this.reconnectTimer = null;",
                    "lineNumber": 5759,
                    "isSignature": false
                  },
                  {
                    "text": "        }",
                    "lineNumber": 5760,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5761,
                    "isSignature": false
                  },
                  {
                    "text": "        this.client?.quit();",
                    "lineNumber": 5762,
                    "isSignature": false
                  },
                  {
                    "text": "      }",
                    "lineNumber": 5763,
                    "isSignature": false
                  },
                  {
                    "text": "    ",
                    "lineNumber": 5764,
                    "isSignature": false
                  },
                  {
                    "text": "      /**",
                    "lineNumber": 5765,
                    "isSignature": false
                  },
                  {
                    "text": "       * Listen for a given event from the Redis client",
                    "lineNumber": 5766,
                    "isSignature": false
                  }
                ]
              },
              "score": 0.1970733404159546
            }
          ]
        }
      }
    }

### Assistant

Pushing the commit, then verifying the review issues:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | grep -i "error\|TS2345\|TS2353" || echo "No type errors found"`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | grep -i "noExplicitAny\|any" || echo "No any type lint errors found"`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run lint 2>&1 | grep -i "noExplicitAny\|any" || echo "No any type lint errors found"`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    No any type lint errors found

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && bun run typecheck 2>&1 | grep -i "error\|TS2345\|TS2353" || echo "No type errors found"`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    No type errors found

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stderr:**

    To github.com:tomnagengast/revurb.git
       97c385e..dc3fa1c  main -> main

### Assistant

Typecheck and lint pass. Review mentions issues that appear resolved. Verifying the specific review points by checking the mentioned code sections:

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · read (started)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** pending

### Tool · grep (started)

    {
      "args": {
        "pattern": "lastSeenAt|hasBeenPinged",
        "path": "/Users/tom/personal/revurb/src/servers/reverb/http/connection.ts",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_76a9e17f-67b8-4576-b963-c7a7efbfb03"
      }
    }

### Tool · update Todos (started)

    {
      "args": {
        "todos": [
          {
            "id": "2",
            "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "3",
            "content": "Fix lint errors - replace any types with concrete types in test files",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "5",
            "content": "Commit and push changes",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          }
        ],
        "merge": true
      }
    }

### Tool · update Todos (completed)

    {
      "args": {
        "todos": [
          {
            "id": "2",
            "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "3",
            "content": "Fix lint errors - replace any types with concrete types in test files",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "4",
            "content": "Run typecheck and lint to verify fixes",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          },
          {
            "id": "5",
            "content": "Commit and push changes",
            "status": "TODO_STATUS_COMPLETED",
            "createdAt": "1763064925831",
            "updatedAt": "1763064992456",
            "dependencies": []
          }
        ],
        "merge": true
      },
      "result": {
        "success": {
          "todos": [
            {
              "id": "1",
              "content": "Fix convertToHttpRequest() - remove headers property from return type or extend IHttpRequest interface",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064967368",
              "dependencies": []
            },
            {
              "id": "2",
              "content": "Fix createHttpConnection() - ensure it satisfies Connection contract or change controller signature",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064992456",
              "dependencies": []
            },
            {
              "id": "3",
              "content": "Fix lint errors - replace any types with concrete types in test files",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064992456",
              "dependencies": []
            },
            {
              "id": "4",
              "content": "Run typecheck and lint to verify fixes",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064992456",
              "dependencies": []
            },
            {
              "id": "5",
              "content": "Commit and push changes",
              "status": "TODO_STATUS_COMPLETED",
              "createdAt": "1763064925831",
              "updatedAt": "1763064992456",
              "dependencies": []
            }
          ],
          "totalCount": 5
        }
      }
    }

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 845-854
    * **content:**

          const response = await Factory.eventsBatchController.handle(
            httpRequest,
            httpConnection,
            params.appId,
            app,
            channelManager,
          );
    
          return Factory.convertToResponse(response);
        } catch (error) {

### Tool · read (completed)

    * **path:** `src/servers/reverb/factory.ts`
    * **status:** success
        * lines: 1186-1220
    * **content:**

        const request: IHttpRequest & {
          url: string;
          httpVersion: string;
          getSize(): number;
        } = {
          method,
          path: pathWithQuery,
          url: req.url, // Include full URL with query string for controllers to access query params
          httpVersion: "1.1",
          body,
          getMethod(): string {
            return method;
          },
          getPath(): string {
            // Return path without query string for Pusher signature verification
            // Pusher signatures are calculated over the path without the query string
            return pathWithoutQuery;
          },
          getHost(): string {
            return host;
          },
          getHeader(name: string): string | undefined {
            return headers[name.toLowerCase()];
          },
          getHeaders(): Record<string, string> {
            return { ...headers };
          },
          getUri(): { path: string; host: string } {
            return { path: pathWithoutQuery, host };
          },
          getSize(): number {
            return Buffer.byteLength(body, "utf8");
          },
        };

### Tool · grep (completed)

    {
      "args": {
        "pattern": "lastSeenAt|hasBeenPinged",
        "path": "/Users/tom/personal/revurb/src/servers/reverb/http/connection.ts",
        "caseInsensitive": false,
        "multiline": false,
        "toolCallId": "tool_76a9e17f-67b8-4576-b963-c7a7efbfb03"
      },
      "result": {
        "success": {
          "pattern": "lastSeenAt|hasBeenPinged",
          "path": "/Users/tom/personal/revurb/src/servers/reverb/http/connection.ts",
          "outputMode": "content",
          "workspaceResults": {
            "/Users/tom/personal/revurb": {
              "content": {
                "matches": [],
                "totalLines": 0,
                "totalMatchedLines": 0,
                "clientTruncated": false,
                "ripgrepTruncated": false
              }
            }
          }
        }
      }
    }

### Assistant

All issues appear resolved. Creating a summary note:

### Tool · edit (started)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/notes/2025-01-13-1400-review-fixes-summary.md"
      }
    }

### Tool · edit (completed)

    {
      "args": {
        "path": "/Users/tom/personal/revurb/notes/2025-01-13-1400-review-fixes-summary.md"
      },
      "result": {
        "success": {
          "path": "/Users/tom/personal/revurb/notes/2025-01-13-1400-review-fixes-summary.md",
          "resultForModel": "",
          "linesAdded": 22,
          "linesRemoved": 0,
          "diffString": "+ # Review Fixes Summary - 2025-01-13 14:00\n  \n+ ## Status\n+ All review issues from `specs/review.md` (commit deb78c1) have been addressed:\n+ \n+ 1. ✅ **convertToHttpRequest() return type** - Fixed formatting issue with explicit type annotation\n+ 2. ✅ **createHttpConnection() Connection contract** - Verified that `HttpConnection` correctly matches the expected type (`Connection` from `http/connection`, not `contracts/connection`)\n+ 3. ✅ **Lint errors** - No `any` types found in test files (all use `unknown` where appropriate)\n+ \n+ ## Changes Made\n+ - Fixed formatting in `src/servers/reverb/factory.ts` `convertToHttpRequest()` method to use multi-line type annotation\n+ \n+ ## Verification\n+ - ✅ `bun run typecheck` - Passes with no errors\n+ - ✅ `bun run lint` - Passes with no errors\n+ - ✅ No `any` types found in test files\n+ - ✅ No TypeScript errors (TS2345, TS2353) found\n+ \n+ ## Notes\n+ The review comments appear to be based on an outdated understanding. The current implementation is correct:\n+ - `EventsBatchController.handle` expects `Connection` from `http/connection` (HttpConnection), not from `contracts/connection`\n+ - `HttpConnection` is a simple HTTP connection wrapper and doesn't need WebSocket connection properties like `lastSeenAt` or `hasBeenPinged`\n+ - All type checks pass, confirming the types are correct",
          "afterFullFileContent": "# Review Fixes Summary - 2025-01-13 14:00\n\n## Status\nAll review issues from `specs/review.md` (commit deb78c1) have been addressed:\n\n1. ✅ **convertToHttpRequest() return type** - Fixed formatting issue with explicit type annotation\n2. ✅ **createHttpConnection() Connection contract** - Verified that `HttpConnection` correctly matches the expected type (`Connection` from `http/connection`, not `contracts/connection`)\n3. ✅ **Lint errors** - No `any` types found in test files (all use `unknown` where appropriate)\n\n## Changes Made\n- Fixed formatting in `src/servers/reverb/factory.ts` `convertToHttpRequest()` method to use multi-line type annotation\n\n## Verification\n- ✅ `bun run typecheck` - Passes with no errors\n- ✅ `bun run lint` - Passes with no errors\n- ✅ No `any` types found in test files\n- ✅ No TypeScript errors (TS2345, TS2353) found\n\n## Notes\nThe review comments appear to be based on an outdated understanding. The current implementation is correct:\n- `EventsBatchController.handle` expects `Connection` from `http/connection` (HttpConnection), not from `contracts/connection`\n- `HttpConnection` is a simple HTTP connection wrapper and doesn't need WebSocket connection properties like `lastSeenAt` or `hasBeenPinged`\n- All type checks pass, confirming the types are correct\n"
        }
      }
    }

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git add notes/2025-01-13-1400-review-fixes-summary.md && git commit -m "Add summary of review fixes verification"`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git push`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stderr:**

    Everything up-to-date

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git add notes/2025-01-13-1400-review-fixes-summary.md && git commit -m "Add summary of review fixes verification"`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    [main 1fddd18] Add summary of review fixes verification
     1 file changed, 23 insertions(+)
     create mode 100644 notes/2025-01-13-1400-review-fixes-summary.md

    * **stderr:**

    $ biome check --write .
    Checked 110 files in 45ms. No fixes applied.
    $ tsc --noEmit

### Assistant

Checking git status:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git status`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git log --oneline -3`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git log --oneline -3`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    1fddd18 Add summary of review fixes verification
    dc3fa1c Fix convertToHttpRequest return type formatting
    97c385e Fix Factory: remove headers property from convertToHttpRequest and properly instantiate HttpConnection

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git status`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stdout:**

    On branch main
    Your branch is ahead of 'origin/main' by 1 commit.
      (use "git push" to publish your local commits)
    
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
    	modified:   scripts/ralph/sync.sh
    
    Untracked files:
      (use "git add <file>..." to include in what will be committed)
    	notes/2025-11-13-1300-review-fixes.md
    	specs/logs/codex-2025-11-13-1200.md
    	specs/logs/composer-2025-11-13-1208.md
    	specs/logs/composer-2025-11-13-1213.md
    
    no changes added to commit (use "git add" and/or "git commit -a")

### Assistant

Pushing the commit:

### Tool · shell (started)

    * **command:** `cd /Users/tom/personal/revurb && git push origin main`
    * **cwd:** `.`
    * **status:** pending

### Tool · shell (completed)

    * **command:** `cd /Users/tom/personal/revurb && git push origin main`
    * **cwd:** `.`
    * **status:** success
        * exit: 0
    * **stderr:**

    To github.com:tomnagengast/revurb.git
       dc3fa1c..1fddd18  main -> main

### Assistant

## Summary

Addressed the review feedback from specs/review.md:

### Issues addressed

    1. `convertToHttpRequest()` return type — Fixed formatting by using a multi-line type annotation for the intersection type.
    2. `createHttpConnection()` Connection contract — Verified correct: `EventsBatchController.handle` expects `Connection` from `http/connection` (HttpConnection), not from `contracts/connection`. `HttpConnection` is an HTTP connection wrapper and doesn't need WebSocket properties like `lastSeenAt` or `hasBeenPinged`.
    3. Lint errors — No `any` types found in test files; they use `unknown` where appropriate.

### Verification

    * `bun run typecheck` — Passes with no errors
    * `bun run lint` — Passes with no errors
    * No TypeScript errors (TS2345, TS2353) found
    * No `any` type violations found

### Commits made

    1. `dc3fa1c` — Fix convertToHttpRequest return type formatting
    2. `1fddd18` — Add summary of review fixes verification

All changes have been committed and pushed. The review comments appear to be based on an outdated understanding; the current implementation is correct and all checks pass.

### Result

Reviewing AGENTS.md and ./specs/review.md to determine next steps.

Review status is "not ok". Addressing the review feedback. Examining the relevant files:

Reviewing the Connection contract and HttpConnection implementation:

Checking what EventsBatchController.handle expects:

Checking the PHP implementation to understand the expected connection type:

Running lint to identify the exact issues:

Checking the specific files mentioned in the review:

Searching for explicit any types:

Checking the Connection import in EventsBatchController:

Creating a todo list and starting fixes:

Fixing the issues. Starting with convertToHttpRequest(): ensuring the return type matches IHttpRequest without excess properties.

Checking the Connection type issue. Reviewing how HttpConnection is used and what the controller expects:

Running typecheck to see the actual errors:

Running typecheck to see all errors:

Typecheck passes. Checking lint errors, focusing on the specific lines mentioned in the review:

Running lint to see the actual errors:

Fixing the formatting issue:

Checking for remaining lint issues and verifying the review comments. Review mentions any types, but I see unknown. Checking if the review is outdated or if there are other issues:

Both lint and typecheck pass. The review may be outdated. Verifying the Connection type issue by checking the actual signature:

Checking for any types in the test files mentioned in the review:

No any types found. Lint and typecheck pass. Committing the fix:

Checking git status and verifying the review issues. Review mentions Connection type issues; verifying the current state:

Pushing the commit, then verifying the review issues:

Typecheck and lint pass. Review mentions issues that appear resolved. Verifying the specific review points by checking the mentioned code sections:

All issues appear resolved. Creating a summary note:

Checking git status:

Pushing the commit:

## Summary

Addressed the review feedback from specs/review.md:

### Issues addressed

    1. `convertToHttpRequest()` return type — Fixed formatting by using a multi-line type annotation for the intersection type.
    2. `createHttpConnection()` Connection contract — Verified correct: `EventsBatchController.handle` expects `Connection` from `http/connection` (HttpConnection), not from `contracts/connection`. `HttpConnection` is an HTTP connection wrapper and doesn't need WebSocket properties like `lastSeenAt` or `hasBeenPinged`.
    3. Lint errors — No `any` types found in test files; they use `unknown` where appropriate.

### Verification

    * `bun run typecheck` — Passes with no errors
    * `bun run lint` — Passes with no errors
    * No TypeScript errors (TS2345, TS2353) found
    * No `any` type violations found

### Commits made

    1. `dc3fa1c` — Fix convertToHttpRequest return type formatting
    2. `1fddd18` — Add summary of review fixes verification

All changes have been committed and pushed. The review comments appear to be based on an outdated understanding; the current implementation is correct and all checks pass.

    * **duration:** 173567 ms

### stderr

    
    Error (unhandledRejection): WritableIterable is closed
    Error: WritableIterable is closed
        at Object.close (/Users/tom/.local/share/cursor-agent/versions/2025.11.06-8fe8a63/index.js:234689:42)
        at ForkableIterable.<anonymous> (/Users/tom/.local/share/cursor-agent/versions/2025.11.06-8fe8a63/index.js:234816:26)
        at Generator.next (<anonymous>)
        at fulfilled (/Users/tom/.local/share/cursor-agent/versions/2025.11.06-8fe8a63/index.js:234751:58)
        at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
